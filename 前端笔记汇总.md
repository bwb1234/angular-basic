# 1.1 html

HTML： 超文本标记语言, 带有**特殊标记**的文本语言,**特殊标记指尖括号**

学习HTML就是认识标签nt>

```html
锚点定位:可以实现页面之内的跳转
 锚： <a href=“#id名”>跳转</a>
 点:  <h3 id=”名”>新位置</a>
base标签:可以设置页面所有链接标签的属性，例如新窗口中打开。
<base target=“_blank”/>
注意： base标签一般写在head标签中
```

表格

```html
总结： 
1.表格的基本标签  table  tr  td  th  thead  tbody  caption  
2.表格的基本属性  width  height  align cellspacing  cellpadding  border
表格合并： colspan  rowspan
注意: 当表格不给宽高时，表格大小由内容撑开。
跨行合并:  rowspan=2    增加高度
跨列合并:  colspan=2     增加宽度
```

列表

```
无序列表	<ul> <li> </li> </ul>
有序列表	<ol> <li> </li> </ol>
自定义列表	<dl> <dt> </dt>  <dd> </dd> </dl>
注意: 自定义列表中 dt和dd不是包裹关系。
注意: 一个dl可以有多个dt，一个dt可以有多个dd
```

表单

```
表单可以收集用户的数据。
表单包含三部分： 表单域， 表单元素，提示信息
使用label标签可以实现点击文字，选中文本框
如果有两个表单，可以写两个label使用，或者使用for,id写法。
```

# 1.2 css: 层叠样式表

css简单介绍

```
CSS的作用: 美化页面, 结构样式相分离
CSS的实现：  宽高，边框，颜色，位置，字体，图片等
行内样式标签写在标签上。 
  <div style=”color:red; ”></div>
内嵌样式表写在head标签中
外链样式表写在单独的css文件中，通过link标签引入。
  <link type=“text/css”rel=“stylesheet” href=“名字.css”/>
```

#### css复合选择器:

```
后代选择器: 选择器A  选择器B{}     //用空格隔开
子代选择器: 选择器A > 选择器B{}     //用大于号隔开
交集选择器: 标签.类名{属性:属性值;}    即..又..的关系
并集选择器: 选择器A， 选择器B{}     //用逗号隔开
链接伪类选择器: 
    a:link       /* 未访问的链接 */
    a:visited    /* 已访问的链接 */
    a:hover     /* 鼠标移动到链接上 */
    a:active     /* 选定的链接 */
    平时我们只用:hover,其他不用
```

#### 标签显示模式

```
1. 标签元素特点：
    1.有宽高
    2. 独占一行
块级元素两者都有：富人（有宽高，独占）
行内元素两者都没有：穷人（无宽高，不独占）
行内块元素有其一： 中产阶级（有宽高，不独占）
典型的块级元素： h1  p  ul ol  li  table  div form （最重要）
典型的行内元素：strong   u  b I  em  ins del  a  span （最重要）
典型的行内块元素： img  input

注意： 块级元素的如果没有宽，默认通栏100%   

2.显示模式的转换display
口诀： 爱它就给它display
 display：
     block;      	块级元素
     inline;      	行内元素
     inline-block; 	行内块元素
```

#### 行高和高

```
单行文本垂直居中: line-height行高=高height
height > line-height   文字偏上
height < line-height   文字偏下
没有高时，行高也能撑大盒子，但不是高属性
```

#### 背景属性设置

```
background-color:red;  背景颜色  
可以用rgba(255,255,255,0.3)
最后一个值是alpha透明度,不会影响盒子内容的透明度
opacity: 透明度  子盒子会继承,并且会影响内容
background-image:url(); 背景图片
background-repeat:  no-repeat;  背景平铺
                    repeat-x;   x轴平铺
                    repeat-y;   y轴平铺
background-position: X轴 Y轴;  背景位置
					left  top;   方位名词单位									10px 100px;   具体数值单位
background-attachment: fixed; 背景固定
background: url() no-repeat 0 0 red fixed;
注意： 背景属于复合属性， 重复使用会覆盖前面已经写好的属性。
注意： 背景属性有很多单值，按需填写，不需要可以不写。
```

#### 盒子模型

```
盒子模型包含3部分:   边框  + 宽度  + 内边距  + 外边距（不属于盒子内）
边框:boder: 边框大小  边框类型  边框颜色
padding导致盒子变大，这个时候减去对应的大小即可
没有设置width属性的值（继承宽度），不会被撑大。
外边距使用过程中经常会出现两个问题： 
	1. 外边距合并问题(上下两个盒子都设置外边距,在两个盒子中间的距离是两个margin中的较大值,而不是和 , 解决方法是:给其中一个盒子距离即可)  
	2 外边距塌陷问题 (父子盒子都有margin-top,结果不起作用 , 解决方法:给父盒子 overflow:hidden;)

圆角: border-radius: 左上角 右上角  右下角  左下角；
阴影: box-shadow : x轴偏移,y轴偏移,模糊距离,阴影尺寸,颜色,内外阴影;
```

#### 居中问题

```
块级盒子垂直水平居中 : position:absolate;
					left:0;
					top:0;
					right:0;
					bottom:0;
					margin: auto； 
注意：  使用margin:0 auto;让盒子的居中的前提
 		1. 元素必须是块级元素
		2. 元素必须有宽度
		
块级盒子垂直水平居中: 
                {position-absolute;
                    left:50%;
                    top:50%;
                    margin-top:-盒子高度的一半
                    margin-right:-盒子宽度的一半
            	} 
单行文字水平居中 : text-align:center;   
文字垂直居中 : line-height:高度；   

行内元素或行内快元素垂直对齐 : vertical-align：middle;   
```

#### 浮动

```css
浮动可以解决快速左右对齐的布局方式
float = 行内块 + 快速左右对齐 + 漂浮
浮动的作用：　让多个盒子在一行上显示。
解决网页排版盒子不能在一行上的问题。
 float:left;   左浮动      
 float:right;  右浮动
 浮动元素脱标不稳定,需要有一个标准流父元素
 为什么要清除浮动? --清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题,。
解决办法: 有4种
	1.overflow:hidden : 给父级添加： overflow: hidden
	
    2.额外标签+clear属性:	在浮动元素末尾添加一个空标签
	<div style=”clear:both”></div>
	
    3.单伪元素法
    .clearfix:after{
　　　　　　content:"";//设置内容为空
　　　　　　height:0;//高度为0
　　　　　　line-height:0;//行高为0
　　　　　　display:block;//将文本转为块级元素
　　　　　　visibility:hidden;//将元素隐藏
　　　　　　clear:both//清除浮动
　　　　　}

　　　　.clearfix{
　　　　　　zoom:1;为了兼容IE
　　　　}
　　　　
    4.双伪元素法
    	.clearfix:before,
    	.clearfix:after {
             content: "";
             display: block;
             clear: both;
        }

        .clearfix {
             zoom: 1;
        }
    
    第一种方法会将超出部分隐藏在某些时候我们想清除浮动并且保留超出部分时做不到,第二种方法会增加许多不必要的标签,所以我们尽量使用第三种方法来清除浮动,为什么不选择第四种方法呢?因为第四种是第三种的改良版虽然比较简便,但是不严谨!
```

#### 定位

```
网页中三种主要布局方式:  标准流    浮动    定位
盒子模型：解决元素之间的位置关系。
浮动：解决元素在一行上显示的问题。
定位：解决元素叠加问题。
```

```
position：static;  静态定位--清除定位，静态定位就是标准流
        relative; 相对定位--参照自己进行移动,占位置
        absolute; 绝对定位--父级无定位则以浏览器文档为准,不占位置
        fixed; 固定定位--固定定位只实现一个效果，就是永远固定在浏览器上, 不仅脱标，还脱浏览器。
        
浮动、绝对定位，固定定位都会自动转换模式： 行内块

z-index：1;    可以修改定位层级
```

#### 显示隐藏总结

```
overflow:hidden;   溢出隐藏
display:none;   将元素隐藏,不占位
visibility:hidden; 将元素隐藏但是占位置
```

#### 其他

```
cursor：pointer;   鼠标小手
outline: 0；  	消除表单获得焦点时的轮廓线
resize：none;	防止拖拽文本域
vertical：middle;   行内元素或行内快元素垂直对齐
去除图片底侧空白缝隙:
1. vertical:middle 或 top；
2. 给图片转为块级元素: display:block;
```

#### css精灵图技术

```
CSS精灵技术使用核心
 	为了让网页越来越好看，必不可少的使用图片，但是以前网速慢，所以就使用小图片，但是小图片个数多了，影响网页加载速度，所以将很多小图片放在一张大图上的技术就叫精灵图技术。 本质还是一张图。
```

# 2. js基础

```
行内JS 很少用
内嵌JS 学习的时候用(少量代码也可以)
外链JS 做项目的时候用(代码量较多时)
注意: 在JS中双引号和单引号都可以使用,但是平时我们建议使用单引号,因为双引号html中已经用了.
```

#### 变量

```
a.关于var变量和变量的值？
	变量就是在内存条中存储数据的容器，而赋予变量的值则是你需要存储的数据
b.变量的取名规范
	取名只能用字母，数字，$,  _  组合而成，不能用数字开头，而且严格区分大小写
c.变量的写法
	var age = 18;(等号左右有没有空格都行，有空格好看)
	var 表示要声明一个变量了，age 是取的变量名，后面的18是需要存储的数据
d.声明多个变量，中间用逗号隔开
	var age = 18, uName = 'andy', eamil = 'andy@qq.com';
e.交换变量
	取一个临时变量，用来暂时存储数据（第一个变量的值），将第二个变量的值赋予第一个变量，之后将临时变量的值赋予赋予第二个变量
```

#### 数据类型

```
简单数据类型:
	Number      数值类型        123
	String      字符串类型      '张三'   '123'  
	Boolean     布尔类型        true       false
	Null		空类型			null
	Undefined	未定义类型		undefined
复杂数据类型:
	数组		[1,2,3]
	对象		object
	函数		function
```

#### 数据类型的判断和转换

```
isNaN(x)  用来判断一个变量是否为非数值 的类型
typeof 可用来获取检测变量的数据类型
	typeof num 也可以写成 typeof(num)
	
toString()  将其他类型转换成字符串
	如果出现一些特殊的类型就用String()
	
Number()  ----只能转换是数字的字符串"123345",如果不是数值,返回NaN
parseInt() ------只能转换开头是数字的字符串 "123abc"
parseFloat() ----只能转换开头是数字,并且能识别第一个小数点.

Boolean()	转换为布尔类型
	0  ''(空字符串) null undefined NaN 等会转换为false
	非0 和其他都会转换成 true
```

#### 运算符

```
1.算数运算符:
       加   +   减   -  乘   *  除   /  取余 %  

2.一元运算符
	2.1 前置运算  :  ++num  先自加  再返回
	2.2 后置运算  : num++  先返回  在自加

3. 关系运算符
	3.1 比较运算符两侧的值,将结果以布尔类型返回  true /  false
	3.2 运算符: > 大于  < 小于  >= 大于等于  <= 小于等于 == 等于
!= 不等于  === 全等于  !== 不全等于
注意:  =  是赋值的意思;   ==  是判断两侧的值一样;   ===  是两侧的值和类型都一样

4. 逻辑运算符
    &&  与运算符    并且     一假为假
    ||  或运算符    或者     一真为真
    !   非运算符    取反
    注意: 逻辑运算是进行布尔值的运算,最后返回的结果也是布尔值
    
   与运算符另外的用法: a && b  表示如果a为true则执行b
   非运算符另外的用法: a || b  表示如果a为false则执行b

5. 赋值运算符
	=  是直接赋值  += 加等于  -= 减等于  *= 乘等于  /= 除等于  %= 余等于   

6.运算符优先级
	() ;  ++  --  ! ; 先 * /  后 + - ; > < >= <= == != === !== ; 先 &&  后 ||  ; 赋值运算符=
```

#### 流程控制

```
流程控制分为:
    顺序结构  (从上往下执行代码)
    分支结构  ( if语句  switch语句)
        三元表达式(if else 的简写)
        表达式1 ? 表达式2 : 表达式3
        如果表达式1为true ，则整个表达式的结果就是表达式2的值，
        如果表达式false，则整个表达式的结果就是表达式3的值.
    循环结构  ( for循环,while循环,do-while循环)
    
for循环  while循环  do-while循环  区别:
    1.当循环次数可知时,用for循环;当循环次数不可知时,用while或者do-while循环
    2.如果是用来计数次数，跟数字相关的，三者使用基本相同
    3.实际中更多使用for循环
        
        
其它:
    1. continue:跳过本次循环,立即结束循环体,跳到自增表达式,开始下一次循环
    2. break:跳出整个循环,立即结束整个循环,开始执行循环下面的语句
```

##### 练习:打印九九乘法表

```js
<script>
    var str = '';
    for (var i = 1; i <= 9; i++) {
    	for (var j = 1; j <= i; j++) {
    		str += j +'*'+ i +'='+ i * j + '\t';
    	}
    	str += '\n';
    }
    console.log (str);
</script>
```

#### 数组

数组就表示一组数据,可以同时存储多个数值;

```js
1. 创建数组:
    //1.new对象创建数组 
    var arr = new Array(); 
    // 数组长度为3 但是内容为空
    var arr = new Array(3); 
    // 创建数组  [3,4,6]
    var arr = new Array(3, 4, 6); 

    // 2. 使用字面量创建数组对象
    var arr = [1, 2, 3];
    // 获取数组中元素的个数
    console.log(arr.length);
    
2.数组的增删改查:
	2.1 获取数组中的值:下标或者索引  arr[0]  表示数组中的第一个值
    2.2 新增 : arr[arr.length] = '李四';
    2.3 修改数组中的值: arr[1] = '张三'; 
    获取数组的长度: arr.length
    如果要动态创建一个数组元素: arr[arr.length]

3.	- instanceof	arr instanceof Array 返回true / false
	- Array.isArray()     Array.isArray(arr) 有兼容性问题
```

##### 练习:冒泡排序(从小往大排序)

```js
 //1.比较趟数: arr.length-1
  //2.每一趟次数: arr.length-i-1
  //3.两两交换,大的往后挪动
  var arr = [5, 4, 3, 2, 1];
   for (var i = 0; i < arr.length - 1; i++) {
       for (var j = 0; j < arr.length - i - 1; j++) {
           if (arr[j] > arr[j + 1]) {
               var temp = arr[j];
               arr[j] = arr[j + 1];
               arr[j + 1] = temp;
           }
       }
   }
   console.log(arr);	//[1,2,3,4,5]
```

#### 函数

##### 函数的创建方法

```
函数是什么?  一段代码的封装,可以重复使用
函数的语法:     函数定义+函数调用
    函数的定义:
    function 函数名 (形参1,形参2) {
   		 //执行语句
    }
函数的几种写法:
1.基本语法: function sayHi(){};  函数的调用: sayHi();
2.匿名函数 : function(){}
3.函数表达式 : var fn = function(){};  函数的调用(由于预解析的原因函数调用必须放到函数定义的后面): fn();
4.自调用函数: (function(){})()

形参:是函数定义中的参数,本质上是一个没有var声明的变量
实参:是函数调用时用的参数,本质上是一个具体的值,调用后,将内容赋值给形参变量
return返回值: 表示从函数内部返回一个结果给调用者,return表示函数的结束

1.函数当参数使用,实际上是自调用函数的写法---外部函数,给到函数内部再执行
2.函数当返回值,实际上是函数表达式的写法. ---函数内部的功能,给到函数外部再执行
```

##### 练习:斐波那契数列

```js
 // 根据数列的规律1，1，2，3，5，8，13，21   求第9个数字是多少(可选)
 var num1 = 1;
 var num2 = 1;
 var num3 = 0;
 for (var i = 3; i <= 9; i++) {
     num3 = num1 + num2;
     num1 = num2;
     num2 = num3;
 }
 console.log(num3);

//函数版
function getFib(num) {
    var n1 = 1;
    var n2 = 1;
    var n3;
    for (var i = 3; i <= num; i++) {
        n3 = n1 + n2;
        n1 = n2;
        n2 = n3;
    }
    return n3;
}

//递归
function getFib(num){
    if(num == 1 || num == 2){
        return 1
    }
    return getFib(num-1)+getFib(num-2)
}
```

#### 全局变量和局部变量

```
全局变量: 大家都可以访问的
局部变量: 只有大括号内部可以访问
全局变量有两种: 
        1.在外面直接定义的变量(没有大括号包裹), var num=1;
        2.在函数内部,没有声明,直接赋值的变量,也是全局变量
局部变量的两种方式:
       1.先把变量的声明提前
       2.再把函数的声明提前,并且提升到变量的前面
       3.函数内部没有var的变量,默认为全局变量
全局变量的销毁: 在浏览器关闭的时候
局部变量的销毁: 在当前函数执行完毕后
```

#### 预解析

```
预解析: 提前解析执行, 在当前作用域中，JavaScript代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明或者定义
预解析过程:
        1.将变量的声明和函数的声明提前
        2.执行赋值或者调用的代码
注意: 变量的声明和函数的声明提前到当前作用域的最前面
              函数的内部变量,直接赋值,本质是全局变量
              
var声明的变量和function声明的函数在预解析的时候有区别，var声明的变量在预解析的时候只是提前的声明，function声明的函数在预解析的时候会提前声明并且会同时定义。
程序最开始的时候，只对window下的变量和函数进行预解析，只有函数执行的时候才会对函数中的变量很函数进行预解析
```

#### 作用域链

```
先理解以下三个概念:
1.函数里面的作用域成为私有作用域，window所在的作用域称为全局作用域；
2.在全局作用域下声明的变量是全局变量；
3.在“私有作用域中声明的变量”和“函数的形参”都是私有变量；

在私有作用域中，代码执行的时候，遇到了一个变量，首先需要确定它是否为私有变量，如果是私有变量，那么和外面的任何东西都没有关系，如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有则继续查找，一直查找到window为止，这就是作用域链。
如果window也没有呢？ 报错 Uncaught ReferenceError: total is not defined	, 上面的代码报错，下面的代码都不再执行了

当函数执行的时候，首先会形成一个新的私有作用域，然后按照如下的步骤执行：

如果有形参，先给形参赋值；
进行私有作用域中的预解析；
私有作用域中的代码从上到下执行
函数形成一个新的私有的作用域，保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的），这也就是闭包的概念。
```



#### 对象

对象就是用代码来描述现实世界中的东西

##### 对象创建的几种方法

```js
 1.字面量对象写法
     var ldh = {
         name : '刘德华',
         age : 18,
         sex : '男',
         sing : function() {
             console.log('唱歌');
         }
     }
    console.log(ldh.name);
    ldh.sing();

2. new Obiect()对象创建写法
    var ldh = new Object();
    ldh.name = '刘德华';
    ldh.age = 18;
    ldh.sex = '男';
    ldh.sing = function() {
        console.log('唱歌');
    }

    console.log(ldh.name);
    ldh.sing();

3.构造函数创建对象写法(对象定义一次,可以多次调用.)
    function Stars(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.sing = function() {
            console.log('唱歌');
        }
    }
    var ldh = new Stars('刘德华',18,'男');
    console.log(ldh.name);
    ldh.sing();

注意: 构造函数就是用来创建对象的函数
    1.构造函数名字必须首字母大写
    2.通过this关键字给属性赋值
    3.创建对象,使用new 构造函数名实现

```

##### new的作用

```js
1.创建一个新的空对象  类似于 new Object();
2.会让this指向这个新的对象(因为这个对象暂时还没有名字,可以用this表示这个对象)
3.给新对象加属性和方法 this.name  this.eat=function(){}
4.返回创建好好的对象.
```

##### this关键字的作用

```js
函数中 -- this 指向Window
在方法中 -- this 指向的是这个方法所属的对象
构造函数中 -- this 就是构造函数创建的对象(没有new过对象的函数,就是构造函数)
总结其实this就是指向函数的调用者
```

##### 遍历对象

```js
for...in 语句用于对数组或者对象的属性进行循环操作。
for (var key in obj) {
    console.log(key); // 这里的k 是属性名
    console.log(obj[key]); // 这里的 obj[k] 是属性值
}
```

##### 遍历JSON

```js
JSON是一种轻量级的数据交换格式,在行业中大量使用.
格式:  属性:值
注意: JSON的属性和值都需要用双引号包裹.

 var json = {
     "id": "1",
     "name": "andy",
      "age": "18",
      "tel": "110120"
 }
 for (var k in json) {
    console.log(k); // 这里的k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}
```

##### 内置对象1:Math对象

```js
Math.PI						// 圆周率
Math.floor() 	              // 向下取整
Math.ceil()                   // 向上取整
Math.round()				// 四舍五入版 就近取整   注意 -3.5   结果是  -3 
Math.abs()					// 绝对值
Math.max()/Math.min()		 // 求最大和最小值
Math.sin()/Math.cos()		 // 正弦/余弦
Math.power()/Math.sqrt()	 // 求指数次幂/求平方根
```

```js
//生成0-1之间的随机数
Math.random()  生成0-1之间的随机数 取值范围是[0，1)
//生成1-100之间的随机数,100要可取
Math.random()*100 +1   生成1-101之间的随机数
Math.floor(上面的结果);  向下取证,就可以得到1-100之间的随机数
                                 
//万能公式
Math.floor(Math.random() * (max - min + 1) + min);     
```

练习:随机生成颜色RGB

```js
function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

function getRGB(min, max) {
    var c1 = getRandom(min, max);
    var c2 = getRandom(min, max);
    var c3 = getRandom(min, max);
    return 'rgb(' + c1 + ', ' + c2 + ', ' + c3 + ')';
}
console.log(getRGB(0, 255));
```

##### Date内置对象

```js
//内置Date时间对象
var now = new Date();
//如果Date()中不写参数,就返回当前时间,如果写参数返回括号中的时间
//new Date('2015-5-1')  或者  new Date('2015/5/1')

```

```js
getFullYear()  	获取当年
getMonth()		获取当月（0-11）
getDate()		获取当天日期
getDay()		获取星期几 （周日0 到周六6）
getHours()		获取当前小时
getMinutes()	获取当前分钟
getSeconds()	获取当前秒钟
```

#### 数组内置方法

##### 检测类型

```js
	- instanceof	arr instanceof Array 返回true / false
	- Array.isArray()     Array.isArray(arr) 有兼容性问题
```

##### 数组转字符串

```js
arr.toString()	 把数组转换成字符串，逗号分隔每一项
```

##### 数组的各种方法

```js
1.push()  //向数组最后添加一个或多个元素,返回新长度
2.pop()   //删除数组最后一个元素,数组长度减1,返回删除元素值
3.shift() //把数组中的第一个元素删除,数组长度减1,返回删除元素值
4.unshift()  //向数组的开头添加一个或多个元素,返回新长度
5.reverse() 颠倒数组中元素的顺序,无参数
6.sort()	对数组的元素进行排序
	arr.sort(function(a, b) {
        return b - a; // 降序
        // return a - b;   升序
	});
7.concat()	连接两个或多个数组 返回一个新的数组
8.slice() 数组截取slice(begin, end) 返回被截取项目的新数组
9.splice() 数组删除splice(第几个开始,要删除个数)  返回被删除项目的新数组  注意，这个会影响原数组
10.indexOf()  从左往右找某个元素的索引 ,找到返回索引,找不到返回-1
11.lastIndexOf()  从右往左找某个元素的索引, 找到返回索引,找不到返回-1
12.join('分隔符')  用于把数组中的所有元素转换为一个字符串。 返回一个字符串
```

##### 清空数组

```js
// 方式1 推荐 
arr = [];

// 方式2 
arr.length = 0;

// 方式3
arr.splice(0, arr.length);
```

##### 数组去重

```js
//思路:
	1.遍历数组
    2.构造字符对象
        {
            a:1,
            b:2,
            c:3
        }
	3.取出对象中值为1的字符,放到新数组中,并返回
var arr = ['c', 'a', 'z', 'a', 'x', 'a'];
var arr = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'];
var o = {};
for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    if (o[item]) {
        o[item]++;
    } else {
        o[item] = 1;
    }
}
console.log(o);
// 声明一个新数组
var newArr = [];
for (k in o) {
    // 如果值是1的话， 说明只有一次，我们可以直接存储到新数组里面
    // 或者 这个数组里面没有重复的
    if (o[k] === 1 || newArr.indexOf(k) === -1) {
        newArr.push(k);
    }
}
console.log(newArr);
```

#### 字符串的常用方法

字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串

```js
// 1 字符方法
charAt(index)    //获取指定位置处字符
charCodeAt(index)   //获取指定位置处字符的ASCII码
str[index]       //HTML5，IE8+支持 和charAt()等效

//字符串操作方法
str1.concat(str2, '肖申克救赎')  //拼接字符串
str.slice(1)    //从start位置开始，截取到end位置，end取不到
str.substring(0,2)//从start位置开始，截取到end位置，  end取不到
str.substr(2,2)        //从start位置开始，截取length个字符
 
//位置方法
str.indexOf('o', index + 1);   //返回指定内容在元字符串中的位置
lastIndexOf()   //从后往前找，只找第一个匹配的
trim()          //只能去除字符串前后的空白

//大小写转换方法
str.toLocaleUpperCase()   //转换大写
str.toLocaleLowerCase()   //转换小写

//其他
str.replace(被替换的字符串， 要替换为的字符串)； //替换,只能替换第一个符合的
str.split(',') //切割	返回的是一个新数组,切割符为字符串中有的某个字符,否则该字符串就是数组中的唯一一个元素
//遇到不清楚的方法,学会去查文档学习.
```

##### 练习:网址URL解析

```js
var url = 'http://www.itheima.com/login?name=zs&age=18';

function getParams(url) {
    // 1. 首先把 网址分为2部分  用 ? 分割 
    // 2. 得到 ？+ 1 的索引位置
    var index = url.indexOf('?') + 1;
    // 3. 得到 ？ 后面的字符串
    var params = url.substr(index);
    console.log(params); // name=zs&age=18
    // 4. 把 得到 这串字符 继续用 & 分隔开,得到一个数组
    var arr = params.split('&');
    // console.log(arr);
    var o = {};
    // 5. 把 数组里面的每一项，继续用 = 分割
    for (var i = 0; i < arr.length; i++) {
        var newArr = arr[i].split('=');
        // console.log(newArr);
        // 完成赋值 操作
        o[newArr[0]] = newArr[1];
    }
    return o;
}
```

# 3. webAPI

## DOM 文档对象类型

### 1.找标签

```
通过id找标签
    document.getElementById()			返回一个标签
通过类名找标签
    document.getElementsByClassName()	返回数组    
通过标签名找标签
    document.getElementsByTagName()		返回数组
通过name属性找标签
    document.getElementsByName()		返回数组   
查询选择器:通过选择器符号来找标签  .one  #two
    document.querySelector()			返回找到的第一个标签
    document.querySelectorAll()			返回数组
    
```

### 2.注册事件

```
onclick 	//单击事件       
ondblclick 	//双击
onmouseover //鼠标移入
onmouseout  //鼠标移出
onfocus     //获得焦点(点击输入框)
onblur      //失去焦点
onmousedown	//鼠标按下
onmouseup	//鼠标松开
onkeydown	//键盘按键按下
onkeyup		//键盘按键松开
```

### 3.属性操作

```
获取属性值：
    标签.属性名
    link.href
    img.src

设置属性值
    标签.属性名=值;
    img.src="a.jpg";

表单属性操作:
value 	//用于大部分表单元素的内容获取(option除外)
type 		//可以获取input标签的类型(输入框或复选框等)
disabled 	//禁用属性		禁用true 默认不禁用false
checked 	//复选框选中属性	checked selected 选中true  不选中false
selected 	//下拉菜单选中属性   
```

### 4.类操作

```
//修改标签的className属性相当于直接修改标签的类名
标签.className='box';

var box = document.getElementById('box');
box.className = 'show';

box.classList  //可以获得标签上的所有类
box.classList.add('a') 	//添加一个类
box.classList.remove('a') 	//移除一个类
```

### 5.内容操作

```
innerHTML  认识标签
innerText  不认识标签
```

### 6.样式操作

```
使用style方式设置的样式显示在标签行内
标签.style.属性名=属性值;
var box = document.getElementById('box');
box.style.width = '100px';
复合属性，短横杠去掉，后面单词首字母大写，驼峰命名法
box.style.backgroundColor = 'red';
```

### 7.自定义属性操作

```
getAttribute() 获取标签行内属性
setAttribute() 设置标签行内属性
removeAttribute() 移除标签行内属性
与element.属性的区别: 上述三个方法用于获取任意的行内属性。
```

### 8.节点操作

```
节点: 有很多东西,包括元素,属性,文本,注释
一个节点有三个属性： nodeType  nodeName  nodeValue
    1.nodeType  //节点的类型
       元素节点
       属性节点
       文本节点 
    2.nodeName  //节点的名称(标签名称)
    3.nodeValue  //节点值
       元素节点的nodeValue始终是null
       
节点的属性和方法:
    parentNode          //父节点
    childNodes          //所有子节点(2*i+1)
    firstChild          //第一个子节点
    lastChild           //最后一个子节点
    nextSibling         //下一个兄弟节点
    previousSibling     //上一个兄弟节点
    hasChildNodes()     //是否有子节点
```

### 9.元素属性和方法

```
元素: 就是一个标签
children            //所有子元素
firstElementChild   //第一个子元素  有浏览器兼容问题
lastElementChild    //最后一个子元素    有浏览器兼容问题
nextElementSibling  //下一个兄弟元素
previousElementSibling  //上一个兄弟元素

createElement()         //创建元素,需要在document中创建
insertBefore(新元素,哪个元素之前) //插入到某个元素之前
removeChild()           //移除元素
replaceChild(新元素,旧元素) //替换元素
appendChild(新元素)     //添加新元素
```

注意:如果appendChild插入的新元素在文档中存在,则会将之前的移除,如果不想移除,先克隆一份添加. cloneNode()

### 10.动态创建元素

```
 document.write()		//可以向页面中写入内容(认识标签),但是在事件点击写入后，会导致原内容清除。
 element.innerHTML		//可以向元素中添加内容，也可以通过事件添加，但是大量内容时性能不好

 document.createElement()	// 通过对象的方式创建标签，并添加属性 
	// 在内存中创建一个DOM对象
	var p = document.createElement('p');
	// 把p元素，放到DOM树上
    var box = document.getElementById('box');
    box.appendChild(p);
```

注意: 多个innerHTML内容需要使用字符串拼接方式,当发生大量字符串拼接操作时会影响性能，可以选择数组来替换实现。

### 11.添加和移除事件监听

```
添加事件的三种方法:
1. 标签.onclick=function(){}

2. attachEvent  //添加事件
   detachEvent  //移除事件

3.添加事件监听方式可以给一个标签同时添加多个事件
    btn.addEventListener(事件类型,执行函数,是否冒泡);
    box.addEventListener('click', function(){

    });

    移除事件: btn.addEventListener(事件类型,命名函数)
    //需要指定执行函数的名字,所以添加事件监听时就不能用匿名函数
    btn.addEventListener(事件类型,fn);
    function fn () {

    }
    btn.removeEventListener(事件类型,fn);
        
```

### 12.事件的三个阶段

```
1.捕获阶段
2.当前目标阶段
3.冒泡阶段
事件对象.eventPhase属性可以查看事件触发时所处的阶段
addEventListener 的第三个参数为false时:事件冒泡(从内到外)
addEventListener 的第三个参数为true时:事件冒泡(从外到内)
```

注意: onclick只有事件冒泡，没有事件捕获.  任何元素都有事件冒泡. 

### 13.事件对象与事件对象属性

```
e.eventPhase       //获取当前事件阶段
e.target           //获取触发源
e.currentTarget    //获取事件处理函数所属的对象 跟this一样
e.type             //获取事件名称
e.clientX          //获取鼠标在浏览器的可视区域的横坐标
e.clientY          //获取鼠标在浏览器的可视区域的纵坐标
e.pageX            //获取鼠标在当前页面的横坐标
e.pageY            //获取鼠标在当前页面的纵坐标

document.body.scrollLeft  //页面滚动出去的横向距离
document.body.scrollTop   //页面滚动出去的纵向距离
document.documentElement.scrollLeft  //获取页面横向滚动距离，有些浏览器这么获取
document.documentElement.scrollTop	//获取页面纵向滚动距离
```

### 14.鼠标事件和监听键盘

```
onmousedown         //鼠标按键按下时触发
onmouseup           //鼠标按键放开时触发
onmousemove         //鼠标移动触发
onkeydown           //键盘按键按下触发,我们所按的键还没有落入文本,可以阻止
onkeyup             //键盘按键放开触发,按的键已经落入文本
e.keyCode 		   //获取键盘码
```

### 其他

```
1.取消链接的默认行为
     // 取消默认行为执行
        return false;   
	   javascript:void(0)
    // DOM标准方法
       e.preventDefault();
  
2.阻止冒泡
	  e.stopPropagation();

3. this表示当前事件源,这个，它

4. 通过模拟DOM结构，了解JS中各种属性和方法的由来都是别人用对象写的。

5. 三元表达式的另类用法： 
     this.className = options.className || '';
     如果第一个值是存在，那么返回第一个值，如果不存在，返回第二个值.
     
6.兼容性问题
    能引入老师的common.js文件,看懂并会使用
    但我们自己写代码的时候不用管兼容性问题
```

## BOM 浏览器对象类型

### 1.BOM对象

```
window.onload  页面加载
window.unonload 页面卸载

//弹框
alert()  弹框
prompt() 带输入弹框
comfirm()  带确认取消的弹框

//单次定时器
var timer = setTimeout(fn,时间);		//设置单次定时器,其返回值是定时器标识
clearTimeout(timer);				//消除单次定时器 : clearTimeout(定时器标识);

//多次定时器
var timer = setInterval(fn,时间);		//设置多次定时器,其返回值是定时器标识
clearInterval(timer);				//消除多次定时器 : clearInterVal(定时器标识);

//location对象
location.href 获取当前网址，或者跳转

//history对象
history.back()
history.forward()
history.go(1)  1前进， -1后退

//navigator对象
navigator.userAgent 获取浏览器信息
navigator.platform  获取当前系统平台
```

### 2.页面偏移量

#### 1.offset偏移量

```
offsetParent	//用于获取最近的定位父级元素，没有定位就是body
offsetLeft		//border外面到父盒子的左边距离
offsetTop		//border外面到父盒子的上面距离
offsetWidth		//内容宽度 border+padding+width
offsetHeight	//内容高度 border+padding+height
```

#### 2.client客户区大小

```
clientLeft   //左边框距离
clientTop    //上边框距离
clientWidth  // width+padding  
clientHeight //height+padding
```

#### 3.scroll滚动偏移

```
scrollLeft    //左边滚动距离（隐藏的内容+边框）
scrollTop     //上面滚动距离(隐藏的内容+边框)
scrollWidth   //内容宽度+隐藏的内容（不包含滚动条）
scrollHeight  //内容高度+隐藏的内容(不包括滚动条)
```

### 综合案例练习

```
1.美女画廊练习
2.检测用户名和密码
3.设置下拉框中的选中项
4.全选反选
5.隔行变色和高亮显示
6.轮播图圆点案例
7.tab菜单切换
8.动态创建列表
9.动态创建表格
10.选择水果
11.事件委托
12.跟着鼠标飞的图片
13.键盘事件,在文本框中只能输入数字
14.删除提示
15.倒计时
16.简单动画
17.拖拽
18.放大镜
19.模拟滚动条

```

# 4. JQuery

### 1.JS和JQuery对比

```

window.onload=function () {
	document.getElementById("btn").onclick=function () {
	//获取div根据id的方式来获取
    var divObj=document.getElementById("dv");
    divObj.style.width="200px";
    divObj.style.height="100px";
    divObj.style.backgroundColor="red";
    } ;
};
```

```
 //页面加载后的一个事件
$(function () {
    $("#btn").click(function () {
        $("#dv").css({"width":"200px","height":"100px",
                      "backgroundColor":"green"});
    });
});
```

```
$('#box').css('属性名','属性值');
$('#box').css({属性名1:属性值1，属性名2：属性值2});
```

### 2.JQuery中的顶级对象$

```
jQuery的顶级对象:jQuery---$
通过$可以点出它的其他方法
```

### 3.页面加载事件

```
JS页面加载事件：  window.onload=function(){}  该方法只能写一次			   
JQ页面加载事件： $(window).load(function(){}) 该方法可以写多个
			   $(document).ready();  //页面加载事件,标签加载完毕后，性能更高
			   JQuery(function(){});
终极写法： $(function(){});

```

### 4.DOM对象和JQ对象互转

```
1.将DOM对象使用$() 包裹即可转换为JQuery对象，然后使用Jquery的方法

//btnObj就是DOM对象
//DOM对象转jQuery对象,只需要把DOM对象放在$(dom对象)--->jQuery对象
$(this)  表示当前标签
$(btnObj) 表示将dom的btn转换为jq对象，这样就可以用到jq的方法
```

```
2.JQ对象转换为DOM对象的方法
	$(btnObj).get(0);---->DOM对象
	$(btnObj)[0];----->DOM对象
```

### 5.Jquery中的选择器

```
$('#btn')  id选择器
$('.box')  类选择器  --多个
$('div')   标签名  --多个
$('li.current')  交集选择器
$('.box li')    后代选择器
$('.box > li')  子代选择器
$('.box, .one ,h3')  并集选择器
$("#box+p")    box后面的第一个p标签元素
$("#box~p")    box后面所有直接的兄弟元素p元素
$('.box li:even')  属性选择器  even偶数  odd奇数
$('.box li:eq(4)')  获取索引为4的li
$('.box li:lt(4)')  获取索引小于4的li
$('.box li:gt(4)')  获取索引大于4的li

$('#btn').text('添加文字内容');  //给该标签设置内容 类似于innerText textContent

注意： JQ中的所有事件和属性修改都支持批量多标签操作，内部有for循环来实现。
```

### 6.JQuery常见的内容方法

```
.html()  类似于innerHTML
.text()  类似于innerText
.val()   类似于input的value属性

注意： 括号中写一个参数表示设置值，什么都不写表示获取值。

.css()   类似于给标签添加样式
```

### 7.JQuery中的事件

```
Jquery中的事件都是将之前的JS事件on去掉，然后把匿名函数写在括号里面
$('#btn').click(function(){});
其他事件：
	mouseover
	mouseout
	
```

#### 手风琴案例

```
$(function () {
    $("#box>ul>li").mouseover(function () {
        //当前的li的所有的兄弟元素li的宽度设置一下
        $(this).siblings("li").css("width","100px");
        $(this).css("width","800px");
    });
    $("#box>ul>li").mouseout(function () {
        $("#box>ul>li").css("width","240px");
    });
});
```

```
<div id="box">
    <ul>
        <li><img src="images/1.jpg"/></li>
        <li><img src="images/2.jpg"/></li>
        <li><img src="images/3.jpg"/></li>
        <li><img src="images/4.jpg"/></li>
        <li><img src="images/5.jpg"/></li>
    </ul>
</div>
```

### 8.类操作

```
addClass('current')     //添加类
removeClass('current')  //移除类
toggleClass('current)    //开关类 
hasClass('current')     //是否有某个类，返回true和false

//可以添加多个类
addClass('current').addClass('bd');
addClass('current bd');
//注意添加类名前面没有点。
```

### 9.css和类样式操作总结

```
 css()
     css("属性","属性值");
     css("属性","属性值").css("属性","属性值");
     css({"属性":"属性值","属性":"属性值"});
 addClass()
     addClass("类样式名字");添加一个类样式
     addClass("类样式名字1 类样式名字2");
 removeClass()
     removeClass("类样式名字");移除类样式
     removeClass();移除的是当前元素中所有的类样式
 hasClass();判断当前元素是否应用了某个类样式
 toggleClass();切换元素的类样式的
```

### 10.链式编程

```
如果多行代码操作的是同一个对象的样式属性，那么可以连接起来写，简化代码。
链式编程原理:内部返回了return this当前对象；

注意： 有些方法传入了参数，才能返回对象，如果是直接获取属性的值，返回的是内容，就不是对象了。
```

```
 $("#dv").html("<p>这是一个p</p>");
 $("#dv").css("backgroundColor","red");
//简写方式
 $("#dv").html("<p>这是一个p</p>").css("backgroundColor","red");
```

注意：如果获取一个标签的值，那么就不能用链式编程，因为会返回一个字符串。$('#dv').html().css()就是错误的

### 11.兄弟元素操作

```
next()  下一个兄弟
nextAll() 后面所有兄弟
prev()   上一个兄弟
prevAll() 上面所有兄弟
siblings() 除自己以外的所有兄弟
```

### 12.常见动画方法

```
show()  显示
hide()  隐藏   本质上还是display:block和none
slideUp() 上滑
slideDown() 下滑
slideToggle()  上下滑
fadeIn()  淡入
fadeOut() 淡出
fadeToggle() 淡入淡出
fadeTo(事件，透明度)    透明度动画


参数1： 
	1.可以写毫秒，1000毫秒
	2.可以写字符串 slow normal fast
$("#dv").hide(1000);
$("#dv").show("fast");

参数2： 是一个回调函数，可以在动画执行后触发

$('#dv').hide(1000,function(){
    alert('动画结束了')；
})
```

### 13.animate动画方法

```
animate(属性，时间，回调函数);
属性的变化和时间是必须的，回调函数可以没有。

animate({"属性名"："属性值"},1000)
注意： animate属性不能修改非数值效果，例如颜色。

stop()   动画停止函数（内部原理停止上一个定时器）；
建议: 在每次添加动画之前都加上stop(),直接显示隐藏动画除外
```

### 14.元素创建

```
直接使用$('标签') 就可以创建一个标签对象。
append()  追加元素
prepend() 插入某个元素前面

after()  在后面添加元素
before() 在前面添加元素

appendTo()  把当前标签添加到其他标签中去

```

```
//创建元素
var aObj=$("<a href='http://www.baidu.com'>百度"+i+"</a>");
//把元素添加到div中
$("#dv").append(aObj);//把超链接追加到div中

//把元素插入到某个元素的前面
$("#dv").prepend(aObj);
//把元素添加到当前元素的后面(兄弟元素来添加)
$("#dv").after(aObj);
//把元素添加到当前元素的前面(兄弟元素来添加)
$("#dv").before(aObj);
```

注意：append追加元素，可以把已经存在的元素移除，类似于剪切效果,可以先克隆,$("#dv").append(aObj.clone())

#### 14.1 appendTo添加元素

```
$("#btn").click(function () {
    //创建p标签
    var pObj= $("<p></p>");
    pObj.text("哈哈哈,我又变帅了");
    //$("#dv").append(pObj);
    //把pObj对象主动的加到div中
    pObj.appendTo($("#dv"));
});
```

#### 14.2 html()添加元素

```
$("#btn").click(function () {
    $("#dv").html("<p>这是一个p标签</p>");
});
```

#### 14.3 动态创建表格

```js
   $("#btnCreate").click(function () {
       var arr=[];
       //遍历数组
       for(var i=0;i<datas.length;i++){
           var obj=datas[i];//数组中的每一个对象
           //创建行和列,加入到tbody中
           arr.push("<tr><td><a href="+obj.url+">"+obj.name+"</a></td><td>"+obj.type+"</td></tr>");
       }
       $("#tbd").html(arr);
   });
```

```js
//另外一种方法
for(var i=0;i<datas.length;i++){
    var obj=datas[i];//数组中的每一个对象
    //创建行和列,加入到tbody中
    $("<tr><td><a href="+obj.url+">"+obj.name+"</a></td><td>"+obj.type+"</td></tr>").appendTo($("#tbd"));
}
```

### 15.清空内容和克隆节点

```
html('') //清空内容
empty()  //清空内容
remove()  移除元素

clone()  克隆元素

children() 子元素
```

### 16.表单属性获取和设置

```
val()  可以获取和设置表单的value值
```

注意; 设置下拉框的value值可以让下拉框某一项选中，前提是option上有value值

### 17.自定义属性

```
attr()  设置和获取自定义属性
设置自定义属性
attr('ss','1');
获取自定义属性
attr('ss')
注意： attr不能获得多选框的选中值checked属性,和下拉选择框的selected属性

prop()  //该方法可以获取多选框的checked属性和下拉选择框的selected属性
```

### 18.设置和获取元素宽高

```
width()   //获取和设置宽度
height()  //获取和设置高度
$("#dv").css("width")   //获取宽度，返回字符串 100px，可以使用parsetInt转换为数字

$('#dv').width(100);    //直接设置元素宽度为100，不需要带px

总结： 通过css设置和获取宽高，需要带px单位，使用width()方法可以不用带px单位。

```

### 19.获取元素的位置操作

```
offset() 方法可以获得 left和top值，都是数字，不带单位
offset().left  //left值
offset().top


//获取left和top的值--->都是数字类型
console.log($("#dv").offset().left);
console.log($("#dv").offset().top);

//设置left和top值
$("#dv").offset({"left":200,"top":200});
```

### 20.页面滚动距离

```js
scrollLeft()  滚动出去的左边距离
scrollTop()   滚动出去的顶部距离

$(document).click(function () {
    //获取的滚动出去的距离----->数字类型
    console.log($(this).scrollLeft()+"===="+$(this).scrollTop());
});
```

### 21.绑定事件

```js
bind() 事件绑定 类似于JS中的addEventListener

普通添加事件：
	$('#btn').click();

添加多个监听事件
$('#btn').bind({"click"：回调函数},{"mouseover"：回调函数});

//可以同时添加多个事件，但是事件执行函数是一样的
$('#btn').bind("mouseover mouseout",function(){});
```

```
delegate(标签,事件类型，回调函数)  //给某个元素的子元素添加事件
```

```js
on()  父元素调用为子元素添加事件
on(事件类型，标签，回调函数);

两种用法：
	1.两个参数： 事件名称 回调函数
	2.三个参数: 事件名称 添加事件元素，回调函数
```

```js
总结：
	bind:
         绑定多个事件
         参数:{"事件的类型":事件处理函数,....}
    delegate
         参数:父级元素.delegate("子级元素","事件类型",事件处理函数)
    on
         参数:父级元素.on("事件类型","子级元素",事件处理函数);

建议：在手机上或者动态添加的事件推荐使用on来添加
```

### 22.解绑事件

```
on()  off()
bind()  unbind()
delegate()  undelegate()

//建议： 事件绑定和解绑，不要混着使用，普通的click方法可以使用off解绑
```

注意： 如果是通过父级元素添加事件，那么父级元素解绑事件，子级元素事件也会消失。

```
 //第一个按钮通过on的方式绑定点击事件
$("#btn1").on("click",function () {
    alert("我被点了");
});
//第二个按钮把第一个按钮的点击事件解绑
$("#btn2").on("click",function () {
    //off()参数:要解绑的事件的名字
    $("#btn1").off("click");//解绑事件
});
```

```
 //第一个按钮bind绑定事件
$("#btn1").bind("click",function () {
    alert("我又被点了");
});
//第二个按钮unbind解绑事件
$("#btn2").bind("click",function () {
    $("#btn1").unbind("click");//解绑事件的方法
});
```

```
//点击第一个按钮为div中p绑定点击事件
$("#btn1").click(function () {
    $("#dv").delegate("p","click",function () {
        alert("我被点了");
    });
});
//点击第二个按钮为div中p解除绑定事件
$("#btn2").click(function () {
    $("#dv").undelegate("p","click");//解绑
});
```

### 23.事件触发

```
事件触发： 就是你帮我去点击
$("#btn1").click();    
$("#btn1").trigger("click");//触发事件
$("#btn1").triggerHandler("click");//触发事件


$("#btn1").click(function () {
    $(this).css("backgroundColor","red");
});
//点击第二个按钮调用第一个按钮的点击事件---触发第一个按钮的点击事件
$("#btn2").click(function () {
    //触发事件--3三种方式
    //$("#btn1").click();
    //trigget()方法中需要写上触发事件的名字
    //$("#btn1").trigger("click");//触发事件
    $("#btn1").triggerHandler("click");//触发事件
});

注意： triggerHandler 不会触发浏览器的focus事件。
```

### 24.事件对象

```
e.delegateTarget----->div--->谁在替元素绑定的事件--div
e.currentTarget----->input--->真正是谁绑定的事件
e.target---->input----触发的事件的元素
```

### 25.事件冒泡

```
取消事件冒泡：
e.stopPropagation(); 或者return false;

return false;  还可以用来取消默认事件。
```

### 26.each方法

```js
each() 方法也叫迭代，简单点就是循环。
注意: Jquery中有隐式迭代，不需要我们再进行遍历某些元素操作，但是不一样的操作需要自己实现。

例如： 批量给标签添加事件，但是每个标签的内容不一样，就可以使用each()方法

总结： 你可以认为each就是一个简单的for循环。

```

```js
$("#uu>li").each(function (index,element) {               
	$(element).css("opacity",(index+1)/10);
});
```

### 27.JQuery插件

```
使用步骤： 
	1.引入js
	2.引入css
	3.复制html
	4.看说明文档
	
注意： 有的插件没有css或者html，但是一定有js，说明书完善的我们推荐使用。
注意： 有的插件中没有带上JQuery.js文件，需要自己提前引入，才行.
```

# 5.js高级

## 1.重新介绍 JavaScript

### JavaScript 是什么

- 解析执行：轻量级解释型的 

- 语言特点：动态，头等函数 (First-class Function)

  - 又称函数是 JavaScript 中的一等公民

- 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境

  - 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js

    

### JavaScript 的组成

- ECMAScript  - 语法规范
  - 变量、数据类型、类型转换、操作符
  - 流程控制语句：判断、循环语句
  - 数组、函数、作用域、预解析
  - 对象、属性、方法、简单类型和复杂类型的区别
  - 内置对象：Math、Date、Array，基本包装类型String、Number、Boolean
- Web APIs
  - BOM
    - onload页面加载事件，window顶级对象
    - 定时器
    - location、history
  - DOM
    - 获取页面元素，注册事件
    - 属性操作，样式操作
    - 节点属性，节点层级
    - 动态创建元素
    - 事件：注册事件的方式、事件的三个阶段、事件对象 

### JavaScript 执行过程

JavaScript 运行分为两个阶段：

- 预解析
  - 全局预解析（所有变量和函数声明都会提前；同名的函数和变量,函数的优先级高）
  - 函数内部预解析（所有的变量、函数和形参都会参与预解析）
    - 函数
    - 形参
    - 普通变量
- 执行

先预解析全局作用域，然后执行全局作用域中的代码，
在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。

## 2.面向对象和面向过程 

### 什么是对象

```
对象是一个容器，封装了属性（property）和方法（method）。
ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。

严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。

面向过程:分步骤,自己一步一步做
面向对象:找一个专门做这件事的人或者事物去做,自己指挥就行
```

### 什么是面向对象

```
面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。
面向对象的特性：
- 封装性 
- 继承性
- [多态性]抽象
面向对象的设计思想是：

- 抽象出 Class(构造函数)
- 根据 Class(构造函数) 创建 Instance
- 指挥 Instance 得结果

面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。

```

## 3.创建构造函数

```
创建对象的方式:
    1.字面量创建对象: var obj = {}
    2.new Object()创建对象: var obj1 = new Object();
    3.自定义构造函数创建对象:

new 的执行过程:
    1.先创建一个空对象
    2.让构造函数中的this指向刚刚创建好的对象
    3.执行构造函数中的代码(给创建好的对象,赋值初始属性)
    4.返回创建好的对象
```

```
创建构造函数:
        通过构造函数判断对象的类型:
            x instanceof y :判断x对象是否是被y构造函数所创建出来的(判断x对象是否是y构造函数的一个实例)
            对象.constructor :判断对象的类型
```

```
构造函数的原型属性:
        构造函数名.prototype 里面指向了原型对象
```

```
对象的原型属性:
    构造函数名.prototype.constructor  指向了构造函数
    对象.constructor  也指向了创建了这个对象的构造函数
    对象的原型属性: 对象.__proto__  指向了构造函数的原型对象  不推荐使用,非标准属性

    总结规律:构造函数的prototype属性 和 对象的__proto__属性 指向了同一个原型对象(完全相同,就是访问方式不同)
    当我们给构造函数的原型对象增加成员的时候,其实就是相当于是在给这个构造函数的实例增加成员
```

```
constructor 的作用:
    构造函数的prototype属性中的constructor属性指向的是原型对象所属的构造函数
    对象的constructor属性 指向的是 创建当前对象的构造函数
    constructor 的作用: 用来记录创建对象的构造函数(用来记录对象的类型),
```

```
原型链和属性查找规则:
    当对象中使用了一个属性的时候,会先到当前对象中查找该属性;
    如果这个对象中不存在这个属性,则去这个对象的原型对象中进行查找;
    如果原型对象中没有,就去原型对象的原型对象中去查找;
    如果原型对象的原型对象都没有该属性,就报错.

```

## 4.继承

### 1.对象拷贝

```js
1. 对象拷贝:(不能继承类型,只能继承对象)
    对象与对象之间的继承
    <script>
        function extend(parent,child){
            for(var key in parent) {
                //不给child复制同名的属性
                if(child[key]){
                contine;
            }
            child[key] = parent[key];
        }
    };
    </script>
```

问题:对象与对象之间无法实现类型的继承 

### 2.原型继承

```
2. 原型继承: 是类型和类型之间的关系
            //让子类型的原型对象等于父类型的实例
            Student.prototype = new Person();
            Student.prototype.constructor = Student;
        继承目的:把子类型中共同的成员提取到父类型中来,代码重用
        原型继承:  通过对构造函数的prototype属性 直接赋值 父对象
```

原型继承存在的问题:无法给父对象的构造函数中的属性重新赋值,一般使用较少,主要用于对象方法的继承 

### 3.借用构造函数继承

```js
3. 借用构造函数继承(使用call方法对父类型构造函数进行调用,完美实现子类型对父类型所有属性的继承)
        问题:使用借用构造函数无法继承父类型构造函数原型中的方法.
    //借用构造函数
    //父类型
    function Person (name,age,sex){
        this.name = name;
        this.age = age;
        this.sex = sex;
        //this.sayHi = function(){}
    }
//将构造函数的方法写到其原型对象上
    Person.prototype.sayHi = function(){
        console.log(this.name);
    }

    //子类型
    function Student (name,age,sex,score){
        //这里只继承了父类型的属性,没有继承父类型的原型对象中的方法
        Person.call(this);
        this.score = score;
    }

    var s1 = new Student('zs',18,'男',100);
    console.dir(s1);
    console.log(s1.__proto__);
```

```

call() 与 bind() 的区别:
            call()方法: 直接调用函数,改变函数中的this 指向,指向call方法中的第一个参数,
                call方法从第二个参数开始,可以传递 函数所需要的实参
                call的返回值就是函数的返回值,没有就是undefind
            call()方法的问题:不能继承到父对象的构造函数中prototype中的方法,只能实现属性的继承
            bind()方法: 不调用函数改变函数中的this  ,
            bind方法从第二个参数开始,可以传递 函数所需要的实参
                fn.call(o,x,y);
                fn.bind(o,x,y);
```

### 4.组合继承 

```
通过组合继承,完成对父类型的所有属性和方法的继承
        组合继承 = 借用构造函数(继承父类型属性) + 原型继承(继承父类型方法)
        好处: 在一些大型项目中为开发人员节约开发时间以及减少重复的代码(减少冗余,提高代码复用率)
        问题:通过原型继承来的父类型的方法是所有子类型都可以进行调用的,子类型自身的原型对象进行了修改,会改变父类型的原型方法,解决方法是:对子类型原型赋值父类型的实例
```

```js
// 组合继承：借用构造函数 + 原型继承
        // 父类型
        function Person(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        }

        Person.prototype.sayHi = function () {
        console.log('大家好，我是' + this.name);
        }

        // 子类型
        function Student(name, age, sex, score) {
        // 借用构造函数,让 person中的this 指向 Student的 对象
        Person.call(this, name, age, sex);

        this.score = score;
        }

        // 通过原型，让子类型，继承父类型中的方法
        Student.prototype = new Person();
        Student.prototype.constructor = Student;
        // 学生特有的方法
        Student.prototype.exam = function () {
        console.log('考试');
        }

        var s1 = new Student('zs', 18, '男', 100);
        console.dir(s1);


        var p1 = new Person('ls', 18, '男');
        console.dir(p1);


        function Teacher(name, age, sex, salary) {
            // 借用构造函数
            Person.call(this, name, age, sex);
            this.salary = salary;
        }

        // 通过原型让子类型继承父类型中的方法
        Teacher.prototype = new Person();
        Teacher.prototype.constructor = Teacher;

        // var t1 = new Teacher('ww', 30, '男', 100000);
        // console.dir(t1);

        // t1.sayHi();
```

## 5.函数

### 1.函数的创建方法及异同点

```
a. 函数声明(命名函数):
    function fn (){
        console.log('test');
        }
    fn();
b. 函数表达式:(函数调用必须放到函数定义的后面)
	var fn1 = function () {
		console.log('test');
	}
	fn1();
c. 自调用函数
d. new Function()创建函数  基本不用,效率不高
	var fn = new Function('var name = "张三";console.log(name)');
    fn();
```

```
命名函数和函数表达式的区别:
        1.调用的方面:
            命名函数:在执行的时候  由于预解析的原因,所以书写顺序没有要求,函数调用可以写在任何位置
            函数表达式:在调用的时候必须遵循先声明后使用
        2.在if语句方面的问题:
            命名函数 在新版本浏览器的if语句中不会被预解析,但在旧版本的IE的if语句中存在被预解析的风险;
            函数表达式 在新版本和旧版本的IE浏览器的if语句中都不会被预解析(解析的是其实存放函数的变量)
```

### 2.函数的调用 

```
1. 普通函数调用 --> window.函数名()
2. 方法调用 --> 对象名.方法名()
3. 作为构造函数调用  -->  new 构造函数名()
4. 作为事件的处理函数  -->  DOM对象.事件名 = function(){}    DOM对象名.事件名()
5. 作为定时器的参数 -->  setInterval (function(){} , 1000);
6. call方法调用
7. apply方法调用
```

```
总结:
1. 方法调用模式:调用对象中的方法,this指向该方法所属的对象
2. 函数调用模式:普通函数和命名函数的调用,this指向window
3. 构造器调用模式:调用构造函数的原型属性中的方法,this指向构造函数创建的实例
4.上下文调用:通过apply(),call()方法调用,this指向第一个参数
```



### 3.函数中this的指向问题 

```
1.在普通函数中,this指向window
2.在对象的方法中,this指向当前方法所属的对象
3.在构造函数中,this指向当前构造函数创建的对象
4.在事件处理函数中,this指向当前事件处理函数所属的对象
5.在定时器函数中,this指向window

终极总结:函数内部的this,是由函数调用的时候来确定其指向的,谁调用,this指向谁
```

## 6.改变函数中的this的三种方法

1.apply() 方法 

```
apply() 的使用:把指定的数组拆分成函数需要的单个参数,节省了遍历数组的过程, 会调用函数; 
apply只有两个参数:
        1.调用函数,改变函数中的this指向
        2.第一个参数:设置函数内部的this指向
          第二个参数是数组,函数有几个参数,数组中就有几个元素
        3.函数的返回值  apply的返回值就是函数的返回值
apply方法的应用:当某些方法不支持参数为数组时,可以用apply方法把数组用作第二个参数传递进去
console.log(Math.max.apply(null,arr));
```

### 2.call()的应用 

```
call():主要用于调用函数并且改变函数中this的指向
call()方法用途: 1. 可以用来实现借用构造函数继承属性
               2. 还可以用于借用内置对象的方法
Array.prototype.push.call(obj,40);  //改变push方法的指向,指向obj,使obj能用这个方法
```

### 3.bind() 的应用 

```
bind() 的应用:用来设置定时器中函数的this指向
bind方法:返回一个新的函数,并且改变函数中this的指向,不会调用函数
var obj ={
            name : 'zs',
            fun : function(){
                setInterval(function(){
                    console.log(this.name);
                }.bind(this),1000);
            }
        }
        obj.fun();
        原来定时器中的this指向window,没有bind()时,输出空
```

## 7.高阶函数

### 1.作为参数传递的函数 

```
function eat (fn){
                setTimeout(function(){
                    console.log('吃晚饭');
                    //吃完晚饭之后做的事情
                    fn();
                },2000)
            }
            eat(function(){
                console.log('去唱歌');
            });
        优点:
        使用案例: sort()排序
            var arr = [35,1,20,6];
            arr.sort(function(a,b){
                return a-b;         //升序排列
            });
        
```

### 2.作为返回值返回的函数(闭包的典型) 

```
//求两个数的和:m+n 
        function getFun (m){
            return function(n){
                return m+n;
            }
        }
        var getSum100 = getFun(100);
        console.log(getSum100(1));      //打印出101
```

## 8.闭包Closure 

```
1.什么是闭包?
      在嵌套的两个作用域中,内部作用域中访问外部作用域局部变量(或方法或属性)的过程,此时发生了闭包,闭包的函数是外层函数
2.闭包的作用:利用函数的作用域保存一些我们需要的变量
      1.解决定时器中无法保存变量的问题
      2.节约代码量
      3.闭包特点:
        延展了函数的作用域 --> 闭包函数不会被轻易释放
4.闭包的缺点:
      占用内存
      
function fn (){
            var n = 10;
            return function(){
                return n;
            }
        }
        var f = fn();
        console.log(f());
        这里返回的函数 f 是闭包
```

### 定时器是如何工作的 

```
浏览器在执行代码的过程中,将我们写的代码分了两部分保存
        script 标签中的代码被放到执行栈中执行,定时器的函数和事件处理函数的代码会被放到任务队列中执行;
        先执行执行栈上的代码,再执行任务队列上的代码
        即定时器中函数的代码会相对于正常代码延后执行
```

```js
console.log('start');
            for (var i = 0; i < 3; i++){
                setTimeout(function(){
                    console.log(i);
                },10)
            }
            console.log('end');
            输出 start end 3 3 3
```

```
用闭包解决这个问题:
            console.log('start');
            for (var i = 0; i < 3; i++){
                (function(i){
                    setTimeout(function(){
                        console.log(i);
                    },10)
                })(i)
            }
            console.log('end');
            //输出 start end 0 1 2
```

###   闭包面试题: 

```
1题.
        function Foo (){
            var i = 0;
            return function(){
                console.log(i++);
            }
        }
        var fn = Foo();
        var fn1 = fn();
        fn();   // 0    执行console.log(i++), i++是先执行,后自增
        fn();   // 1    先前自增过一次,为1
        fn1();  // 0    重新执行整个函数,i重新被赋值,为0
```

```
2题.
        for (var i = 1; i <= 5; i++){
            setInterval(function (){
                console.log(i);
            },1000);
        }
        上面的代码会输出什么?如何输出1 2 3 4 5 
        上面的代码输出: 6 6 6 6 6 ...
        改进:
        for (var i = 1; i <= 5; i++){
            (function(i){
                setInterval(function (){
                    console.log(i);
                },1000);
            })(i)
        }
        输出1 2 3 4 5
```

```
3.题
         var name = "The Window";
         var object = {
             name: 'My Object',
             getName: function(){
                 return function (){
                     return this.name
                 }
             }
         };
         console.log(object.getName()());
         输出: The Window

         分析: var fn = object.getName(); --> getName()函数里面this指向window
         fn(); --> 此时是window调用fn ,this指向window,所以输出window.name
```

```
4题
var name = "The Window";
        var object = {
             name: 'My Object',
             getName: function(){
                 var that = this;
                 return function (){
                     console.log(this);  // window
                     console.log(that); // object
                     return that.name
                 }
             }
         };
         console.log(object.getName()());
         输出: My Object

```

```
5题
var name = "The Window";
         var object ={
              name: 'My Object',
              getName: function(){
                  return function (){
                      return this.name
                  }.bind(this);     //这里把返回的函数中的this指向由原来的window改变成了object 
              }
          };
         console.log(object.getName()());
          输出: My Object
```

```
6题
var name = "The Window";
        var object = {
            name: 'My Object',
            getName: function(){
                return function (){
                    return this.name
                }.call(this);     //这里把返回的函数中的this指向由原来的window改变成了object 并且直接执行了
            }
        };
        console.log(object.getName()());
        这里会报错,因为返回了字符串,不能再调用
        分析:
            function (){return this.name}.call(this);  已经自动执行了,返回了字符串
            object.getName() 的返回值是字符串,
            object.getName()() 是字符串调用方法,就报错了
```

## 9.递归

```
递归: 函数自己调用自己
function fn ({
            var n = 10;
            console.log(n);
            fn;
        })
在递归的过程中会报错 Maximum call stack size exceeded
内存溢出,超过了最大的堆栈大小
递归一般都要写一个结束的条件
```

```
//案例1: 用递归来实现1+2+3+4+...+n;
        function getSum (n){
            //递归结束的条件
            if (n === 1){
                return 1;
            }
            return n+getSum(n-1);
        }
        console.log(10);    //55
        分析:
        n=3,  3+getSum(3-1); -->3+3 --> 6
        n=2,  2+getSum(2-1); -->2+1  --> 3
        n=1,  1;
```

### 遍历DOM树 

```
//遍历指定元素下所有的元素,并给它注册事件
        function loadTree (parent,callback){
            for (var i = 0; i < parent.children.length; i++) {
                //遍历第一层子元素
                var child = parent.children[i];
                if (callback){
                    //传参给回调函数
                    callback(child);
                }
                //递归调用
                loadTree(child);
            }
        }
        <!-- loadTree(document.body); -->
        loadTree(ul,function(element){
            element.onclick = function(){
                console.log(this.innerText);
            }
        });

```



## 10.浅拷贝和深拷贝

### 浅拷贝

```js
//浅拷贝只能复制对象中简单的数据类型,而复杂数据类型的属性则只拷贝地址(引用)
var obj ={
       name: '张三',
       age : 18,
       gender : '男',
       dog: {
            name: '小白',
       },
       friends: ['lilei','hanmeimei']
}
var obj1 = {};
        for (var k in obj){
            if (obj1[k]){
                continue;
            }
            obj1[k] = obj[k];
}
console.dir(obj1);

//当修改obj中的成员时,obj1.name不会改变,obj1.dog.name改变了
        obj.name = '李四';
        obj.dog.name = '大黄';
        console.dir(obj1);
        
//封装函数
function copy (obj,obj1){
	for (var k in obj){
		if (obj1[k]){
			continue;
		}
		obj1[k] = obj[k];
	}
}
```

### 深拷贝

```js
//在我们对象的属性进行拷贝的时候,将对象中的所有复杂数据类型的属性也进行了拷贝(拷贝的是属性中真实的对象,而不是引用)
var obj ={
            name: '张三',
            age : 18,
            gender : '男',
            dog: {
                name: '小白',
            }
            friends: ['lilei','hanmeimei']
        }
        var obj1 = {};
        function deepCopy (obj,obj1){
            for (var k in obj){
                if(obj[k] instenceof Array) {
                    //如果属性的值 是数组类型Array?
                    obj1[k] = [];
                    deepCopy(obj[k],obj1[k]);   //递归
                } else if (obj[k] instenceof Object){
                    obj1[k] = {};
                    deepCopy(obj[k],obj1[k]);
                }else {
                    obj1[k] = obj[k];
                }
            }
        }
        deepCopy(obj,obj1);   
        obj.name = '李四';
        obj.dog.name = '大黄';
        console.dir(obj);
        console.dir(obj1);



//注意: 所有的对象,数组都是Object的实例,所以要先判断是否是数组类型,再判断是否是对象类型
var arr = [];
console.log(arr instenceof Array);      //true
console.log(arr instenceof Object);     //true
//数组也可以用for-in遍历
var arr = [];
for (var i in arr){
     console.log(arr[i]);
}
```

## 11.正则表达式

### 1.概念

```
正则表达式:用于匹配规律规则的表达式
    1.概念:一组用于查找特定字符串的规则(所有语言通用)
    主要用于 对指定字符串进行查找的规则
    优点:方便快捷查找
    作用:
        1.给定的字符串是否符合正则表达式的过滤逻辑(匹配)
        2.可以通过正则表达式,从字符串中获取我们想要的特定部分(提取)
        3.强大的字符串替换功能(替换)
```

### 2.组成

```
普通字符:abc , 123
元字符:在正则表达式中表示特殊含义的字符 \d  \w 
```

### 3.元字符 

```
一个元字符一次只匹配一个普通字符
        ^   以...开头
        $   以...结束
        \d  匹配数字
        \D  匹配任意非数字的字符
        \w  匹配数字或字母或下划线
        \W  匹配任意非数字字母下划线
        \s  匹配任意的空白符
        \S  匹配任意的不是空白符的字符
        .   匹配除换行符以外的任意字符
```

### 4.限定符 

```
限定符 指定的元字符要出现的次数
        {n,m}   重复n到m次
        {n,}    重复n次或更多次
        {n}     重复n次
        ?       重复零次或一次
        *       重复零次或更多次
        +       重复一次或更多次

```

### 5.其他符号 

```
[]      表示匹配其中的任一字符,相当于或的意思
\       转义符,用来取消特定功能符号的正则表达式含义
|       或者,选择两者中的一个,注意: | 将左右两边分为两部分,而不管左右两边有多长多乱
()      从两个直接量中选择一个,分组
[^]     匹配除中括号以内的内容
```

### 6.练习

```
1.邮政编码: 100100
^[1-9]\d{5}$ 

2.验证手机号: 13387546695
^[1-9]\d{10}$ 

3.验证日期: 2012-5-01
^\d{4}-\d{1,2}-\d{1,2}$ 

4.验证邮箱 : xxx@itcast.cn 
^\w+@\w+(\.\w+)+$

5.验证IP地址: 192.168.1.10
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
```

## 12.javascript中使用正则表达式  

### 1.跟正则表达式相关的方法

```
1.跟正则表达式相关的方法:
    1. RegExp 对象
        test()  匹配
        exec()  提取
    2. String 对象
        match()     提取  可以提取多个内容
        replace()   替换
        split()     切割
        search()
```

### 2.创建正则表达式的方式

```
1.new RegExp(); (正则表达式,i是否忽视大小写)
        内置对象  RegExp
        第一个参数: 模式pattern   字符串类型
        第二个参数: flag  i忽略大小写, g全局匹配 字符串类型
        var regularExpression = new RegExp('ab[a-z]','i');
        var str = 'abc';
        console.log (regularExpression.test(str));  //默认区分大小写,写上第二个参数,不区分大小写

2. 字面量: var reg = /正则表达式/i是否忽视大小写
        var regulaiExpression = /ab[a-z]/i;
        var str = 'abc';
        console.log (regularExpression.test(str)); 
```

###  3.正则表达式的exec()提取方法 

```
正则表达式对象.exec(要提取的字符);
    用于提取符合模式的字符串.
    以数组的形式返回找到的结果,否则返回null;
    exec()只返回一个匹配到结果,如果要提取多个符合模式的字符串,则需要使用全局模式,还要循环
        案例:提取工资
        var str = '张三:2500,李四:3600,王五:4800';
        var reg = /\d+/gi;      //全局匹配并且忽略大小写
        do {
        var content = reg.exec(str);
        if (content){
            console.log(content[0]);
        }
        } while (content)
```

### 4.字符串的match()提取方法 

```
 字符串.match(正则表达式);
    可以提取多个内容
        案例:提取工资
        var str = '张三:2500,李四:3600,王五:4800';
        var reg = /\d+/gi;  
        str.match(reg);
        console.log(str.match(reg));    //[2500,3600,4800]
```

### 5.分组提取(给想要的部分加上小括号) 

```
提取日期中的年份,月份,日期
    var dateStr = '2015-5-12';
    var reg = /(\d{4})-(\d{1,2})-(\d{1,2}/);
    reg.test(dateStr);  //调用任何一个正则表达式中的方法都行
        //或 reg.exec(dateStr);
        //或 dateStr.match(reg);
    console.log(RegExp.$1);     // 2015
    console.log(RegExp.$2);     // 5
    console.log(RegExp.$3);     // 12
```

### 6.字符串对象的split()分割方法 

```
var dateStr = '2015-5-12';
    console.log(dateStr.split('-'));    // [2015,5,12]

    var dateStr = '2015/5-12';
    //以 - 或者 / 来切割,用正则表达式 /[/-]/
    console.log(dateStr.split(/[/-]/));    // [2015,5,12]
```

### 7.字符串对象的replace()替换方法 

```
var str = '123123';
var str1 = str.replace('1','-');
console.log(str1);      // -23123 一次只能换一个字符

var str1 = str.replace(/[1]/g,'-');
console.log(str1);      // -23-23   全局匹配找多个

var str = '  jgse  ajhfe 1233  wref ';
trim()  只能去掉前后的空格
console.log(str.trim());
可以:
console.log(str.replace(/\s/g,''));
或:
console.log(str.split(' ').join(''));
```

### 8.字符串对象的search()搜索方法 

```
字符串.search(正则表达式);
    匹配成功则返回第一个匹配到的索引,否则返回-1
    search 方法会帮我们进行字符串的查找,和indexOf() 类似

    var str = 'aabbcc';
    console.log(str.search(/[b]/));     // 2
```

### 9.贪婪模式和非贪婪模式 

```
贪婪模式和非贪婪模式  不等于全局模式
    搜索所有标签:    
    贪婪模式:   <.+>         
    非贪婪模式: <.+?>
```

### 10.arguments.callee 对匿名函数进行递归调用 

```
function test (){
        console.dir(arguments);
        console.log(arguments.callee);
}
test(1,2);
```

# 6.PHP

PHP： PHP Hypertext Preprosessor, 超文本预处理器

## 1.网络基本概念

### 1.服务器和客户端

```
服务器（提供服务）指的就是一台安装特定的软件的计算机，用于专门用于提供特定的服务。
	按照服务类型的不同，又划分为：Web 服务器、数据库服务器、文件服务器等等。
客户端（使用服务）指的是在一次服务过程中使用这个服务的设备（网络端点）。目前咱们最常见的客户端就是浏览器
```

### 2.cs和bs

```
bs即：浏览器端和服务器端 常见的就是pc网站类型  
cs即：客户端和服务器端   常见的客户端就是应用app

应用软件架构一般分为两类：
B/S 架构：Browser（浏览器） ←→ Server（服务器），这种软件都是通过浏览器访问一个网站使用，服务器提供数据存储等服务。
C/S 架构：Client（客户端） ←→ Server（服务器），这种软件通过安装一个软件到电脑，然后使用，服务器提供数据存储等服务。
B/S的优点与缺点：
 优点：部署方便(不用安装)，可维护性强。
 缺点：用户体验不好，不能针对每一个用户的不同特点进行设置
C/S的优点与缺点：
 优点：用户体验好
 缺点：部署不方便(需要安装)，可维护性弱 
```

### 3.IP 地址 ,域名,DNS,hosts,端口,url

```
1.IP 地址 : 设备在某一个网络中的地址  127.0.0.1
查看自己ip地址的方法 ：
A、win +r 同时按住 
B、cmd
C、Ipconfig
D、Ipv4即为你电脑的ip地址

```

```
2、DN域名 : 域名就是给ip地址起一个名字
查看域名映射地址的方法：
A、win+r
B、cmd
C、ping+www.baidu.com
```

```
3、DNS域名解析系统
通过宽带运营商提供的服务器解析一个域名背后对应的 IP，这个过程叫做 DNS 寻址，帮你完成 DNS 寻址过程的服务器叫做 DNS 服务器。

执行过程：
A、浏览器收到域名请求
B、DNS查询域名对应的ip地址
C、返回ip
D、根据ip地址查询
```

```
4.hosts文件
操作系统在发起对 DNS 服务器的查询请求之前，会优先检查本机的 hosts 文件
文件所在路径：
Windows：C:\Windows\System32\drivers\etc\hosts
macOS：/etc/hosts
```

```
5.端口
每一个端口都有一个编号，每台计算机只有 65536 个端口（0-65535）。
即找什么就到对应的窗口去查找

http 默认的端口 80
https 默认的端口是 443
netstat -an 命令监视本机端口使用情况：
```

```
6. url:（Uniform Resource Locator），统一资源定位符
格式: 协议名称://域名:端口/文件目录(文件名称)?key=value&key2=value2
例如：https://itcast.cn:80/schools/students?id=18&name=zce#photo

```

## 2.发送请求的过程

```
1.用户打开浏览器
2.地址栏输入我们需要访问的网站网址（URL）
3.浏览器通过 DNS 服务器 获取即将访问的网站 IP 地址
4.浏览器发起一个对这个 IP地址的 请求
5.服务端监听指定的 端口 的服务器软件接收到这个请求，进行相应的处理
6.服务端将处理完的结果返回给客户端浏览器（响应）
浏览器将服务端返回的结果呈现到界面上
```

```
静态网页访问流程:
用户在浏览器输域名->DNS服务器,解析域名->服务器端Apache软件->读取文件->返回数据
```

```
动态网页访问流程:
用户在浏览器输域名->DNS服务器,解析域名->服务器端Apache软件->PHP引擎->数据库->读取文件->返回数据
```

```php
apache和php之间的关系
   apache 服务器
       接请求
       调模块
       做出响应
    php 逻辑
       做业务逻辑处理
pache 是一家没有太多能力的公司，只能处理一些简单的业务（静态网站），但是心很大想做更多的事（动态网站），所以就想到了外包，所有额外的业务都需要外包给其他程序，而 PHP 就是理解为一个专门能够处理 php 业务的外包公司  
```

## 3.PHP输出方式

```php+HTML
a. echo;    echo 'hello','haha'
	可以同时输出多个字符串以逗号分隔

b. print();    print('1111')
   可以输出字符串,它只能输出一个值,里面写两个值会报错,如果输出的是一个数组那么显示Array

c. print_r();    print_r([1,2,3])
   可以输出复杂数据类型,一般用来输出数组,可以得到对应的key和值;如果是数组,则显示以下:
   	Array([0]=>1 [1]=>2 [2]=>3)
	echo 'pre';  //让数组一行显示
    print_r([1,2,3])
    
d. var_dump();    var_dump([1,2,3])
   可以输出复杂数据类型,可以得到对应的key和值,输入数组,还可以获取值的长度
    array(3){[0]=>int(1) [1]=>int(2) [2]=>int(3)}

```

## 4.PHP混编

```php+HTML
PHP代码写在<?php ?> 中,HTML代码不能写在其中
    a. 普通嵌入
    	<p><?php echo 'hello'; ?></p>
    b. 语句混编
    	<?php if (true){ ?>
    			<p>成年人</p>
    	<?php } else { ?>
    			<p>小朋友</p>
    	<?php } ?>

```

## 5. php中的注释和变量 

```php
1.变量语法的定义规则:
a.所以变量必须以$符号作为前缀
b.变量名区分大小写
c.组成由字符,数字,下划线(不能只以$加数字  $3)

$name = 'zs';

2.变量相关的几个函数
isset()  判断变量是否存在,定义了,还可以判断值是否为空
如果echo 输出为 true  返回值为1
如果echo 输出为false  返回值为 null

如果var_dump() 输出为布尔值 true  
如果var_dump() 输出为布尔值false


empty()  判断变量是否为空值，为空的值有："" 0 "0",null,false,array().
如果值为以上中的某一个，则返回值 1
如果echo 输出为 true  返回值为1
如果echo 输出为false  返回值为 null

如果var_dump() 输出为布尔值 true  
如果var_dump() 输出为布尔值false 


unset():删除变量
- 如果删除一个变量，那么变量的值会置为null
- 可以同时删除多个变量
- 如果在函数中删除全局变量，那么并不会真正的将全局变量删除(以后再说)

```

## 6.数据类型-字符串 

```php
常见数据类型
注意：php中把+当做运算符  会自动把+两边的转换成数值，然后进行相加
Php中变量和字符串拼接使用 .来连接

数据类型的分类：
- 基本数据类型：string（字符串） integer（整型） float（浮点型） boolean（布尔型）
- 复合数据类型： array（数组） object（对象）
- 特殊数据类型：NULL（空） 资源

判断数据类型：
- is_string():判断当前变量是否是字符串类型
- is_bool():判断当前变量是否是布尔类型
- is_int():判断当前变量是否是整形类型
- is_float():判断当前变量是否是浮点类型
- is_array():判断当前变量是否是数组类型
- is_object():判断当前变量是否是对象类型

```



## 7.单引号字符串和双引号字符串的区别 

```php+HTML
1、单引号
	(1)	不能解析变量，会将变量当做字符串原样输出
	(2)	支持 \、\\ 转义
2、双引号  
	(1)	如果变量后面紧跟的是合法字符串(中文、a-z、A-Z、0-9、_) 那么会把变量即后面的字符串当成一个整体的变量解析，  此时一般都会找不到这个变量会输出变量前的字符串
	(2)	如果在变量后面加上一个空格这会解析这个变量  此时会有返回值 变量会被解析
	(3)	如果把变量以{}包裹起来   此时能正常解析变量
	(4)	支持转义字符   浏览器端不支持\n换行  需使用br换行

```

## 8.数组

### 1.索引数组

```php+HTML
<?php
// 定义一个索引数组
$arr = array(1, 2, 3, 4, 5);
var_dump($arr);

// PHP 5.4 以后定义的方式可以用 `[]`
$arr2 = [1, 2, 3, 4, 5];
var_dump($arr2);
```



### 2.关联数组

```php+HTML
<?php
// 注意：键只能是`integer`或者`string`
$arr = array('key1' => 'value1', 'key2' => 'value2');
var_dump($arr);

// PHP 5.4 以后定义的方式可以用 `[]`
$arr2 = ['key1' => 'value1', 'key2' => 'value2'];
var_dump($arr2);
```

## 9.数据类型转换

```php+HTML
<?php
$str = '132';
// 将一个内容为数字的字符串强制转换为一个整形的数字
$num = (int)$str;
// 将一个数字强制转换为布尔值
$flag = (bool)$num;
```

## 10.流程控制

### 1.foreach跟js中不同

```php+HTML
- 顺序结构
- 分支结构
  - if ... else
  - switch ... case
- 循环结构
  - for
  - while
  - foreach --- 专门用来遍历数组
	<?php
	$arr = array('name' => 'zhangsan', 'age' => '18');

	foreach ($arr as $key => $value) {
  	echo $key . ' ' . $value;
	}
```

### 2.指令式的 if、for、foreach、while 单独掌握

```php+HTML
<?php
// 指令式就是将开始 { 换成 :  结束 } 换成 endif;
if ($i > 0) :
  echo 'ok'
endif;

// for foreach while 也是一样
for ($i = 0; $i < 10; $i++) :
  echo $i;
endfor;
```

## 11.函数

```php+HTML
定义与使用函数的方式与 JavaScript 相同：
<?php
// 函数名不区分大小写
function foo ($name, $title) {
  echo "$name ($title)";
}

// 调用
foo('zce', 'UFO');
Foo('zgd', 'SBO'); // 大小写不区分
虽然不区分大小写,但还是尽量区分
建议在 PHP 中采用下划线式（snake_case）做命名规则，不管是函数还是变量
```

## 12.特性--作用域和常量

### 1.变量作用域

```
关于变量作用域这一点，PHP 与绝大多数语言也都不同：默认函数内不能访问函数所在作用域的成员。
如果需要访问全局变量，可以通过 global 关键字声明：
<?php
$top = 'top variable';

function foo () {
  // 声明在当前作用域中获取全局作用域中的 `$top`
  global $top;
  echo $top;
}
```

### 2.超全局变量

```
- $GLOBALS — 引用全局作用域中可用的全部变量
- $_SERVER — 获取服务端相关信息
- $_REQUEST — 获取提交参数
- $_POST — 获取 POST 提交参数
- $_GET — 获取 GET 提交参数
- $_FILES — 获取上传文件
- $_ENV — 操作环境变量
- $_COOKIE — 操作 Cookie
- $_SESSION — 操作 Session

```

### 3.$GLOBALS 的使用

```php+HTML
PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。
<?php
$x = 75;
$y = 25;

function foo () {
  $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y'];
}

foo();
echo $z;
// => 100
```

### 4.常量定义与使用

```
常量跟变量一样也是一个数据容器，但是不同的是一旦申明过后就不允许被修改。
```

```php+HTML
定义常量:
<?php
// 定义常量使用的是内置的 `define` 函数
// 第一个参数是常量的名称，建议采用全大写字母命名，多个单词下划线分隔
// 第二个参数是常量中存放的数据，可以是任意类型
// 第三个参数是常量名称是否区不分大小写，默认 false 区分大小写
define('SYSTEM_NAME', '阿里百秀');
define('SYSTEM_ENABLE', true);
```

```php+HTML
使用常量:
<?php
// 直接通过常量的名称访问常量
// 与变量不同的是不需要用 $
echo SYSTEM_NAME;
echo SYSTEM_ENABLE;
```

## 13.载入其他文件

```
- require
- require_once
- include
- include_once

```

## 14常用 API（函数）

```php+HTML
API（Application Programming Interface）:应用程序编程接口
```

### 1.字符串与数组处理

```
字符串函数

- int strlen ( string $string )
- mixed mb_strlen ( string str [, string encoding = mb_internal_encoding() ] )

数组长度

- count()

```

### 2.时间处理

```
- 时间戳：time()
  - 从 Unix 纪元（格林威治时间 1970-01-01 00:00:00）到当前时间的秒数
- 格式化日期：date()
  - 获取有格式的当前时间
  - 格式化一个指定的时间戳
  - 可以通过 strtotime() 将有格式的时间字符串转换为时间戳

```

### 3.文件操作

```
file_get_contents()  将文件读入字符串
file_put_contents()  将字符串写入文件。
```

## 15.GET与POST

### 1.什么是GET请求

```
GET从字面上理解为'获取'，通常用于获取服务端的数据。
常见的发起GET请求的方式有：
- 地址栏访问
- src/href
- 表单

```

## 16.表单的使用

### 1.表单基本使用

```php+HTML
HTML 中有一个专门用于提交数据的标签：<form>，通过这个标签可以很容易的收集用户输入。

form 标签有两个必要属性：

- action：表单提交地址（填完了，交给谁）
    从便于维护的角度考虑，一般我们最常见的都是提交给当前文件,不要写死,万一文件名修改就麻烦了,用$_SERVER['PHP_SELF']获取
    在后台接收数据时判断是否是表单提交请求
    <?php
	if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  	// 表单提交请求
	}
----------------------------------------
- method：表单以什么方式提交 POST || GET
GET
- 表单数据是通过 URL 中的 ? 参数传递到服务端的
- 可以在地址栏中看到提交的内容
- 数据长度有限制，因为 URL 地址长度有限（2000个字符）

POST:
- 表单数据是通过请求体传递到服务端的，我们在界面上看不到
- 可以提交任何类型的数据，包括文件
- 由于界面上看不见，浏览器也不储存，所以更安全

--------------------------------------------
例如:
  <form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
    <div>
      <label for="username">用户名</label>
      <input type="text" id="username" name="username">
    </div>
  </form>
```

```php+HTML
PHP 中有三个超全局变量专门用来获取表单提交内容：

- $_GET：用于获取以 GET 方式提交的内容，更标准的说法：接收 URL 地址问号参数中的数据
- $_POST：用于获取以 POST 方式提交的内容，更标准的说法：接收 请求体 中的数据
- $_REQUEST：用于获取 GET 或 POST 方式提交的内容

```

```php+HTML
借助 $_POST 或者 $_REQUEST 就可以获取到表单提交的内容：
<?php
// 获取表单提交的用户名和密码
echo '用户名：' . $_REQUEST['username'];
echo '密码：' . $_REQUEST['password'];
```

### 2.常见表单元素处理

```
name 属性值作为键，用户填写的信息作为值，发送到服务端。
表单元素中还有一些比较特殊的表单元素需要单独考虑:
```

#### 1.单选按钮

```php+HTML
<!-- 最终只会提交选中的那一项的 value -->
<input type="radio" name="gender" value="male">
<input type="radio" name="gender" value="female">
```

#### 2.复选按钮

```php+HTML
<!-- 没有设置 value 的 checkbox 选中提交的 value 是 on -->
<input type="checkbox" name="agree">
<!-- 设置了 value 的 checkbox 选中提交的是 value 值 -->
<input type="checkbox" name="agree" value="true">
```

如果需要同时提交多个选中项，可以在 `name` 属性后面 跟上 `[]`

最终提交到服务端，通过 `$_POST` 接收到的是一个索引数组。

#### 3.选择框

```php+HTML
<select name="subject">
  <!-- 设置 value 提交 value -->
  <option value="1">语文</option>
  <!-- 没有设置 value 提交 innerText -->
  <option>数学</option>
</select>
```

## 17.文件上传

**注意：**

- 修改 `php.ini` 中的 `post_max_size` 配置，让服务端可以接受更大的请求体体积
- 修改 `php.ini` 中的 `upload_max_filesize` 配置，让服务端支持更大的单个上传文件

`type` 属性为 `file` 的 `input` 元素可以通过表单提交文件（上传文件），服务端 PHP 可以通过 `$_FILES` 获取上传的文件信息。

```php+HTML
<?php
// 如果选择了文件 $_FILES['file']['error'] => 0
// 详细的错误码说明：http://php.net/manual/zh/features.file-upload.errors.php
if ($_FILES['file']['error'] === 0) {
  // PHP 在会自动接收客户端上传的文件到一个临时的目录
  $temp_file = $_FILES['file']['tmp_name'];
  // 我们只需要把文件保存到我们指定上传目录
  $target_file = '../static/uploads/' . $_FILES['file']['name'];
  if (move_uploaded_file($temp_file, $target_file)) {
    $image_file = '/static/uploads/' . $_FILES['file']['name'];
  }
}
```

`$_FILES` 同样也是一个关联数组，键为表单的 `name`，内容如下：

```php+HTML
array(1) {
  ["avatar"]=>
  array(5) {
    ["name"]=>
    string(17) "demo.jpg"
    ["type"]=>
    string(10) "image/jpeg"
    ["tmp_name"]=>
    string(27) "C:\Windows\Temp\php786C.tmp"
    ["error"]=>
    int(0)
    ["size"]=>
    int(29501)
  }
}
```

文件移动: [move_uploaded_file()](http://www.w3school.com.cn/php/func_filesystem_move_uploaded_file.asp) | 将上传的文件移动到新位置。 

## 18.JSON

```
JSON（JavaScript Object Notation） 是一种通过普通字符串描述数据的手段，用于表示有结构的数据.
1. JSON 中属性名称必须用双引号包裹
2. JSON 中表述字符串必须使用双引号
3. JSON 中不能有单行或多行注释
4. JSON 没有 undefined 这个值

```

```
JSON 反序列化

- json_decode 需要注意第二个参数
- 如果希望以关联数组的方式而非对象的方式操作数据，可以将 json_decode 的第二个参数设置为 true

```

## 19.HTTP

HTTP（HyperText Transfer Protocol，超文本传输协议）最早就是计算机与计算机之间沟通的一种标准协议，这种协议限制了通讯**内容的格式**以及各项**内容的含义**。 **HTTP 为端与端之间的通讯协议**。

Web 属于 B/S 架构的应用软件，在 B/S 架构中，浏览器与服务器沟通的协议就是 HTTP 协议

### 1.约定内容

```
- 请求 / 响应报文格式
- 请求方法 —— GET / POST / etc.
- 响应状态 —— 200 / 404 / 302 / 304 / etc.
- 预设的请求 / 响应头

```

### 2.约定形式

```
1. 客户端通过随机端口与服务端某个固定端口（一般为80）建立连接 三次握手
2. 客户端通过这个连接发送请求到服务端（这里的请求是名词）
3. 服务端监听端口得到的客户端发送过来的请求
4. 服务端通过连接响应给客户端状态和内容（响应报文）

```

### 3.报文

#### 1.请求报文

```
请求行
GET /demo.php HTTP/1.1
请求方式 + 空格 + 请求路径 + 空格 + HTTP 协议版本

请求头
客户端想要告诉服务端的一些额外信息

请求体
这次请求客户端想要发送给服务端的数据正文，一般在 GET 请求时很少用到，因为 GET 请求主观上都是去“拿东西”。

```

#### 2.响应报文

```
状态行
HTTP/1.1 200 OK
HTTP 协议版本 + 空格 + 状态码 + 空格 + 状态描述

响应头
服务端想要告诉客户端的一些额外信息，

响应体
这次请求服务端想要返回给客户端的数据正文，一般返回的都是 HTML，也可以返回 JavaScript 或者 CSS（需要修改响应头中的响应类型）。

```

### 4.应用场景

- 设置响应文件类型

  - `header('Content-Type: text/css');`
  - 常见的 HTTP MIME type：`text/css` `text/html` `text/plain` `applcation/javascript`

- 重定向（跳转到其他网页）

  - `header('Location: https://www.baidu.com');`

- 下载文件

- ```
  // 让文件下载
  header('Content-Type: application/octet-stream');
  // 设置默认下载文件名
  header('Content-Disposition: attachment; filename=demo.txt');
  ```

  图片防盗链

  - 通过判断请求来源 `Referer` 是否为本网站从而区分是否是合法请求

### 5.请求方式

#### 1.GET

字面意思：拿，获取

```
后退按钮/刷新:   无害
书签: 可收藏为书签
缓存 : 能被缓存
编码类型:  application/x-www-form-urlencoded  历史: 参数保留在浏览器历史中
对数据长度的限制: URL 的长度是受限制的（URL 的最大长度是 2048 个字符）
对数据类型的限制: 只允许 ASCII 字符
安全性: GET 的安全性较差，因为所发送的数据是 URL 的一部分
```



#### 2.POST

字面意思：发，给

```
后退按钮/刷新: 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
书签 : 不可收藏为书签
缓存 : 不能缓存
编码类型: application/x-www-form-urlencoded 或 multipart/form-data
历史: 参数不会保存在浏览器历史中
对数据长度的限制:   无限制。
对数据类型的限制:  没有限制,也允许二进制数据
安全性: POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中
```

### 6.状态码

- 1xx：指示信息 —— 表示请求已接收，继续处理。
- 2xx：成功 —— 表示请求已被成功接收、理解、接受。
- 3xx：重定向 —— 要完成请求必须进行更进一步的操作。
- 4xx：客户端错误 —— 请求有语法错误或请求无法实现。
- 5xx：服务器端错误 —— 服务器未能实现合法的请求。

## 20.会话技术 Cookie和Session

### 1.Cookie

Cookie 就像是在超级市场买东西拿到的小票，由超市（Server）发给消费者（Browser），超市方面不用记住每一个消费者的脸，但是他们认识消费者手里的小票（Cookie），可以通过小票知道消费者之前的一些消费信息（在服务端产生的数据）。

#### 1.PHP 中操作 Cookie

```php+HTML
// 设置 cookie
setcookie("TestCookie", "hello", time() + 1 * 60 * 60);  /* 1 小时过期  */
// 获取 cookie
echo $_COOKIE["TestCookie"];
```

```sequence
客户端->服务端: Request GET /login.php
服务端->客户端: Response 空白表单页面
Note left of 客户端: 用户填写表单
客户端->服务端: Request POST /login.php 表单数据
Note right of 服务端: 服务端对提交过来的数据进行校验
服务端->客户端: Response Location: /main.php\n跳转到 main.php
客户端-->服务端: Request GET /main.php
服务端-->客户端: Response Welcome
Note over 客户端,服务端: ..........
客户端->服务端: Request GET /login.php
服务端->客户端: Response 空白表单页面
```

#### 2.JavaScript 中操作 Cookie

```js
// 新增一条 cookie，注意：cookie 是有大小限制，约为 4k
//   格式固定：<key>=<value>[; expires=<GMT格式时间>][; path=<作用路径>][; domain=<作用域名>]
//   除了键值以外其余属性均有默认值，可以省略
//   expires 表示 cookie 失效的时间，默认为关闭浏览器时
//   path 表示 cookie 生效的路径，默认为当路径
//       /   /foo.php   /abc/foo.php
//       /foo     /bar/abc.php
//   domain 表示 cookie 生效的域名，默认为当前域名

document.cookie = 'name=value; expires=Tue, 10 Oct 2017 16:14:47 GMT; path=/; domain=zce.me'
// 获取全部 cookie
console.log(document.cookie)
// => 'key1=value1; key2=value2'
// 得到的结果是字符串，需要自己通过字符串操作解析
```

### 2.Session

由于 Cookie 是服务端下发给客户端**由客户端本地保存**的。换而言之客户端可以在本地对其随意操作，包括删除和修改。如果客户端随意伪造一个 Cookie 的话，对于服务端是无法辨别的，就会造成服务端被蒙蔽，构成安全隐患。

于是乎就有了另外一种基于 Cookie 基础之上的手段：**Session**：Session 区别于 Cookie 一个很大的地方就是：Session 数据存在了服务端，而 Cookie 存在了客户端本地，存在服务端最大的优势就是，不是用户想怎么改就怎么改了。

## 21.数据库 MySQL

### 1.基本概念

- 数据库
- 表
- 字段 —— 指的就是列
- 字段类型 —— 指的就是列能够存储的数据种类
  - int
  - char(<length>)
  - varchar(<length>)
  - date
  - decimal
- 数据库查询：指的是操作数据库的过程（查、增、删、改）
- 数据库查询语言：SQL

### 2.基础操作

#### 1.查询

```
-- 查询数据
-- select 字段[, 字段2] from 表名
select id, name, birthday from users;

-- 通配 * 找到表中所有列
select * from users;
```

#### 2.增加

```
-- 新增数据
-- 插入全部字段
insert into users values (null, '王五', 0, '2020-12-12', '12312');
-- 指定字段
insert into users (name, gender, avatar) values ('王五', 0, '12312');
```

#### 3.修改

```
-- 更新数据
update users set name = '麻子', gender = 0
```

#### 4.删除

```
-- 删除
-- 删除语句必须指定条件
delete from users 
```

#### 5.筛选条件

- 总条数 —— count 分页功能，查询总页数
- 最大值、最小值 —— max/min
- 平均值 —— avg

```
delete from users where id = 6
delete from users where id = 6 and gender = 0
delete from users where id = 6 or gender = 0
delete from users where id > 6
delete from users where id in (4, 5)

select fn(field1) from table
```

## 22.PHP操作MySQL

```
// 假定数据库用户名：root，密码：123456，数据库：baixiu
$connection = mysqli_connect("localhost", "root", "123456", "baixiu");

if (!$connection) {
  // 如果连接失败报错
  die('<h1>Connect Error (' . mysqli_connect_errno() . ') ' . mysqli_connect_error() . '</h1>');
}

$sql = "select * from users";
$result = mysqli_query($connection, $sql);

// 查询数据填充到关联数组
while ($row = mysqli_fetch_assoc($result)) {
  echo $row["id"] . " - " . $row["username"];
}

// 释放结果集
mysqli_free_result($result);

mysqli_close($connection);
```

## 23.php函数补充

#### 1.字符串处理函数

```php
- 字符串截取
  - string 	substr ( string string , int start [, int $length ] )
  - string      mb_substr ( string str , int start [, int length = NULL [, string encoding = mb_internal_encoding() ]] )
- 字符串长度
  - int           strlen ( string $string )
  - mixed     mb_strlen ( string str [, string encoding = mb_internal_encoding() ] )
- 大小写转换
  - string       strtolower ( string $string )
  - string       strtoupper ( string $string )
- 去除首尾空白字符
  - string        trim ( string str [, string character_mask = " \t\n\r\0\x0B" ] )
- 查找字符串中某些字符首次出现位置
  - mixed 	strpos ( string haystack , mixed needle [, int $offset = 0 ] )
  - int           mb_strpos ( string haystack , string needle [, int offset = 0 [, string encoding = mb_internal_encoding() ]] )
- 字符串替换
  - mixed      str_replace ( mixed search , mixed replace , mixed  $subject [, int &  $count ] )
- 重复字符串
  - string        str_repeat ( string input , int multiplier )
- 字符串分割
  - array         explode( string char, string input )

```

#### 2.数组处理

```
- 获取关联数组中全部的键 / 值
  - array_keys()      键
  - array_values()   值
- 判断关联数组中是否存在某个键
  - array_key_exists()
- 将一个或多个元素追加到数组中
  - array_push()
  - $arr[] = 'new value'
- 删除数组中最后一个元素
  - array_pop()
- 数组长度
  - count()
- 检测一个元素在数组中是否存在
  - in_array()
- 获取元素在数组中的下标
  - array_search()

```

# 7.ajax

## 1.概念

```
Ajax的概念,即 Asynchronous Javascript And XML（异步的JavaScript和XML），AJAX 不是一门的新的语言，而是对现有持术的综合利用。
1.基于web标签的xhtml+css
2.可以使用dom进行动态的显示和交互
3.使用XML和XSLT(是一种用于将XML文档转换任意文本的描述语言)进行数据的交换和操作
4.使用XMLHttpRequest进行异步的数据查询和检索等操作。。。
作用：实现客户端和服务器的交互，具体的说，就是可以在页面不刷新的情况下，请求服务器，局部更新页面的数据；

本质:是在HTTP协议的基础上以异步的方式通过XMLHttpRequest对象与服务器进行通信。
```

## 2.异步与同步

```
异步，指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。 
其优势在于不阻塞程序的执行，从而提升整体执行效率。

同步：同一时刻只能做一件事，上一步完成才能开始下一步
异步：同时做多件事，效率更高
```

## 3.使用异步对象发送get请求

1、创建异步对象：var xhr = new XMLHttpRequest();
2、open()函数：设置 请求行 open(请求方式，请求url):
3、send()函数：设置 请求体:发送请求  send(参数：key=value&key=value)

```js
document.querySelector("#username").onblur = function(){
// 1.获取用户数据
var name = this.value;
    
// 2，让异步对象发送请求
// 2.1 创建异步对象
var xhr = new XMLHttpRequest();
    
// 2.2 设置 请求行 open(请求方式，请求url):
// get请求如果有参数就需要在url后面拼接参数，
// post如果有参数，就在请求体中传递
xhr.open("get","validate.php?username="+name);
    
// 2.3 设置 请求头 setRequestHeader('key':'value')
// get方式不需要设置请求头
// post需要设置 Content-Type:application/x-www-form-urlencoded
    
// 2.4 设置 请求体:发送请求 send(参数：key=value&key=value)
// 如果有参数，post应该在这个位置来传递参数
// 对于 get请求不需要在这个位置来传递参数
xhr.send(null);
```

## 4.使用异步对象接收响应

研究对象其实就是研究它的三要素：属性、方法、回调函数
属性：status/readyState/responseText
方法：open()/send()
事件执行回调函数：onreadystatechange
通过事件来监听服务器的响应状态

```js
// 响应报文：
// 报文行：响应状态码 响应状态信息  200 ok
// 报文头：服务器返回给客户端的一些额外信息  
// 报文体：服务器返回给客户端的数据 responseText:普通字符串  responseXML：符合xml格式的字符串
// xhr.status:可以获取当前服务器的响应状态  200 》成功
console.log(xhr.status);
// 一个真正成功的响应应该两个方面：1.服务器成功响应  2.数据已经回到客户端并且可以使用了
// 监听异步对象的响应状态 readystate ,有下面几个值：
// 0:创建了异步对象，但是还没有真正的去发送请求
// 1: 调用了send方法，正在发送请求
// 2: send方法执行完毕了，已经收到服务器的响应内容--原始内容，还不可以使用
// 3: 正在解析数据
// 4: 响应内容解析完毕，可以使用了
xhr.onreadystatechange = function(){
    if(xhr.status == 200 && xhr.readyState == 4){
        console.log(xhr.responseText);
        console.log("-----------");
        document.querySelector(".showmsg").innerHTML = xhr.responseText;
    }
}
```

![1544581934097](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544581934097.png)

## 5.使用异步对象发送post请求并接收响应

```js
document.querySelector("#username").onblur = function(){
/* 1、获取数据 */
var name=this.value;
/* 2、异步对象获取数据*/
var xhr=new XMLHttpRequest();
/* 请求行 */
xhr.open("post","validate.php");
/* 请求头 */
xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
/* 请求体 */
xhr.send("username="+name);
/* 3、监听异步请求 */
xhr.onreadystatechange=function(){
if(xhr.status==200&&xhr.readyState==4){
document.querySelector(".showmsg").innerHTML=xhr.responseText;
}
}
};
```

## 6.通过异步对象读取json文件生成动态页面结构

步骤分析
1、创建异步对象
(1)设置请求行  get请求
(2)发送请求
2、服务器端响应前台数据的回调函数监听
(1)获取响应数据，判断是否响应了并解析玩可以使用
(2)返回的数据类型为字符串需要将数据类型转换成数组，并对其进行遍历将要渲染的数据进行字符串叠加
3、将生成的dom结构渲染在页面上

```js
/* 1、创建异步对象 */
var xhr=new XMLHttpRequest();
xhr.open("get","./server/nav-json.php");
xhr.send(null);
xhr.onreadystatechange=function(){
if(xhr.status==200 && xhr.readyState==4){
console.log(typeof xhr.responseText);
var data=JSON.parse(xhr.responseText);  //将返回的字符串变为数组
console.log(typeof data);

//字符串拼接方法1:
var html="";
for(var i=0;i<data.length;i++){
html+="<li>"
html+="<a href='#'>"
html+=" <img src='./images/nav_2.png' alt=''>"
html+=" <p>全球购物</p>"
html+=" </a>"
html+="</li>"
}
console.log(html);
// 将生成的页面结构添加到dom元素中
document.querySelector("ul").innerHTML = html;
}
}
```

#### 1.字符串拼接方法

以上代码中的字符串拼接还有以下方法:

```js
/*方法1: 字符串拼接*/:
var html="";
for(var i=0;i<data.length;i++){
html+="<li>"
html+="<a href='#'>"
html+=" <img src='./images/nav_2.png' alt=''>"
html+=" <p>全球购物</p>"
html+=" </a>"
html+="</li>"
}

/*  方法2： 字符串拼接 */
html+="<li>"+
    "<a href='#'>"+
        "<img src='./images/nav_2.png' alt=''>"+
        "<p>全球购物</p>"+
    "</a>"+
"</li>";

/* 方法3： 转义符*/
html+="<li>\
    <a href='#'>\
        <img src='./images/nav_2.png' alt=''>\
        <p>全球购物</p>\
    </a>\
</li>";

/* 方法4   模板字符串方法es6*/
 html+=`<li>
    <a href="#">
        <img src="./images/nav_2.png" alt="">
        <p>全球购物</p>
    </a>
</li>`;
```

## 7.客户端渲染和服务器端渲染

![1544582625784](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544582625784.png)



## 8.之前异步请求代码的改进(封装为函数)

Callback函数的理解
当执行成功后数据渲染，将渲染的数据封装起来了，在调用这个函数即可，
调用的时候函数写死了可以把调用的函数写或使用callback表示即可那么调用不同的函数替换掉cakkback即可

![1544582742091](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544582742091.png)

## 9.ajax的封装(略,我们一般使用jquery中封装的方法)

## 10.jquery中封装的ajax方法的使用

![1544583234561](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544583234561.png)

Timeout 是等待时间的设置，单位是毫秒
sleep(4)函数的单位是秒数

## 11. json_encode()和json_decode()  $().serialize()

json_encode() 对变量进行JSON编码
json_decode() 对JSON数据进行解码，转换为PHP变量

json_decode( )    ---- json 转 对象/数组
当第二个参数为true返回 array ,默认是false返回object。

json_encode( )    ---- 对象/数组 转 json
成功返回 json 编码的 string ,失败返回 false 。

$().serialize()获取的是表单以name属性为key，表单输入值为key所对应的值

## 12.注册案例-实现注册

步骤分析：
1、注册按钮绑定 点击事件
2、校验按钮是否存在disabled类名(防止在加载的过程中存在重复多次点击)
3、获取表单所有值
4、发送ajax
(1)请求前添加disabled类名并设置按钮值为注册中
(2)成功后显示成功后的提示，失败后显示失败后的值
(3)不管成功还是失败都将disabled移除，按钮显示为注册

![1544583799260](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544583799260.png)

## 13.模板引擎

ArtTemplate : 模板引擎是为了使 用户界面与业务数据分离出来的方法,它用于生成特定网页结构块

作用:为了动态渲染的时候,简化字符串的拼接

```
1.安装 : npm i art-template -S  下载了文件夹,
2.引入jquery.js , web.js (支持原生和简洁语法)	在art-template/lib/template-web.js
3.编写模板 id="tpl"  type="text/template"
4.调用template方法: template("tpl",{})
```



### 1.exec函数的介绍

```js
<script>
    var str = "heima@itcast.cn";
    // 使用正则的方式实现获取源字符串中的指定部分
    // test():检测字符串是否与指定的正则表达式匹配，如果匹配则返回true,否则返回false。侧重于判断是否匹配
    // exec():检测字符串是否与指定的正则表达式匹配，同时可以提取某些匹配的部分，侧重于匹配之后的提取
    // 使用步骤：
        // 1.创建一个符合源字符串规则的正则表达式
        // 2.调用exec方法
        // 3.实现返回值的接收--返回一个数组
        // 4.如何实现提取：将你想提取的字符串的对应的正则表达式部分用()包含
    var reg = /(\w+)[@]((\w+)[.](\w+))/;
    var obj = reg.exec(str);
    console.log(obj);
</script>
```

### 2.artTemplate原生语法的使用(<%js语句%>    <%=数据%>)

步骤分析：
1、引入art-template.js
2、编写模板  type=”text/template” id=””
3、Js中调用template(模板的id，传入的对象)

```html
<script type="text/template" id="navTemp">
    <% for(var i=0; i < items.length; i++){ %>
        <li>
            <a href="#">
                <img src="<%=items[i].src%>" alt="">
                <p><%=items[i].text%></p>
            </a>
        </li>
    <% } %>
</script>
```

![1544584396713](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544584396713.png)

### 3.artTemplate简洁语法的使用( {{js语句}}   {{数据}})

```js
<script type="text/template" id="musicTemp">
   {{each items as value index}}
      {{if index == 0}}
         <tr bgcolor='red'>
      {{else if index == 1}}
         <tr bgcolor='green'>
      {{else}}
         <tr bgcolor='blue'>
      {{/if}}
         <td>{{items[index].title}}</td>
         <td>{{value.singer}}</td>
         <td>{{value.album}}</td>
         <td>
            <audio src="{{value.src}}" controls></audio>
         </td>
         <td>
            <a href="./edit.php?id={{value.id}}" class="btn btn-primary">编辑</a>
            <a href="./delete.php?id={{value.id}}" class="btn btn-danger">删除</a>
         </td>
      </tr>
   {{/each}}
</script>
```

```
template()传入的第二个参数有几种传参方式:
1.{"items":res.rows}	模板里循环items数组
2.{res}		模板里循环res里的rows数组
```



## 14.跨域

### 1.什么是同源？

同源策略是浏览器的一种安全策略，

所谓同源是指，协议, 域名，端口完全相同。

### 2.什么是跨域？

不同源则跨域,即协议,域名,端口有一种不一样就是跨域

### 3.解决跨域请求的方法

#### 1.在服务器端添加响应头实现跨域请求

```php
header( 'Access-Control-Allow-Origin:*' );  
设置所有的都可以访问
header( 'Access-Control-Allow-Origin:http://www.study.com'); 
设置http://www.study.com可以访问
```

#### 2.ajax中jsonp的使用(利用了script天然的可跨域的特性)

```js
$.ajax({
type:'get',
//url:'getnav.php',
url:'http://day8.com/getnav.php ',
// dataType:'json',
// 开启跨域请求
//后台接收数据的时候会判断dataType 发送过去的是不是jsonp,如果是,就动态创建一个<script src=""></script> 标签,将url中的请求地址放入src中,通过script进行请求并返回数据
dataType:"jsonp",
success:function(result){
console.log("有没有调用、");
var html = template("navTemp",{"items":result});
document.querySelector("ul").innerHTML = html;
}
});
```



```
概念：
JSONP：JSON with Padding
JSONP是JSON的一种使用模式，主要作用：解决浏览器跨域请求的问题。

原理剖析：
其本质是利用了<script src=""></script>标签具有可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。

只能以GET方式请求

jQuery中的JSONP：
jQuery 的$.ajax() 方法当中集成了JSONP的实现，可以非常方便的实现跨域数据的访问。
dataType:'jsonp' 设置dataType值为jsonp即开启跨域访问
jsonp 可以指定服务端接收的参数的“key”值，默认为callback
jsonpCallback 可以指定相应的回调函数，默认自动生成

前端：ajax的请求类型为jsonp
后端：获取函数 +读取文件+将函数返回给前端同时带上数据
```

##### jsonp的实现原理说明

```
原理分析：
1、script标签传递参数给后台
2、后台接受这个参数
3、后台将参数以函数的形式返回给前台并携带返回给前台的数据
4、前台以传递参数所对应值为函数接收后台返回的数据
```

![1544585212165](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585212165.png)

![1544585232323](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585232323.png)

### 4.formdata获取表单提交数据

#### 1.可以帮我们收集表单数据

Formdata的一些方法：
let formData = new FormData()
formData.append('user', 'zhang')
获取 formData.get('user')  //zhang
删除 formData.delete('user')

![1544585690852](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585690852.png)

返回值:

![1544585707871](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585707871.png)

#### 2.第二个功能：可以获取文件上传的信息

![1544585803490](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585803490.png)

如果需要上传多张 :添加multiple属性，name属性的值后面加一个[]

#### 3.formdata文件上传补充说明

1、解决文件过大不能上传的问题
在phpstudy的打开配置文件php.ini中更改

![1544585966180](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585966180.png)![1544585976448](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544585976448.png)



onprogress的触发时机===在send前触发

## 15.案例:学生管理系统

### 1-学生管理系统-首页动态数据的展示.(ajax+模板引擎)

```js
<script type="text/template" id="dataList">
    <%for(var i = 0;i< items.length;i++){%>
        <tr>
            <td><%=(pageNum -1) * pageSize + i + 1%></td>
            <td><%=items[i].name%></td>
            <td><%=items[i].age%></td>
            <td><%=items[i].username%></td>
            <td><%=items[i].school%></td>
            <td><a href="javascript:;" data-id="<%=items[i].id%>" class="delete" title="删除"><span class="glyphicon glyphicon-remove"></span></a></td>
        </tr>
    <%}%>
</script>

/*数据展示*/
$.ajax({
    type:'get',
    url:'findUsers.php',
    data:{
        pageNum:1,
        pageSize:10
    },
    dataType:"json",
    success:function(result){
        console.log(result);
        // 渲染数据列表
        var html = template("stuListTemp",result);
        $("tbody").html(html);
    }
});
```

### 2-学生管理系统-渲染分页结构块

```
分页渲染需要数据分析：
1、pageNum得到当前页    计算当前页的编码 (pageNum-1)*每页的条数+i+1 因为没加载一次数据都是重新获取，那i就是从0开始计算
2、totalPage获取总页数    得到总条数=总页数/每页显示条数在向上取整
a.disabled {cursor: not-allowed;}
```

```
<!-- 分页结构块的模板 -->
<script type="text/template" id="pageTemp">
    <li>
        <a class="prev <%=pageNum==1?'disabled':''%>" href="javascript:void(0)" aria-label="Previous" data-Page="<%=pageNum-1%>">
            <span aria-hidden="true">&laquo;</span>
        </a>
    </li>
    <li><a class='control curr' href="javascript:void(0)"><%=pageNum%></a></li>
    <li><a class='control' href="javascript:void(0)">/</a></li>
    <li><a class='control total' href="javascript:void(0)"><%=totalPage%></a></li>
    <li>
        <a class="next <%=pageNum==totalPage?'disabled':''%>" href="javascript:void(0)" aria-label="Next" data-Page="<%=pageNum+1%>">
            <span aria-hidden="true">&raquo;</span>
        </a>
    </li>
</script>

// 渲染分页结构块
var pageHtml = template("pageTemp",{"pageNum":result.pageNum,"totalPage":Math.ceil(result.total/result.pageSize)});
$(".pagination").html(pageHtml);
```

### 3-学生管理系统-分页功能实现

Data-page =  pageNum-1   自定义属性
获取当前页pageNum  当要实现上一页直接当前页-1，实现下一页直接当前页+1

步骤分析：
1、需要事件委托方式给按钮绑定点击事件(因为是动态添加的元素)
2、判断是否有类名disable，有就阻止
3、判断是否有pre或者next类名，有就获取自定义的属性data-page
4、发送请求获取自定义的属性data-page页的数据

```js
function render(cpage,pageSize){
    $.ajax({
        type:'get',
        url:'findUsers.php',
        data:{
            pageNum:cpage || 1,
            pageSize:pageSize || 2
        },
        dataType:"json",
        success:function(result){
            console.log(result);
            // 渲染数据列表
            var html = template("stuListTemp",result);
            $("tbody").html(html);

            // 渲染分页结构块
            var pageHtml = template("pageTemp",{"pageNum":result.pageNum,"totalPage":Math.ceil(result.total/result.pageSize)});
            $(".pagination").html(pageHtml);
        }
    });
}
render();

// 实现分页功能--事件委托来实现
$(".pagination").on("click","a",function(){
    // 如果是第一页或者最后 一页则不进行响应处理
    if($(this).hasClass("disabled")){
        return;
    }
    // 单击了上一页或者下一页按钮的时候才进行响应处理
    if($(this).hasClass("prev") || $(this).hasClass("next")){
        var currentPage = $(this).attr("data-page");
        // alert(currentPage);
        render(currentPage);
    }
})
```

### 4-学生管理系统-新增功能的实现

```js
// 实现新增操作
$("#save").on("click",function(){
    $.ajax({
        type:'post',
        url:'saveUser.php',
        data:$("#newUser").serialize(),
        dataType:'json',
        beforeSend:function(){},
        success:function(result){
            console.log(result);
            if(result.status == "ok"){
                alert('新增成功');
                render();
            }
        }
    });
});
```

### 5-学生管理系统-删除功能的实现

```
步骤分析：
1、事件委托绑定事件
2、给出提示判断是否要删除
3、获取当前删除行的id  需要自定义属性data-id
4、发送ajax请求
5、成功后判断
(1)重新加载删除后的当前页的数据
(2)判断页面上显示数据条数是否等于1，还需判断当前是否在第一页
①如果当前页等于1说明当前页只有一条，只能渲染当前页
②如果当前页不等于1说明当前页大于1，那么当前页没有数据了那就显示上一页的数据
```

```js
// 实现删除功能
$("tbody").on("click",".delete",function(){
    // 底部用户是否真的需要删除
    if(window.confirm('请问是否真的需要删除?')){
        var id = $(this).attr("data-id");
        $.ajax({
           type:'post',
           url:'removeUser.php',
           data:{"id":id},
           dataType:'json',
           success:function(result){
                if(result.status == "ok"){
                    alert('删除成功');
                    // 注意：删除和刷新是两个不同的操作。如果这一次删除之后但是在刷新之前，我们发现这个tbody中的tr的数量只有一个，那么就说明刷新之后这一页应该没有数据了，那么就应该显示上一页的内容
                    if($("tbody").children().length == 1){
                        // 判断当前是否是第一页，如果是第一页就直接刷新第一页而不是上一页
                        if(window.pageNum == 1){
                            render(window.pageNum);
                        }else{     
                            render(window.pageNum - 1);
                        }
                    }
                    render(window.pageNum);
                }
           }
       });
    }
});
```

# 8.h5c3

### 1-h5新增语义化标签

```js
header:头部    nav:导航  main:主体内容   footer:底部   article:文章  aside:侧边栏
这些语义化标签有兼容性问题:
IE9:认识语义化标签(有选择性)
IE8及以下:完全不支持语义标签(不支持html5):在IE8中，它不认识语义标签，
IE10及以上支持
  所以无法解析这些标签，也就意味着所写的样式无效。
  解决方法一:用js的方法创建这些标签: 						       		document.createElement("header");
     设置样式的时候全部都先转化成为块元素 : display:block 
  解决方法二:引入一个js文件 
     <script src="js/html5shiv.min.js"></script>
```

### 2-表单新增type属性

```html
<form action="">
    用户名:<input type="text" name="userName"><br>
    密码: <input type="password" name="pwd"><br>
	邮箱: <input type="email" name="email"><br>
	手机号: <input type="tel" name="tel"><br>
	网址: <input type="url"><br>
	数量: <input type="number" value=60 max=100 min=0><br>
	请输入商品名称: <input type="search" name="good"><br>
	范围: <input type="range" value=50 max=100 min=0><br>
    颜色: <input type="color"><br>
        <!-- 日期时间相关 -->
	时间: <input type="time"><br>
	日期: <input type="date"><br>
	日期时间: <input type="dateTime"><br>
    日期时间: <input type="dateTime-local"><br>
	星期: <input type="week"><br>
    月份: <input type="month"><br>
    	<!-- 提交按钮 -->
	<button type="submit">提交</button>
</form>
```

### 3-h5c3中新增其他属性

### 4-网络接口

```js
window.ononline=function(){
	console.log("网络连接");
}
window.onoffline=function(){
	console.log("网络断开");
}
```

### 5-全屏接口

```js
由于有兼容性问题,使用时要进行判断,即能力测试
1.操作全屏
div.requestFullScreen();
div.webkitRequestFullScreen();
div.mozRequestFullScreen();
div.oRequestFullScreen();
div.msRequestFullScreen();
2.退出全屏(能力测试)
document.cancelFullScreen();
3.是否全屏(进行判断,返回true/false),能力测试
document.fullscreenElement
```

### 6-类样式的操作

```js
之前是: dom对象.className = "blue underline";//将原来的类覆盖
添加类样式:dom对象.classList.add("underline"); //添加,一次只能添加一个
获取样式:var result = dom对象.classList;	//结果是由类名组成的数组可以用[索引]来找
移除类:dom对象.classList.remove();
切换类:dom对象.classList.toggle();  //有这个样式就移除,没有就添加
判断是否有类:dom对象.classList.contains();//返回true/false
```

### 7-自定义属性

```js
规范：
    1.data-开头
    2.data-后必须至少有一个字符，多个单词使用-连接
建议：
    1.名称应该都使用小写--不要包含任何的大写字符
    2.名称中不要有任何的特殊符号
    3.名称不要副作用纯数字
<p data-school-name="itcast">传智播客</p>
var value=p.dataset["schoolName"];//data-school-name

总结:获取自定义属性的四种方法:
dom对象.dataset["schoolName"];
dom对象.getAttribute('data-school-name');
jq对象.data("schoolName");	设置直接写在标签里面
jq对象.attr("data-school-name")
```

### 8-拖拽接口

```html
拖拽的前提条件是:给被拖拽元素设置:draggable = true
实现能够将多个元素拖拽到多个目标区域,将事件触发源改为documemt由于全局变量不安全并且多了就容易泄露内存,所以用事件源参数来存储和接收被拖拽元素
被拖拽元素的事件:
ondragstart		当拖拽开始时触发
ondrag			当持续拖拽时触发
ondragleave		当鼠标离开被拖拽元素原来区域时触发
ondragend		当鼠标松开被拖拽目标时触发
目标元素的事件:
ondragenter		当鼠标拖拽进入目标元素区域时触发
ondragover		当鼠标拖拽停留在目标元素区域内时触发(结束：阻止浏览器默认行为:e.preventDefault())
ondrop			当鼠标拖拽在目标区域内松开鼠标时触发
ondragleave		当鼠标拖拽离开目标区域时触发
```

```
任意元素拖拽：只需要触发三个事件即可  ondragstart+ondragover+ondrop
```



### 9-本地缓存

```js
//sessionStorage : 数据缓存
//注意:5M 和 20M 的大小根据不同的浏览器也是不同的,这个数据是 chrome 浏览器的大小
    1、存储大小：5M
    2、生命周期
        a.同一个浏览器不同的窗口数据不能共享
        b.不同浏览器数据不能共享
        c.关闭浏览器数据不存在(关闭当前页面数据也是不存在)
        d.数据是存储在当前页面的
        e.存储的类型为字符串
设置数据: window.sessionStorage.setItem(key,value(字符串))
获取数据:window.sessionStorage.getItem(key)
删除数据:window.sessionStorage.removeItem(key)
清空数据:window.sessionStorage.clear()
```

```
//localStorage : 数据缓存
    1、存储大小：20M
    2、生命周期
        1、关闭窗口数据还存在，不同窗口数据可以共享
        2、数据是存储在硬盘上，如果想删除必须人为删除
设置数据: window.localStorage.setItem(key,value(字符串))
获取数据:window.localStorage.getItem(key)
删除数据:window.localStorage.removeItem(key)
清空数据:window.localStorage.clear()
```

```
JSON.stringify(arr2) --> 将数组转换成字符串  原理就是在数组身上打上一个引号
JSON.parse(arr3) --> 将字符串转换成数组对象  
```

### 10-自定义音频/视频播放

```html
h5c3中新增了audio和video标签
音频: <audio src="" controls autoplay loop></audio>
视频: <video src="" poster="" controls autoplay loop height="600"></video>
muted:浏览器不支持自动播放,就加一个muted属性试试
loop:循环播放
poster:指定视频还没有完全下载完毕，或者用户没有点击播放前显示的封面。 默认显示当前视频文件的第一副图像
width:视频的宽度(宽高只需要设置其中一个,另一个等比缩放)
height:视频的高度(宽高只需要设置其中一个,另一个等比缩放)

<video  controls autoplay>
    <!--视频源，可以有多个源-->
    <source src="../mp3/flv.flv" type="video/flv">
    <source src="../mp3/mp4.mp4" type="video/mp4">
</video>
source:因为不同的浏览器所支持的视频格式不一样，为了保证用户能够看到视频，我们可以提供多个视频文件让浏览器自动选择

audio||video  提供属性+方法+事件都是原生的,只能使用dom操作:
	video.requestFullscreen(); (能力测试) 全屏功能
	video.oncanplay = function(){}		加载至能够播放时触发
	video.duration						获取视频总时长(秒)
	video.ontimeupdate = function(){}	播放时间改变时触发
	video.currentTime					获取当前播放时间(秒)
	video.onended = function(){}		播放完成时触发
	video.pause()	播放暂停
	video.play()	继续播放
	
步骤分析：
    1、点击播放按钮
    2、全屏(能力测试)
    3、oncanplay  视频可以播放就执行 
        a.video.style.display=block
        b、获取视频的总时长 : video.duration
        c、通过获取的总时长计算出：时分秒
        d、将时分秒渲染在页面上

    4、ontimeupdate  视频在播放或者视频播放时间在改变
        a.获取当前视频的播放时间：video.currentTime
        b.通过获取的视频的播放时间计算出：时分秒
        c.将时分秒渲染在页面上
        d.计算播放进度的宽度=video.currentTime/video.duration *100+ "%"

    5、跳播
        1、获取当前点击处的偏移值    需要使用事件源参数
        2、计算百分比=当前点击处的偏移值/当前盒子(.bar)的总宽度
        3、计算当前视屏播放时间(video.currentTime)=百分比*视屏总时长

    6、onended  视屏一播放完毕就触发
        1、播放变成暂停
        2、设置当前播放时间为 0   video.currentTime=0;
```

### 11-文件读取(fileReader )

```js
图片的即时预览：new FileReader()
1、input表单绑定oncahnge事件，触发获取文件读取对象   
	var  reader=new  FileReader()
2、获取选中的文件    input的files   数组类型     
    var file=document.querySelector("#myFile").files;
3、调用对象的方法  读取文件      
	reader.readAsDataURL(file[0])
4、什么时候读取完毕： 
	reader.onload=function(){
5、读取后会把图片存放在对象属性中   
	reader.result     ======转码base64
6、显示图片   
	img.src=reader.result
```

### 12-c3选择器

#### 1.属性选择器:

```css
属性选择器:属性是相对于标签而言的.所谓属性选择器是根据指定的属性的名称的值来查找元素
	1.E[attr]:查找指定的拥有attr属性的E标签.比如查找拥有style属性的li标签
    li[style]{}
	2.E[attr=value] : 查找拥有attr属性并且属性值为value的E标签.比如:查找拥有class属性并且属性值为blue的li标签
    li[class=blue] {}
	3. E[attr*=value]:查找拥有attr属性,并且属性值包含value(任何位置)的E标签.比如查找拥有class属性,并且属性值中包含red的li标签
    li[class*=red] {}
	4. E[attr^=value] :查找拥有attr属性,并且属性值以value开头的E标签.比如查找拥有class属性,并且属性值以red开头的li标签
    li[class^=red] {}
    5. E[attr$=value] :查找拥有attr属性,并且属性值以value结尾的E标签.比如查找拥有class属性,并且属性值以red结尾的li标签 
    li[class$=red] {}
```

#### 2.兄弟伪类选择器:

```
兄弟伪类:
    + : 获取当前元素相邻的满足条件的兄弟元素 
    ~ : 获取当前元素所有满足条件的兄弟元素
获取first这个标签的相邻的为li标签的兄弟元素,结果是没有找到
    .first + li {}
获取first这个标签的所有为li 标签的兄弟元素 
    .first ~ li {}
```

#### 3.相对于父元素的伪类选择器:

```css
相对于父元素的伪类结构:(分类型和不分类型两大种)
E:first-child : 查找E元素的父元素中的第一个不限制类型的子元素,是E标签就找到了,不是就找不到
E:last-child :  查找E元素的父元素中的最后一个不限制类型的子元素,是E标签就找到了
E:first-of-type : 查找E元素的父元素中的所有为E标签的子元素,再找其中第一个E (过渡掉其它类型的元素)
E:last-of-type : 查找E元素的父元素中最后一个为E元素类型的E元素，过渡掉其它类型的元素 
E:nth-child(从1开始的索引(5) || 关键字(even) || 表达式(-n+5): 查找E的父元素中所有子元素中指定索引位置的E元素,不限制类型
E:nth-of-type(从1开始的索引(5) || 关键字(even) || 表达式(-n+5) :查找E的父元素中所有子元素中指定索引位置和类型的E元素
E:empty : 查找E元素的父元素中所有为空的子元素,空格也没有
```

#### 4.为锚点目标元素添加样式

```html
<style>
	h2:target {
        font-size:30px;
	}
</style>
<a href="#title"></a>
<h2 id="title">标题</h2>
```

#### 5.伪元素选择器

```css
每个(E)元素都有一对隐形的子元素 
E::before   E::after
优点:不用在dom树中添加新标签,可以减少结构层级
注意:1.必须设置content : "";  否则不可见;
	2.默认是行级元素,要设置宽高必须先转化为块级元素,float,display,position;
	3.由于在dom树中不可见,所以不能用js操作;
通常使用position进行转化
另外伪元素还有(不常用):
E::first-letter		第一个字母或汉字
E::first-line		第一行,如果已经设置了first-letter,那么这个的设置对第一个字不起作用
E::selector			选中的文本,只能设置显示的样式,不能设置内容大小
```

### 13-颜色设置rgba

```css
例如: color:rgb(255,0,0);
rgb(red,green,blue) :里面的每个数都是0~255之间
秘诀:红橙黄绿青蓝紫,要偏向哪个色系,哪个颜色最少在128以上
rgba(red,green,blue,alpha)  alpha是设置透明度,默认1
rgba设置透明度只让盒子变透明,不影响它的子元素及内容
opacity 设置的透明度只能针对整个盒子设置,子盒子及内容会继承父盒子的透明度
```

### 14-阴影

```css
文本阴影:
text-shadow:offsetX offsetY blur color;
阴影可以加多层,用逗号分割
offsetX,offsetY 指阴影的偏移值
blur 指模糊程度,最小为0,值越大,越模糊
color 指阴影的颜色,可以写rgba,也可以写16进制的颜色,或者颜色的英文单词
例如:text-shadow:-5px 5px 2px red;
	text-shadow:-5px 5px 2px red,0px 0px 30px white;
```

```css
盒子阴影:
box-shadow : h v blur spread color inset;
阴影可以加多层,用逗号分割
h : 水平方向偏移值;
v : 垂直方向偏移值;
blur : 模糊值 --可选 默认0
spread : 放大值(阴影尺寸),扩展和收缩阴影的大小 --可选 默认0
color : 颜色 --可选 默认黑色
inset : 内阴影 --可选 默认是外阴影
box-shadow : 2px 2px 2px 10px rgba(255,0,0,0.2) inset;
```

### 15-盒模型

```css
box-sizing 设置盒子大小的计算方式
box-sizing:border-box;	设置的width,height,就是盒子的整个的大小,包括padding和border,之后设置padding和border时不会撑大盒子,只会让内容区域减小
box-sizing:content-box;	(默认值)设置的width,height,就是盒子内容的大小,不包括padding和border,之后设置padding和border时会撑大盒子
```

### 16-盒子圆角

```css
border-radius 设置盒子四个角的圆角
后面的值可以写1个,2个,3个,4个  是与角内切的圆的半径
border-top-left-radius	设置左上角的圆角
border-top-right-radius	设置右上角的圆角
border-bottom-right-radius	设置右下角的圆角
border-bottom-left-radius	设置左下角的圆角
```

### 17-背景属性(渐变)

```css
线性渐变:background:linear-gradient(方向,开始颜色,过渡颜色1,... 结束颜色);
产生的是图像
方向:   不写的话,默认值是 to bottom (180deg)
		可以写方向或者角度值 
		to top 	终点     从下往上  0deg
		to right  终点	从左往右	90deg
		to bottom  终点	从上往下	180deg
		to left	 终点		从右往左	270deg
		top	  起点,有兼容性   从上往下  180deg
background: -webkit-linear-gradient(right,red 0%, red 50%,blue 50%,blue 100%);
```

```css
径向渐变: background:radial-gradient(形状 大小 坐标,开始颜色,结束颜色);
    1.形状(可选): 默认值是ellipse,自动适配形状; circle 正方形
    2.大小(可选): 默认是最远的角farthest-corner; closest-side:最近边; farthest-side:最远边; closest-corner:最近角; 
    3.坐标(可选): 默认在正中心 at center center;可以赋值坐标（参照元素的左上角）,也可以
    赋值关键字(left center right top bottom) 比如:at 10px 10px || at center center 
    4.开始颜色 : 颜色单词 || rgba || 16进制
    5.结束颜色 : 颜色单词 || rgba || 16进制
注意:颜色可以在开始和结束之间加入过渡颜色,每个颜色后面都可以加入像素或者百分数
```

```css
重复渐变:
重复线性渐变:background:repeating-linear-gradient(#fff,#fff 10%,black 10%,black 20%)
重复径向渐变:background:repeating-radial-gradient(#fff, #fff 10%,black 10%,black 20%)
```

### 18-背景图片的设置

```css
background-images
background-repeat
background-position
background-size
background-attachment
background-size
background-origin
background-clip
```

#### background-size:

```css
background-size: auto(原始图片大小) || number(数值) || percentage(百分比) || cover(放大铺满) || contain(缩小铺满)
a)auto：此值为默认值，保持背景图片的原始高度和宽度;
b)number：此值设置具体的值，可以改变背景图片的大小;
c)percentage：此值为百分值，可以是0%〜100%之间任何值;
d)cover：让图片铺满整个盒子,根据盒子和图片的大小,图片会进行缩放,最终图片有可能会不完全显示
background-repeat来实现时，我们就可以采用cover;将背景图片放大到适合容器的大小
e)contain：让图片全部显示在盒子里面,让图片进行缩放,盒子可能会有部分空白
f)当background-size取值为number和percentage时可以设置两个值，也可以设置一个值，当只取一个值时，第二个值相当于auto，但这里的auto并不会使背景图片的高度保持自己原始高度，而是会参照第一个参数值进行等比例缩放。
```

#### background-origin:

```
1.规定 background-position 属性相对于什么位置来定位。默认值是left top左上角

2.语法：background-origin: padding-box|border-box|content-box;
```

#### background-clip:

```
1. background-clip 属性规定背景的绘制区：虽然是设置裁切，但是控制的是显示。说白了，就是设置最终显示那些区域

2. 语法：background-clip: border-box|padding-box|content-box;
```

### 19-过渡与2d变换

#### 1.过渡transition

```css
transition:它只能操纵有具体值的样式,比如width,height,color,background-color,opacity...
像是display这种不能操纵
//单击
div:active {
    left:1000px;
    backgorund-color:red;
}
设置一个样式的过渡:
transition:属性名 动画时间 动画速度 延迟 步进;
动画速度和步进不能同时存在
设置多个样式的过渡:
transition:属性名1 动画时间 动画速度 延迟,属性名2 动画时间 动画速度 延迟 ,...;
```

#### 2.二维平面移动

```css
参照自身左上角移动
transform:translate(x,y);	水平和垂直方向移动
transform:translate(100px);		水平方向移动
transform:translateX(100px);		水平方向移动
transform:translateY(100px);		垂直方法移动

```

#### 3.二维缩放

```css
参照元素的几何中心: >1放大  <1 缩小  ;不影响其他元素
transform:scale(2); 水平和垂直方向都放大两倍
transform:scale(2,1); 水平方向放大两倍,垂直方向不变
transform:scaleX(2); 水平方向放大两倍
transform:scaleY(2); 垂直方向放大两倍
```

#### 4.二维旋转

```css
围绕Z轴旋转,只有一个参数,角度
transform:rotate(45deg);	顺时针旋转45度
旋转轴心的改变:transform-origin: center center;默认是几何中心 
1. X Y
2. left right top bottom center
transform-origin: left top;	左上角
transform: rotate(-45deg);
```

#### 5.二维斜切(扭曲)

```css
transform:skew(45deg);		/*水平方向斜切45度*/
transform:skew(45deg,-30deg);	/*水平方向斜切45度,y轴方向斜切30度*/
transform:skewX(45deg);	/*水平方向斜切45度,*/
transform:skewY(45deg); /*y轴方向斜切45度*/
/*如果角度为正,就往当前轴的负方向斜切,如果角度为负,就往当前轴的正方向斜切*/
```

#### 6.同时进行多个变化

```css
/* 同时让多个transform变化 */
/* 旋转一定要在后面写,因为旋转时,坐标系也会旋转,影响其他的变化 */
	transform: translate(500px,-200px) rotate(-45deg);
/* 清除变化: transform : none; */
```

#### 7.让一个盒子居中显示

```
position:absolute;
left:0;
top:0;
transform:translate(-50%,-50%);

```



### 20-3D变化

#### 1.三维移动

```css
/* 三维平移:transform: translate3d(x,y,z) 
分开写:translateX(100px)  translateY(100px)  translateZ(100px)*/
div:first-of-type:active{
    /* transform: translate3d(200px,0,0); */
    transform: translate3d(0,200px,0);
    /* 仅仅沿Z轴移动,我们在屏幕上看不出效果 */
    /* transform: translate3d(0,0,200px);   */
}
```

#### 2.三维缩放

```css
/* 三维缩放: transform: scale3d(2,2,2); 三个轴的方向全都放大2倍
分开写: scaleX()  scaleY() scaleZ()*/
div:nth-of-type(2):active {
    /* z轴方向的缩放我们看不到 */
    transform: scale3d(2,1,1);
}
```

#### 3.三维旋转

```css
/*添加三维旋转*/
/* 三维旋转: rotate3d(x,y,z,angle)：指定需要进行旋转的坐标轴 , 分开写: rotateX(angle)  rotateY(angle)  rotateZ(angle)*/
div:nth-of-type(3):active{
    /*rotate3d(x,y,z,angle):
    x:代表x轴方向上的一个向量值
    y:代表y轴方向上的一个向量值
    z:代表z轴方向上的一个向量值*/
    transform: rotate3d(1,1,1,330deg);
}
```

#### 4.景深透视

```css
/* 设置景深透视
perspective(length),为元素设置三维透视的距离,仅作用于元素的后代 */
/* perspective-origin:属性规定了镜头在平面上的位置。默认是放在元素的中心 */
perspective-origin: 100px 100px ;
/* transform-style：使被转换的子元素保留其 3D 转换(需要设置在父元素中) */
transform-style: preserve-3d;
transform: rotate3d(3,1,1,60deg);
```

### 21-动画

过渡只能从一个状态到另一个状态,只有开始和结束两个关键帧

动画可以添加多个关键帧@keyframes

```css
1.创建动画 @keyframes moveTest{
	/*百分比是指整个动画耗时的百分比*/
    0%(或者from){
        transform:translate(0,0);
    }
    50%{
        transform:translate(100px,0);
    }
    100% (或者to){
        transform:translate(500px,500px);
    }
}
2.指定动画名称:animation-name: moveTest;
3.指定动画耗时:animation-duration:2s;
4.指定动画播放次数:animation-iteration-count : infinite;无限次
5.设置交替动画:animation-direction:alternate;
6.设置动画延迟:animation-delay:2s;
7.设置动画结束时的状态:默认结束时回到原始状态
	forwards:结束时保持动画结束时状态,在有延迟的前提下,如果有开始状态,不会一开始就执行,没有延迟一开始就执行初始状态
	backwards:不会保持动画结束时状态,在有延迟的前提下,如果有开始状态,一开始就执行,没有延迟一开始就执行初始状态
	both:结束时保持动画结束时状态,,在有延迟的前提下,如果有开始状态,一开始就执行,没有延迟一开始就执行初始状态
animation-fill-mode:forwards;	保持动画结束时状态
8.动画的时间函数:animation-timing-function:linear;
9.设置动画播放状态:animation-play-state:paused;	暂停  running 播放

简写:
animation:动画名称 动画时间 动画延迟时间 动画速度 播放次数 forwards/backwards;
@keyframes 动画名称{
    from{}
    to{}
}
```

### 22-常见的几种布局方式

#### 多列布局

```
/*设置多列布局,在父元素中设置*/
/*1.设置列数*/
column-count: 3;
/*2.添加列间隙样式,与边框样式的添加一样*/
column-rule: dashed 3px red;
/*3。设置列间隙大小*/
column-gap: 50px;
/*4.设置列宽
原则：取大优先
1.如果人为设置宽度更大，则取更大的值，但是会填充整个屏幕，意味最终的宽度可能也会大于设置的宽度--填充满整个屏幕
2.如果人为设置宽度更小，使用默认计算的宽度*/
column-width: 200px;

```



#### 固定宽度布局(position+display+float)

#### 弹性布局(伸缩盒子布局)

```css
1.在父元素上开启弹性布局:
	display:flex;

2.并且给子元素设置在主轴方向上的排列方式(左中右):
	justify-content:flex-start;	(flex-start靠左对齐 || flex-end靠右对齐 || center居中对齐 || space-between 左右两边盒子跟父盒子对齐,中间盒子间距自动计算 || space-around所有子元素都有左右间距)	
/*如果子元素的宽度和比父元素大,子盒子会自动收缩,仍然在一行显示
flex-wrap:wrap;	让子盒子自动换行 (wrap || nowrap || wrap-reverse)*/

3.设置主轴方向 :flex-direction:row;	(默认row: 横向从左到右排列（左对齐） || row-reverse 横向从右到左排列（右对齐）|| column 纵向从上往下排列（顶对齐） || column-reverse 纵向从下往上排列（底对齐）) 

4.flex-flow:默认值为row nowrap ; 设置子元素是否自动换行 和 设置主轴方向,属性值不分前后
	flex-flow:row wrap;

5.设置子元素在侧轴方向上的对齐方式(上中下)
align-items:center; (flex-start  || flex-end || center || stretch 拉伸 || baseline 基线对齐)
```

```css
/*在子元素身上设置:父盒子有剩余空间时,扩展子元素的宽度(将剩余空间按比例分摊给各个子元素,比例=这个子元素的flex-grow / 所有子元素的flex-grow的和)*/
flex-grow:1;	默认值为0
/*在子元素身上设置:父盒子空间不够时,收缩子元素的宽度(将不够的空间按比例分摊给各个子元素,比例=这个子元素的flex-shrink / 所有子元素的flex-shrink的和)*/
flex-shrink:2;	默认值为1

1.flex:number; 是flex-grow  flex-shrink  flex-basis的简写
一般用于给子元素添加flex属性,不设置宽度,第一个1,第二个4,


2./*设置单个子元素在侧轴方向上的对齐方式*/
align-self:center; (flex-start  || flex-end || center || stretch 拉伸 || baseline 基线对齐)
```

# 9.移动端开发

## 1.关于像素

```
屏幕尺寸: 屏幕对角线的长度(英寸)
分辨率: 分辨率则一般用像素来度量 px，表示屏幕水平和垂直方向的像素数
英寸是一个绝对长度单位，而像素是一个相对长度单位（像素并没有固定的长度）
PPI（Pixels Per Inch）:像素密度 --> 屏幕每英寸的像素数量
PPI值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。
屏幕尺寸固定时，当PPI 越大，像素的实际大小就会越小，当PPI越小，像素实际大小就越大
```

![1544594563135](C:\Users\ADMINI~1.USE\AppData\Local\Temp\1544594563135.png)

## 2-二倍图

1、什么是二倍图
原始图片尺寸的二倍
2、为什么要有二倍图
图片在正常分辨率下能正常的显示，到高分辨率下就显示的比较模糊，为了解决这个问题，我们在高分辨率下就需要使用二倍图或者三倍图
3、二倍图的作用
在不同分辨率情况下也能正常的显示高清的效果

## 3-端的视口

### 1.PC端的视口

1、什么叫视口
	承载页面布局的那块区域就是我们的视口,即viewport
	viewport：在PC设备上viewport的大小取决于浏览器窗口的大小
2、如何获取视口的大小

```js
<script>
    // 获取到html元素的大小
    var clientWidth = document.documentElement.clientWidth;
    var clientHeight = document.documentElement.clientHeight;
    console.log('PC设备Viewport的宽度为：' + clientWidth);
    console.log('PC设备Viewport的高度为：' + clientHeight);
</script>
```

3、在PC设备上如何让页面正常显示
	元素设定较大固定宽度

### 2.移动端的视口

1、布局视口和屏幕视口的概念
	layout viewport(布局视口) :承载页面布局的那块区域
	ideal viewport(屏幕视口) : 即设备窗口的尺寸
2、页面能正常的显示的原理
	原理：页面能正常的显示是通过了一个缩放
	将layout viewport（布局视口）进行了缩放，使其恰好完整显示在ideal viewport（屏幕）里，其缩放比例为ideal viewport / layout viewport

## 4.屏幕适配

```
<meta name="viewport" content="width=device-width, initial-scale=1.0，user-scalable=no">

1.通过meta标签来设置viewport的属性
<meta name="viewport" content="width=device-width">

2.viewport的其他属性
	a) name=”viewport” 说明meta是来设置viewport属性的
	b) width : viewport的宽度
	c) device-width:设备的宽度

3.移动端viewport是设置页面的初始缩放值，为一个数字，可以带小数。

4. user-scalable:是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许

```

### 使用rem单位进行长度的设置

```
window.onload = function(){
   var width,fontSize;
   $(window).on("resize",function(){
       //获取设备宽度
       width = $("html").width();
       //将屏幕宽度等分为等份,结果就是html的font-size
       fontSize = width/640*100;
       $("html").css("font-size",fontSize);
   }).trigger("resize");
}
```



## 5.最大宽度和最小宽度

```
最大宽度和最小宽度的样式设置   max-width:640px;  min-width:320px;

为了解决页面在一些常见的设备上都能正常的显示:
max-width:640px 是根据ui最大设计尺寸为640px来的，例如我们的轮播图图片尺寸此时是640，如果超过640就会对图片拉伸图片就会失真，所以我们需要设置一个最大宽度

min-width:320px 因为我们设置的宽度都是100%，当它无限小的时候最小，页面布局就会掉下来或者挤在一起这样就会影响我们页面的布局，所以我们加一个最小宽度，基本上市面上最小屏的智能机是iphone4s它的尺寸为320px
```

## 6.左右两边盒子固定中间自适应的设置

要求:左边盒子宽200px,高100px,右边盒子宽100px,高100px,中间盒子随屏幕缩放而变化

### 1.用flex进行弹性盒子设置

```
给父盒子设置  display: flex; 让三个盒子自动在一行显示
中间盒子设置  flex:1;  占据父盒子的剩余全部空间
```

### 2.用margin进行设置

```
父盒子设置  position: relative;
左边和右边盒子使用定位放在父盒子的左边和右边  position: absolute;
中间盒子不要设置宽度,设置  margin-left: 200px;  margin-right: 100px;
```

### 3.用padding进行设置

```
父盒子设置  position: relative;
左边和右边盒子使用定位放在父盒子的左边和右边  position: absolute;
中间盒子设置  width:100%; margin-left: 200px;  margin-right: 100px;
```

## 7.京东首页

```
页面滚动时,获取滚动出去的距离:
window.onscroll=function(){
    var offsetTop=document.body.scrollTop;
    /*3.计算比例值，获取透明度，设置背景颜色的样式*/
    var opacity=0;
    /*判断，如果当banner还没有完全 滚出屏幕，那么才有必要计算透明度和设置透明度*/
    if(offsetTop < bannerHeight){
        opacity=offsetTop/bannerHeight;
        /*设置样式*/
search.style.backgroundColor="rgba(233,35,34,"+opacity+")";
    }
}
```

```js
//手动轮播图思路:
//1.将图片的第一张和最后一张复制并添加到ul的开头和结尾
/*1.1.获取轮播图结构*/
var banner=document.querySelector(".jd_banner");
/*1.2.获取图片容器*/
var imgBox=banner.querySelector("ul:first-of-type");
/*1.3.获取原始的第一张图片*/
var first=imgBox.querySelector("li:first-of-type");
/*1.4.获取原始的最后一张图片*/
var last=imgBox.querySelector("li:last-of-type");
/*1.5.在首尾插入两张图片   cloneNode:复制一个dom元素*/
imgBox.appendChild(first.cloneNode(true));
/*insertBefore(需要插入的dom元素，位置)*/
imgBox.insertBefore(last.cloneNode(true),imgBox.firstChild);
```

```js
/*步骤：
2、通过js设置整个轮播图盒子的宽度以及定位*/

/*2.1获取所有li元素*/
var lis=imgBox.querySelectorAll("li");
/*2.2 获取li元素的数量*/
var count=lis.length;
/*2.3.获取banner的宽度*/
var bannerWidth=banner.offsetWidth;
/*2.4 设置图片盒子的宽度*/
imgBox.style.width=count*bannerWidth+"px";
/*2.5 设置每一个li(图片)元素的宽度*/
for(var i=0;i<lis.length;i++){
    lis[i].style.width=bannerWidth+"px";
};

/*3.设置默认的偏移*/
imgBox.style.left=-bannerWidth+"px";

```

```js
/*4.当屏幕变化的时候，重新计算宽度*/
window.onresize=function(){
    /*4.1.获取banner的宽度,覆盖全局的宽度值*/
    bannerWidth=banner.offsetWidth;
    /*4.2 设置图片盒子的宽度*/
    imgBox.style.width=count*bannerWidth+"px";
    /*4.3设置每一个li(图片)元素的宽度*/
    for(var i=0;i<lis.length;i++){
        lis[i].style.width=bannerWidth+"px";
    };
    /*4.4重新设置定位值*/
    imgBox.style.left=-index*bannerWidth+"px";
};
```

```js
/*2、自动轮播+无缝轮播的原理
a)自动轮播原理
i.首先申明全局的index=1(因位偏移首先显示的index=1的那张图片)
ii.定时器1s执行一次，让索引自增一次，
iii.设置图片盒子的位偏移 =-当前的索引*图片盒子的宽度
iv.添加过渡让其有动画效果*/
imgBox.style.transition="left 0.5s ease-in-out";
imgBox.style.left=(-index*bannerWidth)+"px";

/*b)无缝轮播的原理
i.	添加定时延长
ii.	判断索引值为9(也就是最后一张),直接让其索引index=1
iii.设置图片盒子的位偏移 =-当前的索引*图片盒子的宽度
Iv.	关闭过渡*/
setTimeout(function(){
    if(index==count-1){
        console.log(index);
        index=1;
        imgBox.style.transition="none";
        imgBox.style.left=(-index*bannerWidth)+"px";
    }
},500);
```

## 8.移动端touch事件(前提是元素有具体宽高)

```
1.touch事件有几种及什么情况下触发？

	a)touchsatrt  		当手指触摸屏幕的时候触发
	b)touchmove  	当手指在屏幕上滑动的时候连续触发
	c)touchend   	当手指离开的时候触
```

```
2.touch事件触发的顺序
	touchsatrt  >  touchmove  >  touchend   
```

```js
3.它的事件源参数e中有:
touches :是指当前屏幕上所有手指对象 
targetTouches : 当前元素上的手指对象(建议使用这个)
changedTouches : 当前屏幕上变化的的手指对象--从无到有 , 从有到无
// screenX / screenY : 手指的触摸点相对于屏幕左上角的坐标距离
// clientX / clientY : 手指的触摸点相对于当前视口--移动端屏幕的左上角的距离
// pageX / pageY : 手指的触摸点相对于当前页面的内容的左上角的坐标距离(包含有滚动条时滚动出去的距离)
//没有滚动条时,pageX 和clientX的值一样
//
//targetTouches和touches在测试中没有区别
startX = e.targetTouches[0].clientX;
startY = e.targetTouches[0].clientY;

```

## 9.移动端元素拖拽

```js
var startX,startY,moveX,moveY;
var distanceX = 0, distanceY=0, currentX=0, currentY=0;
//1.开始触摸时获取手指相对于移动端屏幕左上角的坐标
div.addEventListener("touchstart",function(e){
    startX= e.targetTouches[0].clientX;
    startY= e.targetTouches[0].clientY;
    console.log(startX+":"+startY);
});
/*2.触摸滑动时,持续获取手指相对于移动端屏幕左上角的坐标,并计算与初始值的差值*/
div.addEventListener("touchmove",function(e){
    /*记录手指滑动过程中的坐标值*/
    moveX= e.targetTouches[0].clientX;
    moveY= e.targetTouches[0].clientY;
    console.log(moveX+":"+moveY);
    /*计算与上一次坐标的差异*/
    distanceX=moveX-startX;
    distanceY=moveY-startY;
    console.log(distanceX+":"+distanceY);
    /*设置偏移*/
 //3.给被触摸的元素设置移动,移动距离就是计算出来的差值  div.style.transform="translate("+(distanceX+currentX)+"px,"+(distanceY+currentY)+"px)";
});
//4.触摸结束时,获取元素相对于最开始移动的距离,并记录下来,并将distence清零
div.addEventListener("touchend",function(e){
    currentX += distenceX;
    currentY += distenceY;
    distenceX = 0;
    distenceY = 0;
}
```

```
1、滑动时图片产生延迟的原因是什么
开启定时器的时候添加了过渡效果，在touchmove的时候没有清除这个过渡也就导致那个延迟了，解决的办法是在touchmove事件中清除过渡
```

```
2、过渡结束事件的兼容性写法
imgBox.addEventListener("webkitTransitionEnd",function(){}
```

```
3.快速滑动会出现空白的问题？
当前滑动距离超过100，图片完成过渡效果需0.5s，这时用户又接着多次滑动就导致此时的过渡没有触发，从而就导致了空白问题(用节流阀解决)
节流阀的原理：
a.初始一个全局变量 设置其值为true,
b.在touchmove事件判断阀门是否开启
c.在touchend事件关闭阀门
d.在transitionEnd事件在开启阀门
```



## 10.给任意元素实现拖拽功能

通过对document添加事件可以捕获当前响应事件对象e.target,然后再获取当前对象的坐标来实现拖动偏移定位

## 11.**zepto** 

```
1.zepto的特点
    a)轻量级体量小
    b)可以提高我们的开发效率
    c)针对的都是一些高级浏览器(即移动端浏览器)
    d)zepto是集成模块的，把所有的功能都集成在模块中
2.zepto的定制
	步骤分析：
	zeptojs为我们封装了常用的触屏事件，需要touch模块支持，默认没有构建此模，我们可以自定义构建。
    2.1、安装Nodejs环境
    2.2、下载zepto.js
    2.3、解压缩
    2.4、cmd命令行进入解压缩后的目录  	
		菜单node>node.js command
		cd+文件夹路径C:\Users\silence\Desktop\伍湖-移动web备课\zepto-master\zepto-master
    2.5、执行npm install 命令
    2.6、编辑make文件，添加自定义模块并保存，如下图
    2.7、然后执行命令 npm run-script dist
    2.8、查看目录dist即构建好的zepto.js
```

## 12.实现全屏页面的设置

```
全屏页面:内容的宽和高不要超出父容器(或者说内容的宽和高不要超出视口或屏幕)
html,body{
	width: 100%;
	height: 100%;
}
```

## 13.精灵图设置背景图会用到的属性

```
a)background-clip:content-box    默认是border-box 裁剪,用来显示内容,将盒子content以外的精灵图都裁掉,只显示盒子的content区域里的精灵图
b)background-origin::content-box   用来设置background-position的圆点是盒子comtent区域的左上角,默认是border-box
```

## 14.移动端tap事件--单击

### 1.为什么不用click事件?

```
1.为什么不用click事件?
	在移动端进行click事件时,设备要判断是单击还是双击,会延迟300ms,如果300ms以内右单击了一次,那么就确定是双击事件,如果300ms以内都没有第二次点击,就确定这是单击事件.
	有了这300ms的延迟,在移动端会先触发其他事件--touch事件
```

### 2.通过touch事件封装一个单击事件---tap

```
思路:
//1.手指触摸时,判断只有一根手指:e.targetTouches.length
	记录手指开始触摸的时间   startTime=Date.now();
	记录当前手指的坐标  startX= e.targetTouches[0].clientX;
            		startY= e.targetTouches[0].clientY;
   2.手指松开时,判断是否只有一根手指进行操作 e.changedTouches.length
   判断时间差是否在150ms以内  Date.now()-startTime
   判断松开手指时的坐标与触摸开始时的坐标的距离差异--抖动距离是否小于6px
```

### 3.使用zepto中的tap事件

```
$(".tap").on("tap",function(){
        $(this).hide();
});
```

### 4.用fastclick单击事件

```js
<!--引入fastclick文件-->
<script src="./js/fastclick.js"></script>
<script>
	if ('addEventListener' in document) {
        document.addEventListener('DOMContentLoaded', function() {
            /*参数可以是任意的dom元素，如果写document.body，说明会将document.body下面的所的元素都绑定fastclick*/
            FastClick.attach(document.body);
        }, false);
    }

	tap.addEventListener("click",function(){
        tap.style.visibility="hidden";
    })
</script>
```

### 5.点透

```
通过定位有重叠的两个元素,点击重叠部分,想触发上面的元素的事件,但是下面元素的事件也被触发了,类似于父子元素的冒泡事件,但这里不是父子关系

web的click事件有延迟,没有点透问题
自己封装的tap事件是通过touch事件实现的,有点透问题
zepto中提供的tap方法没有完全解决点透问题,时灵时不灵
fastclick中解决了点透又没有延迟,是最好的方法
```

## 15.iscroll插件的使用

一个可以实现客户端原生滚动效果的类库

```js
//使用步骤:
//1.页面结构上要有以下结构: 对标签没有要求,要求一样的id
<div id="wrapper">
    <ul>
        <li>...</li>
        <li>...</li>
        ...
    </ul>
</div>
//2.引入js文件
<script src="./js/iscroll.js"></script>
//3.引入js代码
<script type="text/javascript">
    var myScroll = new IScroll('.ct_hotCategory',{
        mouseWheel: true,    鼠标滚动也可以实现滑动
        scrollbars: true     添加滚动条
    });
</script>

//4.设置滚动条位置: 
//只需要给id为wrapper的标签元素添加一个position:relative属性就可以实现
```

## 16.swiper的插件的使用

```js
//1.页面结构上要有以下结构: 对标签没有要求,要求一样的id
<div id="swiper-container">
    <ul>
        <li>...</li>
        <li>...</li>
        ...
    </ul>
</div>
//2.引入js文件
<script src="./js/swiper.js"></script>
//3.引入js代码
<script type="text/javascript">
    var mySwiper = new Swiper('.swiper-container',{
    effect : 'cube',
    cube: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 100,
        shadowScale: 0.6
    }
})
</script>
```

## 17.响应式布局

### 1.常见的布局方法

```
1、网页布局有几种方式？
a、固定宽度布局：为网页设置一个固定的宽度，通常以px做为长度单位，常见于PC端网页。
b、流式布局：为网页设置一个相对的宽度，通常以百分比做为长度单位。
c、栅格化布局：将网页宽度人为的划分成均等的长度，然后排版布局时则以这些均等的长度做为度量单位，通常利用百分比做为长度单位来划分成均等的长度。
d、响应式布局：通过检测设备信息，决定网页布局方式，即用户如果采用不同的设备访问同一个网页，有可能会看到不一样的内容，一般情况下是检测设备屏幕的宽度来实现。
注：以上几种布局方式并不是独立存在的，实际开发过程中往往是相互结合使用的。
```

### 2.什么是响应式布局?

屏幕尺寸不一样展示给用户的网页内容也不一样

### 3.响应式布局的原理

利用媒体查询可以检测到屏幕的尺寸（主要检测宽度），并设置不同的CSS样式，就可以实现响应式的布局。

### 4.响应式布局的优缺点

a) 一个页面可适配不同的终端    b) 产生代码体积过大各种终端的资源都会存在加载

### 5.媒体查询

```
超小屏幕  xs	（移动设备）	 	 w<768px 
小屏设备  sm    768px-992px 	 768 <= w <992
中等屏幕  md    992px-1200px     992 =< w <1200
宽屏设备  lg    1200px以上       w>=1200
```

语法: (**注意：空格不能省略，否则无法生效**)

```css
@media screen and (max-width: 768px){
    body{
        background-color: green;
    }
}
@media screen and (min-width: 768px) and (max-width: 992px){
    body{
        background-color: blue;
    }
}
@media screen and (min-width: 992px) and (max-width: 1200px){
    body{
        background-color: red;
    }
}
@media screen and (min-width: 1200px){
    body{
        background-color: purple;
    }
}
```

书写顺序说明:

```
1.如果是判断最小值 (min-width)，那么就应该从小到大写--bootstrap就是判断最小值，从小到大写
	1.1.向上兼容：如果设置了宽度更小时的样式，默认这些样式也会传递到宽度更大的条件范围内   (宽度向上找，直到找到宽度最大的那个)
	1.2.向下覆盖：宽度更大的样式会将前面宽度更小的样式覆盖*

2.如果是判断最大值 (max-width)，那么就应该从大到小写
```

```
1、min-width:在pc端和移动端能正常的响应，效果一致  。它是指当前可视区域的宽度
2、min-device-width:在移动端和期望值一样  device：设备。它是指当前设备的宽度。当拖动来改变浏览器大小的时候，当前终端设备的宽度并不会变化，意味着媒体查询条件不会响应
```

外链式媒体查询:

当屏幕尺寸宽度在992-1200就调用b.css ,不在这个范围就调用a.css

```
<link rel="stylesheet" href="a.css">
<link rel="stylesheet" media="screen and (min-width:992px) and (max-width:1200px)" href="b.css">
```

not的使用:
屏幕的尺寸不在768-992，body就显示背景颜色blue
屏幕在这个尺寸范围就显示红色

```
<style>
    body{background-color: red;}
    @media not screen and (min-width: 768px) and (max-width: 992px){
        body{
            background-color: blue;
        }
    }
</style>
```

## 18.bootstrap

简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。

```
引入bootstrap的css文件
<link rel="stylesheet" href="bootstrap-3.3.7-dist/css/bootstrap.min.css">

解决ie9以下不支持h5c3的问题
<!--[if lt IE 9]>
<script src="./lib/html5shiv/html5shiv.min.js"></script>
<script src="./lib/respond/respond.js"></script>
<![endif]-->

引入jquery文件
引入bootstrap的js文件

找到需要的模板复制html代码,进行修改
修改css完成需要的结构样式
复制js代码
```

# 10.Git

Git是一款源代码管理工具(版本控制工具)

```
如果没有.git文件就:  选项-查看-显示隐藏文件
```

```
git仓库命令大全  (根目录 --> 工作区)
1.初始化仓库:
	git init
2.配置用户名和邮箱:(每个人都可以往同一个目录下存放代码,为了区分当前的使用用户是谁)--只需要做一次
	命令:
	1. 在.git目录的同级目录下创建要备份的文件,
	2. 在项目目录.git上 右键打开git-bash
	3. 配置用户名: git config --global user.name "小明"
	4. 配置邮箱: git config--global user.email "xiaoming@qq.com"   这里的邮箱不一定要真的,但格式要正确
```

```
3.添加文件到本地仓库的门口:(暂存区)
命令:
	git add xx.md  ||  git add .  ||  git add *  || 或者直接在要上传的目录上打开git bash  -- git add *

4.将文件添加到仓库中:(仓库区)
	git commit -m '写上注释,越详细越好'
	
5.查看当前文件状态
	git status  查看文件在哪个区有提示让你怎样做
	如果文件全部提交到仓库了,会提示nothing to commit 表示工作区和仓库区同步了
	
6.查看日志
	git log  列出全部的提交日志(提交者  提交时间)
	
7.列出简洁版的日志
	git log --oneline
	
8. 展示最近的三条日志
	git log -3
	
9. 查看所有分支详细日志
	git reflog

```





```
10. 版本回退
	git reset --hard head~0   最后提交的一个版本
	git reset --hard head~1  回退到上一个版本		git reset --hard head~2  回退到上上一个版本
	git reset --hard head^  回退到上一次提交
	git reset --hard 版本信息号	直接回退到某个确定的版本(cf47e91)
```



```
11. 创建分支  --dev是分支名
	git branch dev
12. 查看当前所在分支
	git branch
13.切换分支
	git checkout dev
14.删除分支(要先切换到其他分支,借刀杀人)
	git branch -d dev
	
15.合并分支(先切换到要合并的分支,通常是合并到master),产生的冲突只能人为解决
	git merge master
	
	注意:文件只要更改就要提交
	在aa分支上进行命令git merge bb
	是将aa和bb合并,但只有aa分支改变了,bb分支不会改变
```



```
在实际工作中,创建分支是在码云上直接创建,再直接在黑窗口git pull
再切换分支, git checkout dev
再在这个分支上上传文件 git add dev1.html
git commit -m '这是dev分支的代码'
git push
上传完毕之后,再切换到主分支,将分支合并
git checkout master
git merge origin/dev
git push


注意:在创建分支时,码云上有起点,起点中的文件都会复制到新建的分支中,要新分支上没有其他分支上的文件,就先全都把分支建好,再合并分支
```



```
这些方法可以在vscode中文件-在终端中打开  中输入命令
或者ctrl+`  打开终端
```

```. 16.
16. 创建项目 
	git clone 地址 
	git add .
	git commit -m ''
	git pull	将代码从云端拉下来,更新到最新
	git push	上传之前先拉一下
```

## 用SVN上传代码

​	码云-点击要做的项目--管理--勾选使用SVN管理代码

--重新打开项目 -- 克隆SVN地址

复制SVN的地址:

鼠标右键-选择SVN checkout  ===git clone 
鼠标右键-选择SVN commit 代码更新后直接就上传成功,不用经过本地仓库 ===git add  + git  commit + git push
鼠标右键-选择SVN update  别人上传过代码,自己的要更新



# 11.乐淘

## 1.项目配置环境

```
1.开启phpstudy
2.运行mysql
3.导入sql文件
4.在项目根目录下 shift+鼠标右键打开黑窗口,输入命令 : npm start
如果有报错:"cannot find module 'express' "
方法1: 在项目根目录输入 npm i express -S
方法2: 删除node_modules文件夹,再在项目根目录输入 npm i , 用来重新下载文件
5.在浏览器地址栏输入: localhost:3000/m 显示页面
```

## 2.mui框架

其他框架:sui

mui是只针对移动端使用的框架

在Hbuilder中新建-移动APP-Hello mui  创建模板

```
mui-pull-left		左浮动
mui-pull-right		右浮动
mui-content			栅格化容器
mui-row				栅格化 行
mui-col-xs-3		栅格化

```

在style中写上touch-action:none;  解决滑动报错



轮播图无缝轮播:用mui组件,自己改样式

```
看文档:加loop相关的类名,在首尾加上相应的图片结构

```
### 文本超出范围用省略号表示:


```
white-space:nowrap;  强制一行显示
overflow:hidden;		超出部分隐藏
text-overflow:ellipsis;	文本超出部分用省略号显示

/* 文本分两行显示,超出部分用省略号显示 */
    -webkit-line-clamp: 2;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-box-orient: vertical;
```

```
动态(模板引擎)生成的结构不能直接绑定事件,要用事件委托的方式给它绑定事件
```

模板引擎中给第一个一级分类添加类样式

```;
1.在js中找到第一个元素,用addClass添加类样式
2.在模板中用三元表达式进行判断,当i==0?"active":"";
```

### 将地址栏中从参数取出来

```
1.拿到地址栏中的字符串
var params = location.href;
2.将字符串中?后面的全部取出来
var paramStr = params.substr(params.indexOf("?")+1)
3.将参数字符串用&切割,返回数组
var paramArr = paramsStr.split("&")
4.遍历数组,将每一个键值对以"="又进行二次分割
for(var i=0; i<paramArr.length; i++){
    var current = paramArr[i].split("=");
    5.将每一次得到的数组中的第一项(键)进行判断,看是不是我们需要的参数,如果时,就返回对应的值
    if(current[0] == "keyword"){
        return current[1]
    }
}
return null;



简单一行搞定:(public.js中封装的方法)
var keyword = getParamsByUrl(location.href, 'keyword');

window提供的方法:
var keyword = new URLSearchParams(location.search).get("keyword");
```

### 上拉加载更多+分页  

使用mui组件实现

```
1.初次进入,组件会立刻触发
2.触发之后,执行callback函数,(在此函数中发送ajax请求,得到数据,渲染页面)
3.拿到数据后,结束组件
```

商品价格/销量进行排序的时候,点击其中一项排序,另一项排序不进行,发送ajax请求传参时,只传入其中一项

```
var a={aa : 1}
var b={bb : 2}
$.extend(a,b);  // {aa:1 , bb:2}

```

### 同步请求

在ajax请求的参数中加上: async:false 就是同步请求了

```
1.点击会员中心,进入user.html,进入user.js中时发送同步请求,(不在入口文件中写)此时html页面中解析暂停,js中获取用户信息,
2.如果未登录,就跳转到登录页面;
3.如果登录了,将用一个全局变量把返回结果保存起来;结束同步请求,继续解析
4.在html中全部渲染出来后,继续解析user.js的入口函数中的代码,运用模板引擎将同步请求中得到的数据渲染到html页面上


注意:如果不适用同步请求,就是同时进行获取用户信息和解析html文档,那么在得到数据后,进行模板引擎渲染时,html页面上结构还没完全加载,造成模板引擎渲染失败

ps:如果同步请求也放在入口函数中写,那么就只能在user.html全部加载完毕之后再进行,没有登录就跳转到登录页面,这里会造成闪烁一下,先显示user页面,立即跳转到login页面
```



## 3.乐淘项目中用到的语法

```
1. 获取表单name属性为username的元素:
	$('[name="username"]')
    
2. mui组件中的提示框:
	mui.toast("请输入用户名"); 
	
3. 获取表单中的值,用正则表达式进行验证
	var reg=/^[a-zA-Z][a-zA-Z0-9]{3,15}$/;    if(reg.test(username)==false){
       mui.toast("请输入英文字母和数字组成的4-10位字符");
       return;
    }
    
4. ajax请求中的data参数,可以获取form表单的serialize方法
	$("form").serialize(),
 
5. 消除字符串左右两边的空格
	$.trim(string)   ||   string.trim()
	
6. mui组件中默认阻止a标签的跳转,要重新设置a标签可以跳转:
	// 恢复A元素的跳转
	$('body').on('tap', 'a', function(){
		mui.openWindow({
			url: $(this).attr('href')
		});

	});
	
7. 拿到地址栏的参数(public.js中封装的方法)
	var keyword = getParamsByUrl(location.href, 'keyword');
	
8. 将两个对象合并
	var a={aa:1}, b={bb:2};
	$.extend(a,b)     {a:1,bb:2}
```

# 12.canvas

## 1.canvas初级

### 1.canvas简介

```
canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.

1.使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸.
2.默认 canvas 的宽高为 300 和 150.
3.不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性.
4.如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力.
5.canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题.
6.canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.
```

### 2.基本绘图方法

```
1.获得 canvas 对象.
2.调用 getContext 方法, 提供字符串参数 '2d'.
3.该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令.
4.使用 CanvasRenderingContext2D 对象提供的方法进行绘图.
5.基本绘图命令:
    设置开始绘图的位置: context.moveTo( x, y ).
    设置直线到的位置: context.lineTo( x, y ).
    描边绘制: context.stroke().
    填充绘制: context.fill().
    闭合路径: context.closePath().
```



```js
	// 获取canvas标签
	var canvas = document.createElement( 'canvas' );
    canvas.width = 500;
    canvas.height = 400;
    canvas.style.border = '1px dashed red';
    document.body.appendChild( canvas );
    // 获得 CanvasRenderingContext2D 对象
    var context = canvas.getContext( '2d' );
    // 设置 起点
    context.moveTo( 0, 0 );
    // 设置 终点
    context.lineTo( 500, 400 );
    // 设置 起点
    context.moveTo( 0, 400 );
    // 设置 终点
    context.lineTo( 500, 0 );
    // 描边显示效果
    context.stroke();
```



### 3.非零环绕原则

```
如果需要判断某一个区域是否需要填充颜色. 就从该区域中随机的选取一个点.
	从这个点拉一条直线出来, 一定要拉到图形的外面. 此时以该点为圆心.
	看穿过拉出的直线的线段. 如果是顺时针方向就记为 +1, 如果是 逆时针方向,
	就记为 -1. 最终看求和的结果. 如果是 0 就不填充. 如果是 非零 就填充.
```



### 4.闭合路径

```
closePath():
使用该方法可以将最后一个描点与最开始的描点自动连接起来.

lineWidth 设置绘制图形的线宽
closePath 与 直接使用 lineTo 闭合是有区别的
```

### 5.绘图状态

```
Canvas 绘图是含有状态的, 在需要改变颜色, 绘制方法, 改变一些属性... 就需要
改变绘图状态. 使用 beginPath() 方法. 开启一个新的路径.
```

### 6.绘制虚线

```
ctx.setLineDash( 数组 )
ctx.getLineDash() 获取设置的虚线数组
ctx.lineDashOffset = 值 设置虚线的偏移
数组中存储的数字就是分别表示 实线部分与空白部分的长度
[5] 实线和虚线都是5
[10,5] 实线是10 虚线是5
[10,5,2] 实线10 虚线5 实线2 虚线10 实线5 虚线2 实线10
[10,5,5,10]
```

### 7.其他线型相关属性

```js
1. ctx.lineWidth 设置线宽.
2. ctx.lineCap 设置线末端类型.
设置线型末端的样式, 可取值为: 'butt'( 默认 ), 'round', 'square'.
'butt' 表示两端使用方形结束.
'round' 表示两端使用圆角结束.
'square' 表示突出的圆角结束.
3. ctx.lineJoin 设置相交线的拐点.
设置两条直线的拐点描述方式. 可取值 'round', 'bevel', 'miter'(默认)
'round' 使用圆角连接.
'bevel' 使用平切连接.
'miter' 使用直角转.
```



### 8.填充与描边样式

```js
CanvasRenderingContext2D.strokeStyle = value  设置描边的颜色
CanvasRenderingContext2D.fillStyle = value    设置填充的颜色
这两个属性还可以设置渐变对象.
```

### 9.绘制坐标网格

```javascript
<canvas width="500" height="300" id="cas"></canvas>
    <script>
        var cas = document.getElementById("cas");
        var context = cas.getContext('2d');
       
        /* 绘制横线 */
        var step = 10
        for(var i=0; i<300/step; i++){
            context.beginPath();
            context.moveTo(0, step*i);
            context.lineTo(500, step*i);
            context.stroke();
        }
        /* 绘制竖线 */
        for(var j=0; j<500/step; j++){
            context.beginPath();
            context.moveTo(step*(j+1), 0);
            context.lineTo(step*(j+1), 300);
            context.stroke();
        }
    </script>
```



### 10.绘制矩形

```js
//绘制矩形参数 : x,y 是矩形的左上角的坐标,  w,h是矩形的宽高
ctx.rect(x,y,w,h) 		//绘制矩形,要手动添加描边或填充
ctx.fillRect(x,y,w,h)   //绘制填充矩形
ctx.strokeStyle(x,y,w,h)//绘制描边矩形
ctx.alearRect(x,y,w,h)  //清除矩形区域
```



### 11.绘制圆弧

```js
//绘制圆弧参数: x,y是圆弧的圆心坐标, r是半径,
// startRadian,endRadian是开始和结束时的弧度
// 最后一个参数是true / false ,是指定圆弧绘制的方向,默认是false,指顺时针绘制, true是逆时针绘制
ctx.arc(x,y,r,startRadian,endRadian,false);
```

### 12.绘制扇形

```
//绘制扇形,就是先找一个落笔点(圆心),再绘制圆弧,最后闭合路径或者直接填充
ctx.moveTo(200,200);
ctx.arc(200, 200, 100, 0, Math.PI/4);
ctx.closePath();
ctx.stroke();
```





### 13.计算圆弧的起始或结束位置的坐标

```
x0,y0 是圆心坐标值,r 是圆的半径
x坐标的值: x = x0 + r * Math.cos(弧度);
y坐标的值: y = y0 + r * Math.sin(弧度);
```



### 14.绘制文字

```js
// ctx.fillText("文本内容",x,y);  默认(x,y)坐标在文本的左下角 
// ctx.strokeText("文本内容",x,y);  默认(x,y)坐标在文本的左下角

// 设置文本字体大小, ctx.font = '30,黑体'

// 设置水平方向对齐方式 ctx.textAlign:  left , center , right , start , end ,默认是left:坐标点在文字的左边
	// ctx.textAlign = 'left';
      
// 设置文本垂直方向对齐方式 ctx.textBaseline : top , middle , bottom , alphabetic , hanging , ideographics
	// ctx.textBaseline = 'alphabetic';
```



### 15.绘制图片

#### 15.1. 绘制较小图片在画布上

```js
// ctx.drawImage(img,x,y) 坐标(x,y)是设置图片左上角的位置

/* 1.创建图片对象 */
       var img = new Image();
       img.src = 'imgs/rBACFFH1-B7DFB4PAAAYpkS1Sv4882_200x200_3.jpg';
/* 2. 当图片加载完毕之后,再进行绘制,不然没加载完就绘制,就没有结果了 */
       img.onload = function(){
           ctx.drawImage(img,100,100);
       }
 
     
```

#### 15.2. 将大图绘制在画布上

```js
/*  ctx.drawImage(img,x,y,w,h) 
    坐标(x,y)设置图片的左上角的位置
    w,h是设置图片的宽高值 
*/
/* 1.创建图片对象 */
        var w = 500;
        var h;
        var x = 50;
        var y = 50;
       var img = new Image();
       img.src = 'imgs/3484432_092618805000_2.jpg';
/* 2. 当图片加载完毕之后,再进行绘制,不然没加载完就绘制,就没有结果了 */
       img.onload = function(){
	/* 获取原图片的宽高,设置新图片的宽高,等比例设置高*/
            h = w / img.width * img.height;
           ctx.drawImage(img,x,y,w,h);
       }  
```

#### 15.3. 裁剪图片的部分区域,绘制在画布指定位置和大小的地方

```js
/*  ctx.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh) 
     将图片从(sx,sy) 处,裁剪出宽为sw, 高为sh的矩形区域,
     绘制到画布的(dx,dy)处,绘制大小为dw,dh
        */
/* 1.创建图片对象 */
        var dw = 300;
        var dh = 170;
        var dx = 50;
        var dy = 50;
        var sx = 677, sy = 0, sw = 300, sh = 170;
       var img = new Image();
       img.src = 'imgs/3484432_092618805000_2.jpg';
/* 2. 当图片加载完毕之后,再进行绘制,不然没加载完就绘制,就没有结果了 */
       img.onload = function(){
           /* 获取原图片的宽高,设置新图片的宽高,等比例设置高*/
           ctx.drawImage(img,sx,sy,sw,sh, dx,dy,dw,dh);
       }
```



### 16.EChars 的使用

```js 
/* 使用echars */
/* 1.引入echars.js文件 */

/* 2.为echars准备一个具有宽高的容器 */

/* 3.通过 echarts.init 方法初始化一个 echarts 实例 */
    var myChart = echarts.init(document.getElementById('main'));
/* 4.通过 setOption 方法生成一个简单的柱状图 */
    /* 注意: 图表中每个部分,比如说: 表格标题title,它的样式就在下面的option中的title这个对象中进行设置 */
        var option = {
            itemStyle: {
                // 阴影的大小
                // shadowBlur: 200,
                // 阴影水平方向上的偏移
                // shadowOffsetX: 0,
                // 阴影垂直方向上的偏移
                // shadowOffsetY: 0,
                // 阴影颜色
                // shadowColor: 'rgba(0, 0, 0, 0.5)',
                // 鼠标移入高亮显示 emphasis : 重点,强调
                emphasis: {
                    shadowBlur: 200,
                    shadowColor: 'rgba(0, 0, 0, 0.6)'
                }
            },
            title: {
                text: 'ECharts 入门示例 折线图'
            },
            tooltip: {},
            /* legend : 图例 */
            legend: {
                data:['销量'],
                right:50
            },
            /* xAxis : 横坐标 */
            xAxis: {
                data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
            },
            /* yAxis : 纵坐标 */
            yAxis: {},
            series: [{
                name: '销量',
                type: 'bar',
                data: [5, 20, 36, 10, 10, 20]
            }]
        };

/* 5.使用刚指定的配置项和数据显示图表。 */
        myChart.setOption(option);


     /*另外: 可以给表中的每个图形添加点击事件,点击后,获取到这个图形相关的所有参数,跳转到百度搜索这个产品 */
        myChart.on('click', function (params) {
            console.log(params);
            
            window.open('https://www.baidu.com/s?wd=' + encodeURIComponent(params.name));
        });


/* 6.以后需要改动,就只需要改动第四步中的代码,设置不同的option */
```







# 13.node.js

## 1.安装node.js

## 2.node.js概念

1.什么是 Node.js：就是 Javascript 的服务器端运行环境，可以让程序员使用 Javascript 来实现服务器端的编程；

2.Node.js 中 Javascript 的组成部分
- ECMAScript 核心 + 全局成员 + 核心 API 模块
- 全局成员：console、setInterval、setTimeout。。。
- 核心 API 模块：就是 Node 平台 单独提供的一些API，这些API是Node平台所独有的；

3.注意：Node.js 中 没有 BOM 和 DOM
1. 由于 Node 服务器端运行环境中，没有浏览器 和 HTML 的概念，所以，Node中的javascript 提出了 DOM 和 BOM 这两个对象模型，取而代之的，是 全局成员 和  核心 API 模块；

4.ECMAScript 规范，浏览器中的js，Node中的js之间的关系

1. ECMAScript 规范（标准）：就是一本书，这本书中规定了语言的特性；
2. 浏览器中的js：
   - 浏览器中的 js 组成部分：ECMAScript 核心 + DOM + BOM
3. Node中的js：
   - Node中的 js 组成部分： ECMAScript 核心 + 全局成员 + 核心API成员

## 3.node命令

```
直接用node命令来运行js文件 : 输入node 文件路径
node命令小技巧:
1. 在终端中，使用键盘的↑, 可以快速定位到上一次执行的命令
2. 在终端中，使用键盘的 tab 键能够快速补全路径
3. windows 系统上，在终端中输入 cls 可以清屏,cls不是node的,是window的命令
4.在vscode中, ctrl+反引号 快速打开终端
```

## 4.用let  const声明

```js
console.log(b);     //b is not defined
let b=20;
//用let 声明的变量没有变量提升的问题,要使用就一定先要定义

for(let j = 0; j< 10; j++){
    
}
console.log(j);     //j is not defined
//用let 声明的变量 存在{ }作用域的限制
```

```js
console.log(c);         //c is not defined
const c = 30;
//用const 声明的常量没有变量提升的问题,要使用就一定先要定义,而且不能够重新赋值

{ 
    const f = 50;
}
console.log(f);     //f is not defined
//用const 声明的常量 存在{ }作用域的限制
```



## 5.对象/数组解构赋值

```js
//对象的解构赋值,步骤是先解构,再赋值
const {name,age} = {name:'张三',age:18};
console.log(name,age);  //张三 18
//想用其他的变量名,不用对象中的属性名
const {name:aa,age:bb} = obj;
console.log(aa,bb);  //张三 18

//数组的解构赋值
const [num1,num2] =  [22,50]
console.log(num1,num2)  //22 55

/*注意:解构赋值是只要等号两边的结构一致,都可以,不一定非要数组或对象*/
```

## 6.箭头函数

```js
//将普通函数中的`function 函数名`去掉,在小括号和大括号之间加上 `=>`
function add (x,y){
    return x+y;
}
//将以上函数改造为箭头函数,本质为匿名函数
(x,y) => {
    return x+y;
}
```

```js
//---------------------------变体1
//形参只有一个参数时,小括号可以省略
 var add = x => {
    return x+10;
}
console.log(add(1));

//-----------------------------变体2
//函数体只有一行代码时,大括号可以省略,return也可以省略,默认会返回那行代码的执行结果
var add = (x,y) => x+y;
console.log(add(10,20));


//-----------------------------变体3
//当函数形参只有一个参数时,小括号可以省略,函数体只有一行代码时,大括号可以省略,return也可以省略
var add = x => x+20;
console.log(add(3))
```



## 7.ES6中对象中方法和属性的简写

```js
var name = 'zs';
var age = 18;
function show(){
    console.log('hello');
}
//对对象的方法的简写:直接写变量名,会直接找到变量,将变量名当做属性名,变量值当做属性值
//对对象中的方法的简写 : 将冒号和function都省略,直接在方法名后面写小括号,大括号
var person = {
    name,
    age,
    show,
    say(){
        console.log(123);
    }
}
```



## 8.fs读取文件

```js
//首先调用fs模块,
//再调用fs模块的读取文件的方法,有三个参数
/* 第一个参数: 要读取的文件的路径(后面要求写绝对路径) */
/* 第二个参数: 文件的格式,建议写'utf8'/'utf-8',是可选参数,默认是Buffer二进制数据流 */
/* 第三个参数: 读取文件结束的回调,此回调函数中有两个参数
    第一个参数在文件读取正确时,是null, 文件读取错误时,是错误对象
    第二个参数在文件读取正确时,是读取到的数据, 文件读取错误时,是undefined */
```



```js
const fs = require('fs');
fs.readFile('files/8.text','utf8',function(err,data){
    if(err) {
        console.log("读取文件失败");
        return;
    }
    console.log(data);
    
});
```

## 9.写入和追加文件

```js
const fs = require('fs');
//写入文件:会覆盖文件中之前的数据
// 三个参数: 路径,任意数据,回调函数(不需要读取数据,只有一个参数)

fs.writeFile("files/2.txt",'同志们辛苦了',(err) => {
    if(err) return console.log("文件写入失败");
    console.log("文件写入成功");
});

//追加文件:不会覆盖文件中之前的数据
// 三个参数: 路径,任意数据,回调函数(不需要读取数据,只有一个参数)
fs.appendFile("files/3.txt",'同志们辛苦了',(err) => {
    if(err) return console.log("文件追加失败");
    console.log("文件追加成功");
});
```

## 10.复制文件

```js
const fs = require("fs");
// fs.copyFile ('被复制文件的路径','要写入文件的路径',回调(err))
fs.copyFile("files/1.text",'files/1-copy.text',err => {
     if(err) return console.log('文件复制失败');
     console.log('文件复制成功');
     
 });
```

## 11.文件系统的路径问题

```js
//读取文件的路径是相对于你打开终端的文件来说的,当在不同级目录的终端下打开这个文件时,此时的路径就错了
//要使用path模块中的join方法:path.join(__dirname,'files/2.txt')
const fs = require('fs');
const path = require("path");
fs.readFile(path.join(__dirname,'files/2.txt'),'utf8',err => {
    if(err) return console.log('2.txt文件读取失败');
    console.log('2.txt文件读取成功');
});
```

## 12.创建包

```
1.初始化包配置文件,在文件夹中生成package.json文件
	npm init -y
2.自己创建一个js文件,在package.json文件中找到 main项,将文件名改为你创建的js文件名
	
3.使用自己创建的包:
	在另外的js文件中引用创建的包
	const test = require('./test')
	就可以使用自己创建的包了
```



## 13.下载/删除全局包(都在c盘目录下)

### 将md文件转化为html

```
1.安装全局包(i5ting_toc  : 可以把md文件转化为html文件)
	npm install i5ting_toc -g
2.安装完成后,使用安装包:
	i5ting_toc -f ./笔记.md
	完成后在同级目录下出现preview文件夹,其中有新生成的html
3.删除全局包
	npm uninstall i5ting_toc -g
```

## 14.下载/删除本地包(下载到打开命令行窗口的文件中)

```
1.初始化包配置文件,在文件夹中生成package.json文件
	npm init -y
2.下载本地包
	npm install jquery -S  (等价于npm install 包名 --save)
	安装包到本地的开发环境中
3.如果不小心把node_modules文件夹删除,包都没了,就输入 npm install  会去当前目录找package.json 文件,看这个文件中配置了什么包,然后帮我们下载下来我们没有的包
4.删除本地包
	npm uninstall jquery -S
	
5.安装到测试环境(--save-dev 等价于 -D)
	npm i art-template --save-dev
```

## 15.解决npm下载过慢的问题

```
npm下载的服务器是在美国,还要翻墙,下载速度慢
1.使用淘宝镜像下载cnpm:
npm install -g cnpm --registry=http://registry.npm.taobao.org
2.下载完毕后,再下载包的时候,都使用cnpm进行下载
使用cnpm下载的时候后面的-g 之类的一定要加上,命令要完整
如果在一个项目中,你之前一直都是用npm下载,后来改用了cnpm下载,那么之后这个项目中就一直要用cnpm下载
```



## 16.创建最基本的服务器

```js
//1.导入http核心模块
const http = require("http")

//2.调用http.createServer 方法,创建一个web 服务器
const server = http.createServer()

//3.为server服务器绑定监听事件
server.on('request',function(req,res){
	//3.1防止中文乱码的问题,200表示请求成功,成功就执行回调
	res.writeHeader(200,{
        'Content-Type':'text/html;charset=utf8'
    })
    //3.2根据不同的请求返回不同的页面
    if(req.url == '/about.html'){
        res.end('当前是about页面')
    } else if(req.url == '/movie.html'){
        res.end('当前是movie页面')
    } else{
        res.end('404访问的内容不存在...')
    }
})

//4.启动服务器,第二个参数是域名,默认是127.0.0.1  可以不写
server.listen(3000,'127.0.0.1',function(){
    console.log('server running at http://127.0.0.1:3000')
})
```

## 17.服务器的优化(用template模块进行渲染)

```js
const http = require('http')
const fs = require('fs')
const path = require('path')
const template = require('art-template')
const server = http.createServer();
server.on('request',(req,res) => {
    let url = req.url
    //返回不同的页面
    /* if(url == '/') url = '/views/index.html'
    fs.readFile(path.join(__dirname,url),'utf-8',function(err,data){
        if(err) return res.end('404文件读取失败')
        return res.end(data)
    }) */
    
    if(url == '/') url = '/views/index.html'
    //template(要渲染的文件路径,渲染需要的数据,不要可以为{} )
    let html = template(path.join(__dirname,url),{})
    res.end(html)
})

server.listen(3000,'127.0.0.1',() => {
    console.log('server running at http://127.0.0.1:3000');
    
})
```

## 18.下载nodemon工具包

通过npm i nodemon -g 命令下载工具包,

作用:每次对代码保存后,自动重启node服务器,用nodemon启动服务器

## 19.express 框架的安装和基本使用

express框架是基于http模块进一步进行了封装的模块,更加简洁,高效

1.**安装：**运行 `npm i express -S` 即可安装

2.**创建基本的 `express` 服务器：**

- 导入 `express` 第三方模块；
- **创建服务器的实例：**调用 `const app = express()` 方法；
- 通过 `app.get()` 或 `app.post()` 方法，来监听客户端的 `get` 或 `post` 请求，具体语法：
  - **监听 `GET` 请求：**`app.get('请求地址', (req, res) => { 处理函数 })` 
  - **监听 `POST` 请求：** `app.post('请求地址', (req, res) => { 处理函数 })` 
- **启动 express 服务器：**通过 `app.listen(端口, IP地址, 启动成功后的回调函数)` 启动服务器；

下载全局包,是工具包,不影响项目,可有可无,是辅助的,

下载局部开发环境包是必须的,没有就报错

```
初始化包: npm init -y
下载包: npm i express -S
```

```js
//1.导入express模块
const express = require('express')

//2.创建express服务器
const app = express()

//3.监听get请求
app.get('/',(req,res) => {
    //在express框架中使用http中的end方法,也可以使用
    // res.end('hello world')
    res.send('你好')
})

//4.启动服务器
app.listen(3000, () => {
    console.log('app running at http://127.0.0.1:3000');
})
```

## 20.express 中的快捷方法

1.`res.send()`

1. 支持 发送 字符串 `Content-Type: text/html;`
2. 支持 发送 对象 或 数组 `Content-Type: application/json`
3. 支持 发送 Buffer 此时会当作文件下载；

2.`res.sendFile()`

- 用法1：`res.sendFile(path.join(__dirname, './view/index.html'))`
- 用法2：`res.sendFile('./view/movie.html', { root: __dirname })`
- 注意：`res.sendFile()` 可以向浏览器发送 静态页面；



## 21.使用 `express.static()` 快速托管静态资源

> 如果我们网站中，有很多静态资源需要被外界访问，此时，使用 res.sendFile 就有点力不从心了;
>
> 这时候，express 框架，为我们提供了 `express.static('静态资源目录')` 
>
> 来快速托管指定目录下的所有静态资源文件；

1. **语法1：** `app.use(express.static('public'));`
   - `app.use() `方法，是专门用来注册 中间件；
   - `express.static` 是express的内置中间件；
2. **语法2：**`app.use('/虚拟目录', express.static('public'))`

## 22.为 express 框架配置模板引擎渲染动态页面

1. 安装 ejs 模板引擎` npm i ejs -S`
2. 使用 app.set() 配置默认的模板引擎 `app.set('view engine', 'ejs')`
3. 使用 app.set() 配置默认模板页面的存放路径 `app.set('views', './views')`
4. 使用 res.render() 来渲染模板页面`res.render('index.ejs', { 要渲染的数据对象 })`，注意，模板页面的 后缀名，可以省略不写！

## 23.使用 express 框架中提供的路由来分发请求

```js
const express = require('express')
const app = express()
//引入定义了路由的文件
const router = require('./06-定义路由.js')
//app.use方法进行注册
app.use(router)

app.listen(3000,()=>{
    console.log('server running at http://127.0.0.1:3000');
})
```

```js
//定义路由也就是: 06-定义路由.js
const express = require('express')
const path = require('path')

//创建路由对象
const router = express.Router()

//将请求与对应的响应内容挂载到路由对象上
router.get('/',(req,res)=>{
    res.sendFile(path.join(__dirname,'../views/home.html'))
})
router.get('/about.html',(req,res)=>{
    res.sendFile(path.join(__dirname,'../views/about.html'))
})
router.get('/movie.html',(req,res)=>{
    res.sendFile(path.join(__dirname,'../views/movie.html'))
})

//将定义好的router暴露给其他模块使用
module.exports = router
```



## 24.使用mysql模块操作数据库

```js
const express = require('express')
const mysql = require('mysql')
const app = express()

//1.用phpstudy开启mysql,开启navicat,用npm i mysql -S 命令下载mysql包
//2.创建mysql连接对象
const conn = mysql.createConnection({
    host     : 'localhost',
  user     : 'root',
  password : 'root',
  database : 'mysql-001'
})
//3.创建sql语句
//-----------------------查询--------------------
/* const sql1 = 'select * from users where isdel = 0'
conn.query(sql1,(err,result) => {
    if(err) return console.log('数据库查询失败'+err.message)
    console.log(result);
}) */

//------------------------新增---------------------
/* const user = {uname:'小黄',age:18,gender:'男'}
const sql2 = 'insert into users set ?'
conn.query(sql2,user,(err,result) => {
    if(err) return console.log('数据库新增失败'+err.message)
    console.log(result);
}) */

//-----------------------修改(更新)-----------------------
/* const user = {id:2,uname:'大雄',age:10}
const sql3 = 'update users set ? where id = ?'
conn.query(sql3,[user,user.id],(err,result) => {
    if(err) return console.log('数据库更新失败'+err.message)
    console.log(result);
}) */

//-------------------软删除:数据库中数据还在-------------------
/* const user = {id:2,isdel:1}
const sql4 = 'update users set ? where id = ?'
conn.query(sql4,[user,user.id],(err,result) => {
    if(err) return console.log('数据库删除失败'+err.message)
    console.log(result);
}) */

//----------------硬删除:直接将数据从数据库中删除---------------
const sql5 = 'delete from users where id = ?'
conn.query(sql5,2,(err,result) => {
    if(err) return console.log('数据库删除失败'+err.message)
    console.log(result);
})

app.listen(3000,()=>{
    console.log('http://127.0.0.1:3000');
    
})
```



## 25.三种获取请求参数的方法

### 1.通过req.query方法获取get请求参数

```js
const express = require('express')
const app = express()
app.get('/login', (req,res) => {
    res.send(req.query)        
    //请求地址: http://127.0.0.1:3010/login?name=zs
    //客户端接收数据: {"name": "zs"}
})
app.listen(3010,()=>{
    console.log('server running at http://127.0.0.1:3010');
    
})
```

### 2.通过req.params方法获取路由中的参数

```js
const express = require('express')
const app = express()
app.get('/register/:username/:age', (req,res) => {
    res.send(req.params)    
    //请求地址: http://127.0.0.1:3011/register/jack/21
    /*客户端接收数据: { "username": "jack", "age": "21"}  */    
})
app.listen(3011,()=>{
    console.log('server running at http://127.0.0.1:3011');
    
})
```



### 3.通过req.body方法获取post请求(表单)中的参数

```js
const express = require('express')
const app = express()

//引入 引入解析表单的中间件 body-parser
const bodyParser = require('body-parser')

//注册中间件
// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({extended:false}))
// parse application/json
app.use(bodyParser.json())

//注册完之后的req.body方法就可以直接获取表单数据了
app.post('/user/info', (req,res) => {
    res.send(req.body)
    //请求地址: http://127.0.0.1:3012/user/info  从表单中提交
    /* 客户端返回数据:  {
                            "name": "宋江",
                            "gender": "男",
                            "power": "1000"
                        }*/
})

app.listen(3012, () => {
    console.log('express server running at http://127.0.0.1:3012');
})
```



## 26.解决npm下载的包丢失的问题

```js
// yarn的作用和npm类似,都是包的管理工具
1. npm i yarn -g   //用npm安装全局的yarn,缺点是卸载node.js之后,npm下载的包全都没了
2. yarn -v  //查看当前yarn是否安装成功
3.yarn 的一些常见命令
	yarn init   //初始化文件,没有-y  需要一步一步回车
	yarn add 包名字  //安装包,默认安装到开发环境中
    yarn remove  包名字  //卸载包,默认安装到开发环境中
    yarn || yarn install  //找回你安装过的包
```

## 27.前后端彻底分离案例--英雄列表(MVC设计模式)

```js
/*后端负责操作数据库、给前端暴露接口
前后端分离的好处：保证了各个岗位的职责单一；
前端负责调用接口，渲染页面、前端就可以使用一些流行的前端框架 Vue， React， Angular  */
//1. 后端项目运行地址：http://127.0.0.1:5001
//2. 前端项目运行地址：http://127.0.0.1:3001
//产生的跨域问题的解决方法看 29.跨域问题的解决方法
```

[MVC](https://baike.baidu.com/item/MVC)全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，就是分层开发的思想:把复杂的业务处理,分成职能单一的小模块;每个模块之间看似相互独立,其实又各自有依赖关系

MVC的优点: 保证了模块职能的单一性,方便程序的开发,维护,拓展

MVC: M--model -->  数据操作层    V-View-->  页面视图层    C--Controller -->  业务处理层  



1.模型(Model) :

db文件夹: 数据库操作模块 --- 为了保证职能的单一性,数据库操作模块中只封装了数据库的连接对象,供外界使用

2.视图(View) : 页面视图层 ---- 客户端能看到的页面

3.控制器(Controller) : 

```
app.js  ---   入口文件;
	为了保证职能的单一性, app.js 中只负责创建web服务器, 并挂载路由和静态资源 ; 具体如何定义路由 , app.js并不关心
```

```
router路由模块:
	为了保证职能的单一性,路由模块只负责分发客户端的请求,但是并不关心如何处理这次请求; 具体这次请求如何处理,需要调用对应的controller业务处理模块
```

```
controller 业务处理模块:
	为了保证职能的单一性,单独创建了controller业务处理相关的模块,封装了各种业务逻辑的处理函数; 但是如果controller模块中需要操作数据库,此时需要导入db数据库操作模块
```

```js
/* hero案例开发步骤:
1.分好web 和 code两个文件夹,一个放前端代码,一个放后端代码
2.在前端和后端各自创建一个服务器,端口不同,
3.将前端开发要编写的代码全都放在public文件夹中,里面存放我们需要的文件 html, css, js等,托管为静态资源,让我们可以直接使用
4.前端静态页面写好,开始写功能,在前端的js文件中写,向后台API发送请求.  注意这里有跨域,可以让后台设置cors模块,一次解决
5.后台接收前端发送的请求,编写路由,再编写业务处理函数,对数据库进行增删改查,将处理得到的数据结果传递给前端
6.前端拿到后台响应的数据,再次对数据进行处理,比如使用模板引擎渲染页面等
```

## 28.前后端混合开发(传统)--黑马播客案例

```js
//传统开发模式下，用的最多的是 Jquery + 模板引擎 + Bootstrap
```

```js
/*步骤是:从view可视页面上点击发送请求,后台接收请求; 
在router路由模块编写路由; 
在controller业务逻辑层编写处理函数,决定返回数据让前端处理,或者直接用ejs渲染出一个完整的页面返回给前端
```

### 1.循环读取文件,实现注册路由

```js
//循环读取文件,实现注册路由
fs.readdir(path.join(__dirname,'./router'),(err,filenames)=>{
    if(err) return console.log('文件读取失败')
    // console.log(filenames);   //[ 'article.js', 'index.js', 'user.js' ]
    //遍历数组,将每个元素取出,引入路由模块并注册
    filenames.forEach(item => {
        const router = require(path.join(__dirname,'/router',item))
        app.use(router)
    })
})
```



## 29.跨域问题的解决方法

```js
//Cannot set headers after they are sent to the client  
//在请求时 ，出现这种问题，一定是因为，浏览器请求一次之后，服务器却返回两次及两次以上的响应。
//这种容易发生在异步回调中
//解决方法:在每次的请求处理中，一旦服务器返回响应，就即使的使用return，避免出现一次请求后，返回两次响应。
```

### 1.用jsonp解决跨域

```js
//1.跨域产生的原因:
浏览器的同源策略限制
//2.jsonp的原理
jsonp的原理是利用script标签中的src属性不存在同源限制
//3.jsonp的核心是后台返回一个函数的调用,同时传入后台的数据

<button class="btn1">用jsonp解决跨域方法1</button>
<button class="btn2">用jsonp解决跨域方法2</button>
<button class="btn3">用cors解决跨域方法1</button>
<button class="btn4">用cors解决跨域方法1</button>


/**/
<script>
    function callback (data) {
        console.log(data)
    }


    /*这是跨域请求,不会成功
    $('#btn').on('click',()=>{
        $.ajax({
			url:'http://127.0.0.1:80/jsonptest',
            success:function(res){
                console.log(res)
            }
        })
	}) */
    
//用jsonp解决跨域问题方法一:
//前端代码:
    function callback (data) {
        var html = tempalte('tpl',data)
        $('#tbd').html(html)
    }
    $.ajax({
        url:'http://127.0.0.1:80/jsonptest1',
        type:'get',
        dataType:'json',
        jsonp:'cb',
        success:function(res){
            console.log(res);
        },
        error:function(err){
            console.log(err);
        }
    })
//后端代码:
    app.get('/jsonptest1',(req,res)=>{
        const data = {
            name:'lisi',
            age:15
        }
        res.send(data)
    })
</script>
```

```js
//用jsonp解决跨域问题方法二(本质):
//前端代码:前台动态创建一个script标签,让这个标签添加到页面上,访问要请求的地址;前端在fn函数中对数据进行处理
    $('#btn2').on('click',function(){
        var script = document.createElement('script')
        script.src = 'http://127.0.0.1:80/jsonptest2?cb=fn'
        script.setAttribute('type','text/javascript');
        document.body.appendChild(script)
    })
//后端代码:后台会返回一个函数的调用,让浏览器调用函数,比如:	`fn(${data})`,后台将要传入的数据存储到data变量中
    app.get('/jsonptest2', (req,res) => {
        const fnName = req.query.cb
        console.log(fnName);
        const data = {
            name:'zs',
            age:18
        }
        res.send(`${fnName}(${JSON.stringify(data)})`)
        console.log(`${fnName}(${JSON.stringify(data)})`);

    })
```

### 2.用cors解决跨域

```js
// No 'Access-Control-Allow-Origin' header is present on the requested resource.
//方法三: 使用cors解决跨域问题方法一(本质,但是太简单了):
//前端代码:
	$('#btn3').on('click',function(){
            $.ajax({
                url:'http://127.0.0.1:80/corstest1',
                type:'get',
                success:function(res){
                    console.log(res);
                },
                error:function(err){
                    console.log(err);
                }
            })
        })
//后端代码:
    app.all('*', function (req, res, next) {
    	res.header('Access-Control-Allow-Origin', '*')
    	next()
    })
    app.get('/corstest1',(req,res)=>{
        const data = {
            name:'ww',
            age:20
        }
        res.send(data)
    })
```



```js
//使用cors解决跨域问题方法二:引入cors模块,并注册
//前端代码:
	$('#btn4').on('click',function(){
        $.ajax({
            url:'http://127.0.0.1:80/corstest2',
            type:'get',
            success:function(res){
                console.log(res);
            },
            error:function(err){
                console.log(err);
            }
        })
    })
//后端代码:
    const cors = require('cors')
    app.use(cors())
    app.get('/corstest2',(req,res)=>{
        const data = {
            name:'zhaoliu',
            age: 35
        }
        res.send(data)
    })
```

### 3.jsonp与cors的区别

```
1. JSONP的原理：动态创建script标签；所以实质上是get请求
   - JSONP发送的不是Ajax请求
   - 不支持 Post 请求；
2. CORS中文意思是跨域资源共享 ,需要服务器端进行 CORS 配置；
   - CORS 发送的是真正的Ajax请求
   - CORS 支持Ajax的跨域
   - 如果要启用 CORS 跨域资源共享，关键在于 服务器端，只要 服务器支持CORS跨域资源共享，则 浏览器肯定能够正常访问 这种 CORS 接口；而且，客户端在 发送 Ajax的时候，就像发送普通AJax一样，没有任何代码上的变化；
3. 对于Node来说，如果想要开启 CORS 跨域通信，只需要安装cors的模块即可；

```



## 30.获取时间戳

```js
new Date().valueOf()

new Date().getTime()

+new Date()

Date.now()

new Date(1546765357936)

```

## 31.cookie

```
HTTP协议的无状态性:
1. HTTP协议的通信模型：基于请求 - 处理 - 响应的！
2. 由于这个通信协议的关系，导致了HTTP每个请求之间都是没有关联的，每当一个请求完成之后，服务器就忘记之前谁曾经请求过
3.服务器为了能够明确区分每个客户端,我们可以在请求头(Request Headers)中添加一个标签，叫做cookie，这样，每次发送请求，都会把这个cookie随同其他报文一起发送给服务器，服务器可以根据报文中的cookie，区分不同的客户端浏览器。
```

```js
//在Node中可以在writeHeader的时候，通过Set-Cookie来将cookie标识通过响应报文发送给客户端！
var http = require('http');

var server = http.createServer();

server.on('request', function (req, res) {
    // 解析cookie
    var cookies = {};
    var cookieStr = req.headers.cookie; // 从请求的headers中获取cookie信息
    cookieStr && cookieStr.split(';').forEach(function (item) {
        var parts = item.split('=');
        cookies[parts[0].trim()] = parts[1].trim(); // 将cookie解析出来，保存到对象中
    });

    res.writeHeader(200, {
        'Content-Type': 'text/plain; charset=utf-8',
        "Set-Cookie": ['issend=ok', 'age=20']
    });

    if(cookies.issend ==='ok'){
        res.end('不要太贪心哦！');
    }else{
        res.end('呐，赏你一朵小红花~~');
    }
});

server.listen(4000, function () {
    console.log('服务器已启动!');
});
```

```js
// 通过expires设置Cookie的过期时间
// 设置 过期时间 为60秒之后
// 注意：在设置过期时间的时候，需要将时间转换为 UTC 格式
var expiresTime = new Date(Date.now() + 1000 * 60).toUTCString();
res.writeHeader(200, {
  'Content-Type': 'text/html; charset=utf-8',
  'Set-Cookie': ['isvisit=true;expires=' + expiresTime, 'test=OK']
});
res.end('<h3>你好，欢迎光临，送给你一个苹果！</h3>');
```

## 32.session

```js
//1.配置express-session
npm i express-session -S

//2.注册session;注册完之后,就可以在访问到req.session,在请求登录时,判断是否登录成功,如果成功就设置session
app.use(session({
    secret:'这是加密的秘钥', //这个值可以是任意字符串
    resave:false,
    saveUninitialized:false
}))

//3.如果登录成功,就在session上挂载一些用户个人信息和用户登录信息
    req.session.user = result[0]
    req.session.islogin = true

//4.将登陆成功的状态告诉浏览器
	res.send({msg:'登录成功',status:200})
```



# 14.微信小程序

## 1.生命周期函数

```js
//在app.js中设置的生命周期函数,任意页面都可以用
App({
  // 在整个应用启动时触发
  // 只会触发一次
  onLaunch: function (options) {
    console.log('应用启动了')
  },
  // 应用程序显示到屏幕上
  // 每次成为焦点状态都会触发
  onShow: function (options) {
    console.log('应用前台显示了')
    console.log(options)
  },
  onHide: function () {
    console.log('隐藏到后台')
  },
  // onError 只能捕获到运行阶段的异常
  onError: function (msg) {
    console.log(msg)
  },

  // 除了生命周期里面约定的 钩子函数，还可以定义任何成员，
  // 定义在这里的成员可以在后续每一个页面中共享
  foo: 'bar',
  say () {
    console.log('hello')
  }
})

```



```js
/*另外还有页面的周期函数,是在pages文件夹中的每个页面文件夹中的js文件中进行设置的,比如说在 pages/index/index.js 中设置:*/
Page({
  data: {},
  // 页面加载
  // 这个页面即将要工作了
  // 适合去做数据初始化
  onLoad () {
    // this.data.foo = 'hello world'
    this.setData({ foo: 'hello world' })
    console.log('index on load')
  },
  // 页面进入焦点状态（前台展示）
  onShow () {
    console.log('index on show')
  },
  // 当页面准备好了
  // 页面渲染完成
  onReady() {
    console.log('index on ready')
  },
  onHide () {
    console.log('index on hide')
  },
  // 页面卸载
  // 当页面被销毁
  onUnload () {
    console.log('index on unload')
  }
})
```

## 2.钩子函数

```js
//在某一个时间点去触发的函数叫钩子函数,就是一个回调函数
```



## 3.数据绑定

```js
//在js文件中定义好的data中的数据,将之在wxml页面中显示出来,此为数据绑定
//数据绑定用小胡子语法: mustache -> 专门用于输出逻辑层暴露的数据

//mustache 可以作用在 元素的 内容和 属性上
	<text>{{message}}</text>
  	<input value="{{message}}"/>
        
//小程序的 wxml 中 属性的值 如果只是在双引号内部 它永远是字符串
  //mustache 可以用于申明有类型的值
  <checkbox checked="{{false}}"></checkbox>  
	//如果是checked="false"  还是相对于非恐的字符串,复选框不被选中
	//checked="{{false}}" 可以识别是布尔类型的值,就是false 选中
```

## 4.wxs标签

```js
//wxs标签相当于微信里面的script标签,可以在里面写js代码
//在js文件中的data数据层定义的函数不能再页面上使用
<wxs module="foo">
  // 这里可以定义一个对象，这个对象可以直接在界面上使用
  // 这里的代码必须遵循 commonjs 规范
  module.exports = {
    addPostfix: function (input) {
      return input + ' wxs'
    }
  }
</wxs>
```

## 5.给标签绑定事件处理函数

```js
//在index.js中编写:
Page({
  // 定义用于界面层的事件处理函数
  tapHandle (e) {
    // e 指的是事件参数
    console.log(e)
  },
  viewTapHandle (e) {
    console.log(1, e)
  }
})

//在index.wxml中写:
<view bindtap="viewTapHandle">
  <button id="btn" bindtap="tapHandle">Click me</button>
  <!-- 通过 catchtap 绑定的事件不会有冒泡  -->
</view>
//这里有两个元素嵌套,都有绑定点击事件,会有事件冒泡,解决方法:
//将绑定事件的属性 bindtap 改成 catchtap ,就不会有事件冒泡了

//可以通过data-xx 属性 给事件处理函数传递额外的参数 
<button id="btn" catchtap="tapHandle" data-id="1">Click me</button>
//点击后在事件源参数 e 中有 dataset:{id: "1"}
```

## 6.数据流

### 1.单数据流和双数据流

```html
<!-- 小程序 和 react 都是单数据流, 即 在逻辑层js定义好的数据,通过数据绑定,显示在页面上,只要逻辑层数据改变,页面上的数据会自动改变-->
<!-- vue 是双数据流, 即 在逻辑层定义好的数据,通过数据绑定,显示在页面上,只要逻辑层数据改变,页面上的数据会自动改变; 相反,在页面上改动的数据也会被监测到,在逻辑层也会自动修改 -->


```

### 2.将小程序的单数据流变为双数据流

```html
<!--这是index.wxml页面-->
<!-- 需求: 改变input 表单里面的数据时,自动修改js中的数据,再将页面上的数据也自动刷新 -->
<text>{{ change }}</text>

<!-- 在表单数据改变时,监听数据 -->
<input value='{{ change }}' bindinput="changeInputData" />

<!-- 跳转到首页 -->
<block>
  <navigator url='/pages/index/index'>跳转到首页</navigator>
</block>
```

```js
//这是index.js页面
Page({
  data: {
    change:"这是数据"
  },
  //添加函数,监听表单数据
  changeInputData (e) {
    console.log(e.detail.value)
    //将改变的数据重新赋值给data中的change属性
    // console.log(this)  //指向的是 Pages
    //这种只改变了逻辑层数据,并没有改变视图层数据,要用setData进行设置
    // this.data.change = e.detail.value
    // setData 的作用:
    // 1. 改变数据源
    // 2. 通知框架，数据源变了，需要重新渲染页面
    this.setData({ change: e.detail.value})
  }
})
```



## 7.if 和 hidden

```js
//if是创建和删除DOM元素,, hidden是显示或隐藏DOM,
//在大量切换DOM的时候应该使用hidden,如果切换频率比较低,就使用if

//1. wx:if   wx:else    wx:elif
 <view class='loadmore loading' wx:if="{{hasmore}}">正在加载...</view>
<view class='loadmore' wx:else>没有更多了</view>

//2.  wx:hidden
    <view hidden="{{!isLoading}}">
        <text>loading...</text>
    </view>
    <!-- <view wx:elif=""></view> -->
    <view hidden="{{isLoading}}">
        <text>load done</text>
    </view>
```

## 8.循环数据

```html
<!-- wx:key的作用:在不刷新的dom树的情况下,添加dom元素,这样不影响之前元素绑定的事件 -->

<view>
<!-- wx:key 属性值 写的是 遍历的数据单项属性名称 -->
<!-- 或者也可以可以通过 *this 这个保留值 去指定当前被遍历的元素 -->
<!-- 遍历的每一项默认为item, 可以通过 wx:for-item="v"  来设置 -->
<!-- 每一项的索引默认为index,可以通过 wx:for-index="i"来设置 -->
  <view wx:for="{{students}}" wx:key="id">
    <checkbox/>
    <text>{{item.name}}</text>
  </view>
</view>

<text wx:for="foo">-{{item}}-</text>
<button bindtap="addItemHandle">add</button>
```

## 9.设置全屏

```css
/* 1. 设置page标签全屏,盒子宽高100%*/ 
page,.box{
    width:100%;
    height:100%
}
.box{
    background-color:red
}

/* 2. 设置盒子定位,再设置它的宽高100%*/  
.box{
     background-color:red;
     position:absolute;
     width:100%;
     height:100%
}

/* 3. 设置盒子定位,设置距离上右下左四个边的距离都是0*/  
.box{
     background-color:red;
     position:absolute;
     top:0;
     bottom:0;
     left:0;
     right:0
}

/* 4. 设置盒子的宽为750rpx,高就只有内容撑起来了,或者设置高度*/ 
.box{
    background-color:red;
    width:750rpx
}
```



## 10.1px边框问题

```js
//在小程序里面把屏幕都分为750rpx,设置边框时单位用rpx就可以解决1px问题
//不论是什么像素的手机,都把屏幕宽度设置为750rpx,等分为750等分,再根据屏幕实际宽度可以计算出1px = ?rpx
//1px 边框问题是因为苹果手机有2倍屏或者3倍屏,当设置边框为1px时,可能看起来会有2px或者3px,所以直接设置为1rpx就行了
```

## 11.组件,指令,生命周期,路由,请求

```js 
//无论学习什么框架都要学习组件,指令,生命周期,路由,请求
1.组件
	从ui的角度,页面上每一个独立的小界面都是一个组件,通常把 html, css, js 单独抽出来就是一个独立的组件
    在小程序中的pages中的每一个文件都是一个组件
    区分组件化和模块化: 模块化是从代码的角度来讲,把相同功能的代码抽离出来就是模块化, 组件化是从页面的角度来讲,把相同的小界面单独抽离出来

2.指令
	类似于 wx:for这种都叫指令  v- 开头  ng-开头的都是指令,就是框架给你提供的一些快速帮助你开发的系统,类似于webapi中提供的api

3.生命周期
	页面从无到渲染完毕再到最后消失的过程就是生命周期
    钩子函数 简单来说就是一个回调函数

4.路由: 
	路由就是一些对应规则 , 是请求与处理函数的对应关系

5.请求
	$.ajax()  window.fetch()这个有兼容性问题  wx.request()  this.$http()  vue-resoure  axios
    
6.任何定义全局的属性和方法
	小程序中的app.js 中有一个globalData  其他页面 let app = getApp().globalData
    
7. MVVM  
	M:数据层
    V:视图层
    VM:控制层
    
8. encodeURI('明星')  将中文变成url编码
	decodeURI('url编码') 将url编码变成中文
```



















#  16.ES6中的拓展

## 1.模板字符串的拼接 

```//解决方法二:cors

``反引号之间都是字符串,不用在意引号,在里面要拼接变量,就用${变量}  把变量包起来就行
var str2 = '传智博客的含义是：'
var str1 = str2+'传播智慧，播撒希望的一群侠客'
var str3 = `${str2}传播智慧，播撒希望的一群侠客`
console.log(str1, str3) */
/* var b = 'www.baidu'
var a = '<a href="http://'+b+'.com">我是a标签</a>'
var c = `<a href="http://${b}.com">我是a标签</a>`
console.log(a, c)
```

## 2.startsWith  判断是否是以某一段字符开始 

```js
var str4 = '金融港'
// str4.indexOf('金')  // 
var flag1 = str4.startsWith('金')  // 如果str4是以金开始则返回ture 反之返回false
var flag2 = str4.endsWith('融港')  // 如果str4是以金结尾则返回ture 反之返回false
console.log(flag1, flag2)

同理还有endsWith 判断是否以某一段字符串结束
```

## 3.padStart 用指定字符将字符串增加到指定长度

```js
str = 'aaa'
console.log(str.padStart(10,'c'))  //'cccccccaaa'
//应用: 倒计时计算时间后的补零操作
//同理也有从后面增加的方法 : padEnd
```

## 4.promise的使用

```js
 //利用promise处理异步请求,目的是: 请求数据和拿到数据之后的逻辑处理进行分离
//1.创建Promise构造函数的实例对象
/* 有两个参数此时只处理异步请求,不对返回的数据进行处理,成功和失败,代表请求之后的两个状态, 之后在请求结束之后,在then函数中,有两个参数,分别是两个处理函数,对应处理成功和失败的返回数据,可以在函数体中对数据进行处理*/
let p = new Promise(function(resolve,reject){
            $.ajax({
                url:'data/arr.json',
                dataType:'json',
                success(arr){
                    resolve(arr)
                },
                error(err){
                    reject(err)
                }
            })
});
p.then(function(arr){
       console.log(arr);
            arr.forEach(item => {
                console.log(item);
            }); 
            
       },function(err){
            console.log('请求失败')
})    
```

```js
//Promose.all() 方法可以把多个promise请求合并成一个新的promise
// 两个请求的结果在then方法的参数中,then的两个参数都是函数,函数的参数是请求结果
// then(function(){},function(){})
//数组中第一个元素是p1请求的结果,第二个元素是p2请求的结果

        Promise.all([p1,p2]).then(function(arr){
            console.log(arr);
            let [res1,res2] = arr;
            alert('全都成功了')
            console.log(res1)
            console.log(res2)
            //发生第三个请求
            let p3 = new Promise(function(resolve,reject){
                $.ajax({
                    url:'data/aa.txt',
                    dataType:'json',
                    data:{
                        res1,
                        res2
                    },
                    success(arr){
                        resolve(arr)
                    },
                    error(err){
                        reject(err)
                    }  
                })
            }).then(function(arr2){
                console.log('第三个请求发送成功了');
                
            })
        },function(err){
            console.log('至少有夜歌失败了');
        })
```

## 5.数组的扩展运算符

```js
//扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]

//该运算符主要用于函数调用。
function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
```

## 6.函数参数的默认值

```js
//es6之前不能为函数的参数设置默认值,通常的做法是:
function log(x, y) {
      y = y || 'World';
      console.log(x, y);
    log('Hello') // Hello World
    log('Hello', 'China') // Hello China
    log('Hello', '') // Hello World
}
//es6中可以为函数的参数设置默认值
    //参数变量是默认声明的，所以不能用let或const再次声明,否则会报错
function log(x, y = 'World') {
  console.log(x, y);
}
log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello    
    
//还可以与解构赋值结合起来用
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```



## 7.Token验证

```js
'yarn init -y'
'yarn add jquery axios jwt ws express'
注意:不要用中文目录
```



```js
//用户登录验证时,在服务端存储的session 以及存储到浏览器端域名下的cookie 有限制, 有的开发没有域名,比如移动端或者平板,所以要用token来储存用户信息
```

```js
//token原理: 
  /* 1.用户第一次登陆发送登录请求,服务端接收用户信息,与数据库比对,如果都正确,就让前端登录并将用户信息进行加密,并将加密过的信息返回给前端;失败就重新登录
	2.前端收到服务端返回的数据,如果成功登录,将返回的加密字符串存储到本地缓存token中
    3.下次请求需要登录的页面时,将本地缓存中的token当做参数发送请求,验证此token解密后信息是否与数据库匹配,如果是,就不需要登录,反之跳转到登录页面 */
```

```js
//请求登录
$('.btn').on('click',function(){
	fetch('/login?userName=张三&age=18')
	.then(res => {
		return res.json()  //将二进制转化为json或者其他
	})
	.then(res => {
		//如果登录成功,服务器会返回加密字符串,将之存储到本地缓存中
		localStorage.setItem('token',res.msg)
	})
})
```

```js
//引入jsonwebtoken ,将用户数据进行加密
const jwt = require('jsonwebtoken')
//登录接口
app.get('/login',function(req,res){
    //请求登录时,获取用户信息,进行验证,验证成功后,将之加密
    const userInfo = req.query
    // jwt.sign(用户信息,加密字符串,回调函数)
    //还可以给这个加密字符串设置一个有效期  3000000000毫秒
    userInfo.exp = Math.floor(Date.now() / 1000) + 3000000000
    jwt.sign(userInfo,'我是用来加密的字符串',(err,result) => {
        if(err) return res.send({msg:"登录失败",err:1})
        res.send({msg:result,status:200})
    })
})
```

```js
//通过传过去的token,获取用户数据,看是否匹配,
        $('.btn1').on('click',function(){
            fetch(`/getUser?token=${localStorage.token}`)
            .then(res => {
                return res.json()
            })
            .then(res => {
                console.log(res);
            })
        })
```

```js
//通过token获取用户数据,之后每次请求页面时,会将token携带过来,可以获取到token ,将之解密并与数据库中的用户进行对照,看是否有此用户,如果有,就不用登录
app.get('/getUser',function(req,res){
    //获取get请求中携带的token
    const token = req.query.token
    // jwt.verify(token,加密字符串,回调函数)
    jwt.verify(token,'我是用来加密的字符串',(err,result)=> {
        if(err) return res.send({msg:"获取用户信息失败,请重新登录",err:1})
        res.send({msg:result,status:200})
    })
})
```



## 8.Websocket即时通讯



## 9.promise封装ajax/fetch

```js
//这里的形参是obj 如果没有传参数,就默认是空对象
    function promiseAjax (obj={}){
        return new Promise(function(resolve,reject){
            $.ajax({
                url:obj.url,
                type:obj.type,
                data:obj.data,
                success:function(res){
                    resolve(res);
                },
                error:function(err){
                    reject(err)
                }
            })
        })
    }


$('.btn').on('click',function(){
        /*//分步说明为什么可以一直.then()
         var p1 = promiseAjax({
            url:`http://127.0.0.1:3300/`,
            type:'get',
            data:{
            }
        })
        console.log(p1,"p1");  //Promise {<pending>} "p1"     是一个promise对象

        var p2 = p1.then(res => {
            return 123  //这个就是下一次.then()中的实参了
        })
        console.log(p2,"p2");  //Promise {<pending>} "p2"     是一个promise对象

        var p3 = p2.then(res => {
            console.log(res,"p3打印结果");
            
        })
        console.log(p3,"p3");  //Promise {<pending>} "p3"     是一个promise对象 */
        
        promiseAjax({
            url:`http://127.0.0.1:3300/`,
            type:'get',
            data:{
            }
        })
        .then(result => {
            console.log(result,"第一次then");   //{err: 0, data: "成功"} "第一次then"
        })
        .then((res)=>{
            // 这里的第一个.then()的返回结果也是一个promise,所以可以接着.then()
            console.log(res,"第二次then");  //undefined "第二次then"
            
        })
        .catch(err => {
            console.log(err);
        })
    })
```

```js
//使用fetch进行请求
    $('.btn').on('click',function(){
        fetch('/')
        .then(res => {
            console.log(res,"没转化之前的数据");
            return res.json()   
        })
        .then(res => {
            console.log(res,"fetch");   //{err: 0, data: "成功"} "fetch"
            
        })
    })
```

## 10.跨域之反向代理

```js
//从自己的服务端请求聚合数据的接口数据
//用反向代理解决此跨域问题,原理: 不直接向聚合数据发送请求,而是向自己的服务端发送请求,此时不存在跨域,
//再由自己的服务端向聚合数据发送请求,服务端之间也不存在跨域,所以就解决了
        $('.btn').on('click',function(){
            fetch('/test')
            .then(res => {
                return res.json()  //将二进制转化为json或者其他
            })
            .then(res => {
                console.log(res);
            })
            .catch(err => {
                console.log(err);
                
            })
        })
```

```js
const express = require('express')
//引入axios,可以在服务端发送请求
const axios = require('axios')
//创建express的服务器,这样在服务端打开promise-ajax.html这个文件,不会因为协议不同而产生跨域问题
const app = express()

//托管静态资源
app.use(express.static('./public'))
app.get('/test',(req,res) => {
    //代理是axios解决的吗?  axios只是一个请求的库,我们这里可以用任何一个请求库都可以完成,所以当前反向代理和axios没有关系
    axios.get(`http://v.juhe.cn/movie/index?key=788b3a78aacd537af7de807a32a177bc&title=%E9%92%A2%E9%93%81%E4%BE%A03`)
    .then(result => {
        res.send({msg:"我用反向代理帮你解决跨域",data:result.data})
    })
})
```

 11 class 类继承

这是es6中的面向对象

js是原型继承的,其他语言都是类继承的 , 类继承比较好理解, 原型继承不好理解,所以js在es6中推出了class把原型继承包装了一下,

```
class Person{
    constructor(name,age){
        this.name = name
        this.age = age
    }
    sayHi(){
        console.log("你好啊,我是"this.name)
    }
}
class Student extends Person{
    constructor(name,age){
    //super:调用父类的构造函数,为子类对象提供属性的初始化
        super(name,age)
    }
}
let p = new Person('刘德华')
console.log(p)
p.sayHi()

let s = new Person('张学友')
console.log(s)
s.sayHi()

```



# 17.vue

## 1. 准备工作

### 1.1 在chrome浏览器中装上插件Vue.js devtools

### 1.2 github

#### github提交代码时报错解决方案

报错信息:

> permisstion denied

> access denied

1. 检查公钥是否配置正确

2. 检查当前仓库关联的远端仓库是否使用的 `ssh` 协议

   查看当前仓库的关联详细信息

   ```
   git remote --verbose
   ```

   将本地的仓库关联到远端的 git@github.com:TianchengLee/test.git

   ```
   git remote add origin git@github.com:TianchengLee/test.git
   ```

   如果之前关联的是https, 非ssh, 可以删除
   	
   删除关联

   ```
   git remote remove origin
   ```

   重新添加

   ```
   git remote add origin git@github.com:TianchengLee/test.git
   
   ```

#### github提交代码步骤

+ 在github上创建新仓库--远程仓库
+ 在电脑上创建一个与仓库同名的空文件夹
+ 在文件夹里面鼠标右键,打开git base
+ git init  初始化本地仓库
+ 将要上传的代码放在 .git 同级的位置, git add .  
+ git commit -m '注释'
+ git remote add origin git@github.com:youyoujiushishuang/test.git
+ git push -u origin master
+ git push
+ 以后再上传代码到这个仓库中去,就可以直接 add - commit  -  push  这个步骤了

注意: 设置邮箱和用户名必须是github上的邮箱和用户名,

git config --global --list     用这个指令来检查你的邮箱和用户名,如果不一致,再用  git config --global  username

#### git管理的项目可以查看以前的代码

```
git log --oneline  查看以前的提交日志,每次都有唯一标识符,比如:af22s52s
git reset --hard af22s52s  回到这个标识符标志的代码
git relog 查看所日志,找到最新的日志
git reset --hard最新标识符的版本
```



##  2. 框架与库的区别

```
框架:是一套完整的解决方案;对项目的入侵较大,项目如果需要更换框架,则需要重新架构整个项目

库(插件):提供某一个小功能,对项目的侵入性较小,开发过程中,可以很轻易地切换成其他库或者框架继续开发

jquery最强大之处在于:选择器和便捷的DOM操作,处理了浏览器兼容问题

Vue等框架MVVM思想设计的框架,都有数据绑定的特点,当Model层的数据更新,会通过VM层自动同步刷新到View层,从此程序员只需要关注业务逻辑,而不需要操作DOM

Vue和Angular都提供了双向数据绑定,除了可以从Model同步到View层,还可以从View层数据发生变化时反向同步到Model层
```

## 3. node中的MVC与前端中的MVVM的区别

```
MVC是后端的分层开发概念
```

![MVC](F:\前端23期学习\15 vue.js\总资料\新VUE\Day_001\笔记\01.MVC和MVVM的关系图解.png)

```
MVVM是前端视图层的开发思想,主要是把每个页面分成 数据层 M , 视图层 V , vue实例 VM ; 其中, VM是MVVM思想的核心,因为VM是 V 和M之间的调度者
M--model : 保存了每个页面中的数据
VM : 是一个调度者,分离了V 和 M ; 每当V层想要获取保存数据的时候,都要由VM做中间的处理
V--view : 就是页面中的HTML结构
前端页面中使用MVVM 的思想,主要是为了让我们开发更加方便
注意: 是 VM 提供了数据的双向绑定 , 只要数据改变,页面中的数据也自动改变
```

## 4. vue基本使用

```js
//html结构  view视图层
<div id="app"></div>  
```

```js
//js代码:
let vm = new Vue({	//vm层调度者
    el:"#app",
    data:{		//Model数据层
        msg:"这是数据层"
    }
})
```



## 5.vue的指令

vue中以 `v-` 开头的属性都是指令 , 双引号中的是变量(表达式,可以写js代码)

### 5.1 v-cloak

```
v-cloak  : 为了解决Vue模板渲染时的闪烁问题(vue.js引入是在html结构渲染之后再引入的,就会出现闪烁问题); 可以直接在</head>标签上面引入就可以彻底解决这个问题,所以这个指令不太重要
```

### 5.2 v-text

```
v-text : 相当于将表达式的结果渲染到标签上的innerText 属性上,哪怕标签里面有内容也会被覆盖
	跟差值表达式<p>{{...}}黑胡椒</p> 的区别是,标签内部差值表达式之外的内容也还存在, 且差值表达式只能用于元素内部内容的渲染,不能用于属性渲染
```

### 5.3  v-html 

```
v-html : 与v-text用法一样,区别是这个能渲染出标签,而 v-text 只会解析为纯文本
```

### 5.4 v-bind : 绑定原生和自定义属性的指令

```
v-bind : 是vue中提供的用于绑定原生和自定义属性的指令 <input v-bind:value="msg+'字符串拼接'"/>
	有简写形式, 将 v-bind删掉 直接用  :value="msg"
<input :a="msg" :value="msg+'bb'"/>
```

自定义指令的时候,给指令命名不能有大写字母,想要双击input获取焦点,定义v-focus的时候,不能定义在inserted里面,而是要定义在update中

失去焦点是 @blur="nofocus"   双击事件: @dblclick="change"



### 5.5 v-on : 用于提供事件绑定的指令

```
5.v-on : 用于提供事件绑定的指令
	另:在vue绑定事件中,可以携带参数
	<div v-on:click="show">点我</div>
	点击后会去找show方法,在methods中;
有简写形式 @ 
	<div @click="show">点我</div>
```

### 5.6 事件修饰符

```
6. v-on绑定事件 的事件修饰符
vue中为了方便开发人员处理一些简单的逻辑,例如阻止事件冒泡或者是默认行为,
	.stop  阻止事件冒泡,到此不再往外传
	.prevent 阻止默认行为发生
	.capture 添加事件监听器时使用事件捕获模式
	.self  只有点击当前元素自身时才触发事件,不会通过事件冒泡触发它身上的事件
	.once  事件只发生一次,之后无效
	
```

### 5.7 v-model

```
7. v-model  vue提供的双向数据绑定的唯一一个指令
v-bind 只能实现数据的单向绑定,从 M 到 V ,无法实现数据的双向绑定
v-model 实现数据的双向绑定,从 M 到 V , 还可以从 V 到 M ,即用户修改value属性时,自动同步回model层; 为什么不需要手动指定要绑定的属性呢? 由于用户与input 交互时,修改的是value值,所以v-model 只能绑定value属性 ; 
```

### 5.8 v-bind:class  在vue中动态绑定类样式

```js
8.v-bind:style    在vue中动态绑定类样式 
//现在style标签中定义好样式
			.red{
                color:red
            }
            .fontsize{
                font-size: 50px;
            }
            
//方法1:直接传入一个数组,虽然使用属性绑定了,但是依然写死了,没有实现动态的切换
	<h4 :class="['red','fontsize']">{{msg}}</h4>

//实现动态切换有两种方式,可以使用三元表达式或者对象来决定是否要动态添加数组元素

//方法2:在数组中使用三元表达式
	<h4 :class="['red', flag?'fontsize':'']">{{msg}}</h4>

//方法3:在数组中,将三元表达式改造为对象,提高代码可读性
	<h4 :class="['red', {'fontsize':flag}]">{{msg}}</h4>

//方法4:直接使用对象
	<h4 :class="classObj">{{msg}}</h4>
	在data中有 classObj 这个对象 {fontsize:true,red:false}
	//在为class使用v-bind绑定对象的时候,对象属性是类名,由于对象的属性名可以带引号,也可以不带,,所以这里没有引号

`总结:当类样式较多,而需要动态切换的类名只有一个,推荐(方法3)使用绑定数组的方式来实现动态切换,反之,当类样式较少,都需要切换时,使用(方法4)对象较为方便`
```



### 5.9 v-bind:style  行内样式的绑定

```js
//给style属性进行 v-bind 绑定
//1. 直接传入一个对象
<p :style="{color:'red','font-size':'20px'}"></p>
<h4 :style="classObj">{{msg}}</h4>
注意:当对象的属性名是合法的变量名时,可以不带引号,如果不是(有横线),就要加上引号

//2. 传入一个数组
<h4 :style="[classObj,classObj1]">{{msg}}</h4>

//在data中定义好对象:
data: {
        classObj: { color: 'red', 'font-weight': 200 },
        classObj1: { 'font-style': 'italic' }
      }
```

### 5.10 v-for 

```
v-for 原理:正在更新已渲染过的列表元素时,它默认"就地复用"策略

:key的作用就是将当前的数据与当前的DOM元素进行绑定,以后如果数据顺序发生变化,vue会在内部重新排序,然后渲染,这虽然会降低v-for的一部分性能(排序),但是影响不大

```

```
1.迭代数组
	<p v-for="(item,i) in arr">{{item}}</p>	
	
2.迭代对象
	<p v-for="(value,key,index) in obj">{{item}}</p>	
	
3.迭代数字,count从1开始
	<p v-for="count in 10">{{item}}</p>
```

```
注意:v-for中的key属性,在v-for循环渲染列表后,如果每个单项都有状态类型的表单元素,例如:checkbox ,此时

每次使用v-for时,用key来标识每一项的唯一身份,注意这个  :key="" 这里的值只能是字符串或者数值,一般用item.id或者是index
```



### 5.11 v-if 和 v-show

```
v-if 和 v-show 的区别:
共同点:都是用于控制元素的显示和隐藏的
不同点:
	v-if 的特点是每次都会重新删除或创建元素; 有较高的切换性能消耗 ; 如果元素涉及到频繁的切换,尽量不要用v-if
	v-show 的特点: 每次不会重新进行DOM的删除和创建,只是切换了元素的display:none 样式 ; 有较高的初始渲染消耗(表达式是false,v-show还是会创建出来)
```

5.12 自定义指令(了解)

在Vue内部提供了很多内置指令: v-text, v-html, v-if, v-show, v-model ... 等等, 一切以v-开头的都是指令

除了内部提供的这些指令外, 开发者还可以自定义指令

1. 定义全局指令

   // 定义全局指令
       // 参数1: 指令名称, 不需要 v-
       // 参数2: 对象, 对象中有可以有5个函数 bind, inserted, update, componentUpdated, unbind
       //     5个函数就是所谓的钩子函数, 就是当指令应用到标签身上整个过程, 每个阶段所调用的函数
       Vue.directive('focus', {
         // 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
         bind(el) {
           // console.log(el)
           // console.log('我被绑定了')
           // el.focus()
         },
         // 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
         inserted(el) {
           console.log(el)
           // console.log('我insert到父节点了')
           el.focus()
         },
         // 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前
         update() {}
       })

2. 使用指令

   <input v-focus type="text" class="form-control" v-model="keywords">

**注意: 定义指令时不需要加 `v-` 使用指令时必须要加 `v-`**

### 5.13 定义私有指令

同私有过滤器, 在vm配置对象中, 和methods以及data同级的位置, 加入一个`directives`的属性:

```js
directives: {
	focus: {
	  bind() {
	  },
	  inserted() {
	  }
	}
}
```

### 定义全局指令

```js
Vue.directive('focus',{
    bind(el){  //该指令被绑定到元素上时发生

    },
    inserted(el){  //当元素插入到DOM中时发生
    	el.focus()
    },
    update(el){		//当元素发生改变时发生,双击获取焦点,就要在这里定义focus

    }
})
```



## 6. es5中的迭代方法: 

forEach  some  findIndex reduce map every filter 都会循环遍历数组,这些方法都是对传统for循环的封装

在这些方法中,想要随时终止循环,不能用break ,

break终止循环只能用在 for switch  while 中

```js
// forEach就是单纯的循环遍历数组中的每一个元素, 不具备任何特点
this.list.forEach(item => {
	// 在forEach内部完成的循环
	console.log(item)
	if (item.id == 1) {
		// break
		// break只能用于 for  while  switch 中,其他地方不起作用
	}
})
```

```js
//some的特点: 当回调函数return true的时候会终止循环
this.list.some((item, i) => {
            // 循环取到一个数组元素就会调用一次回调函数
            // 在some函数内部完成
            // console.log(item)
            // if (i === 0) {
            //   return true
            // }
            if (item.id === id) {
              this.list.splice(i, 1)
              return true
            }
})
```

```js
//findIndex的特点: 当回调函数return true是 会结束循环并把当前遍历到的元素索引返回给调用findIndex的位置
          let index = this.list.findIndex(item => {
            if (item.id === id){ 
              return true
            }
          })
```



## 7. 按键修饰符

```js
//当用户输入完数据后, 每次都需要点击添加按钮才可以将数据录入表中, 用户体验不佳, 最好能够当用户输入完数据后, 直接按回车立即录入表中
<input @keyup.enter="add" type="text"  v-model="name">
//@keyup.enter 的意思是给input绑定键盘抬起事件, 并且只有在回车键抬起时才会触发    

//所有键盘事件都有按键修饰符, 本质上其实是点的keyCode, 只不过Vue为了方便大家记忆, 内置了一些别名: enter , delete , tab , left , right , up , down , space , esc  
//想要使用其他的键,都要直接只用keyCode码,或者自定义全局按键修饰符
    @keyup.108="add"  //键盘上的108代表的是数字键盘上的enter
	//或者用 Vue.config.keyCodes.f1 = 112
```

## 8. 过滤器

过滤器:就是对在数据渲染到页面上的前一瞬间 , 对数据进行加工,不改变原来的数据,再将过滤之后的返回值渲染到页面上 ; 过滤器可以串联

### 8.1 全局过滤器

定义在Vue上的是全局过滤器,不管哪个vm实例中都可以使用 

```js
//Vue.filter('过滤器的名字',回调函数)
//回调函数中的参数:
    //第一个参数:管道符左边的内容
    //第二个参数:从第二个参数开始就是过滤器传过来的参数
Vue.filter('msgFilter',(data,str)=>{
     return data.replace('HelloWorld','你好世界')+str
})

// 过滤器还可以串联使用
// <p>{{msg | msgFilter('哈哈哈哈') | test}}</p>
```

### 8.2 私有过滤器

定义在vm实例中的是私有过滤器只能在那个vm实例中使用 

```js
var vm2 = new Vue({
	el:"#app2",
	data:{},
	methods:{},
	//这个过滤器定义在app2中,只有在app2中才能使用
	filters:{
		dateFormat:function(date){
		}
	}
})

//注意:过滤器调用原则是:就近原则,如果全局过滤器和私有过滤器名称一致,就先使用私有的
```

`注意: 过滤器只能在插值表达式或者 v-bind中使用,其他地方不能使用`

##  9. 生命周期函数

生命周期函数是指, Vue实例创建的过程中, 从出生到死亡每个阶段所执行的函数

一共有8个:

```
beforeCreate: 实例完全创建之前, 此时data和methods等数据都没有初始化, 不能使用

created: 实例已经创建完毕了, 此时data和methods等数据都可以使用了, 实例对象也可以访问 , 一般在这里就可以发送请求了

beforeMount: 模板在内存中编译完成了, 但是还未渲染到页面上,获取到的都是模板字符串

mounted: 编译好的模板完全渲染到页面, 用户最终看到的样子, 此时DOM元素也是最新的, 如果想操作DOM元素, 最好在这个生命周期函数中进行

beforeUpdate: 当data中数据改变时会触发, 此时页面上的数据并没有重新渲染, 只是data中的数据更新了

updated: 当data中数据改变后, 并将页面上的数据也更新完成后会触发, 此时data中的数据和页面上的数据是同步的

beforeDestroy: 当实例进入销毁阶段时执行的钩子函数, 此时Vue实例中的data/methods/filters/directives等都还可以使用

destroyed: 实例上的所有成员已经完全销毁, 无法使用了
```

## 10. vue-resource 发送请求

```js
//发送get请求
this.$http.get('请求地址',[])
```



```js
//发送post请求
this.$http.post('请求地址',[{}],[{}]).then(成功回调,失败回调)
第一个参数: 请求地址
第二个参数: 请求的参数
第三个参数: 设置发送请求的格式  Content-Type , 默认是 application/json  , 但是很多浏览器不支持这个格式,所以要通过 emulateJSONP:true  来将格式设置为  application/x-www-form-urlencoded ; 之前用jquery中的ajax发送请求默认就是application/x-www-form-urlencoded 这个格式,为了兼容性问题


```



```js
//发送jsonp请求
del(id){
    this.$http.jsonp(`delproduct`)
    .then(result=>{
         if(result.body.status == 0){
              this.list = result.body.message
         }
     })
}             
```



设置全局配置根域名 , 设置之后,请求路径要用相对路径

Vue.http.options.root = 'http://vue.lovegf.cn:8899'

全局启动emulateJSONP配置

Vue.http.options.emulateJSONP = true



## 11. 动画

### 1.使用过渡类名设置动画

在vue中的动画只是为了帮助用户理解应用程序而存在,并非是为了做出炫酷的特效

![](https://cn.vuejs.org/images/transition.png)

```js
//动画有六个类名(只需要掌握4个)
v-enter : 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除

v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。

v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

v-leave-to: 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。
```

使用上面的类名制作动画

1.先将要执行动画的元素使用 `<transition></transition>` 标签包裹,这个标签会给包裹起来的元素增加或者移除样式

```html
<input type="button" @click="flag=!flag" value="按钮">
<!-- 需求: 点击按钮让h3显示隐藏切换 -->
<transition>
    <h3 v-if="flag">这是一个h3</h3>
</transition>
```

2.给四个类名设置样式

```css
 .v-enter{
 	opacity: 0;
 	transform: translateX(180px)
 }
 .v-leave-to{
	 opacity: 0;
 	transform: translateY(180px)
 }
 .v-enter-active,
 .v-leave-active {
 	transition: all 0.8s ease;
 }
```

另:

自定义前缀

```js
/*因为网页中可能有多个元素需要动画,没了不混淆,所以自定义前缀
在transition标签上加上一个name属性,其属性值就是 自定义的前缀
自定义类名优先级高于普通类名,便于与第三方css动画库结合使用*/

<transition name="flip">
    <h3 v-if="flag">这是一个h3</h3>
</transition>

//这里将 transition 标签的 name 属性设置为了 flip name设置过渡样式时的类名都不用默认的`v-` 开头了,而是 `flip-` 开头
```

### 2.animate.css 动画库

```
1. 引入 animate.css 库 
2. 在 transition 标签上添加属性 enter-active-class 设置入场动画 ; leave-active-class 设置离场动画
3.设置入场和离场动画的属性值都是类名,animated都是要加的,另一个是动画的类样式
```

```html
<transition 
enter-active-class="animated rollIn"
leave-active-class="animated rollOut">
	<h3 v-if="flag1">这是一个h3</h3>
</transition> 
```

```html
4. 还可以设置入场和离场动画的时间
	使用 :duration="毫秒值" 来统一设置
	<transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="200">
      <h3 v-if="flag" class="animated">这是一个H3</h3>
    </transition>
```

```html
5.入场和离场动画的时间 也可以不同
<transition 
    enter-active-class="bounceIn" 
    leave-active-class="bounceOut" 
    :duration="{ enter: 200, leave: 400 }">
    <h3 v-if="flag" class="animated">这是一个H3</h3>
</transition> 
```



### 3.列表动画

```js
//对于使用v-for遍历数据渲染出来的列表,要对每个渲染出来的元素使用动画,就和上面的单元素的动画不一样了
```

```
需要使用transition-group标签进行包裹

1. 不同于 <transition>，<transition-group>标签会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。
2. 过渡模式(mode属性)不可用，因为我们不再相互切换特有的元素。
3. 内部元素 总是需要 提供唯一的 key 属性值。
4. 通过appear属性可以让列表加载时执行动画

```

案例:

```html
<!-- html代码 -->
<transition-group tag="ul" appear name="flip">
    <li v-for="(item,i) in list" :key="item.id" @click="del(i)">
          {{item.id}}---{{item.name}}
    </li>
</transition-group>
```

```css
/* css代码 : 为 transition-group 包裹起来的元素设置动画 */
            .flip-enter,
            .flip-leave-to{
                opacity: 0;
                transform: translateY(80px)
            }
/*如果想让删除时的动画更加平滑, 删除一个元素后, 其他元素一起执行动画, 可以使用Vue内部封装FLIP动画队列后的 v-move 类样式来设置过渡效果 , 通过tag属性改变前缀后,已经是 .flip-move 了*/
            .flip-enter-active,
            .flip-leave-active,
            .flip-move{
                transition: all 1s ease;
            }
/*注意: 当执行删除动画时, 元素依然占位置, 所有需要在v-leave-active中设置绝对定位, 让元素脱离文档流实现完美的动画效果!!!*/
            .flip-leave-active{
                position: absolute;
            }
```





### 4.实现半场动画

```
用javascript钩子实现 , 也就是动画的生命周期函数
```



## 12.组件化开发

```
什么是组件?
组件的出现,就是为了拆分vue实例的代码量的,能够让我们以不同的组件,来划分不同的功能模块,将来我们需要什么样的功能,就可以去调用对应的组件即可
```

组件化: 对视图层的业务逻辑的划分,提高了视图层的复用性

模块化: 对controller的划分,提高了代码的复用性



### 1 创建组件的方法

注意事项: 

+ 在注册组件名字的时候,如果组件名用驼峰命名的,在作为标签使用的时候,把大写字母改为小写,并将两个单词之间用 - 连接 ; 当然,如果命名时,没有用驼峰命名,就直接用祖建名作为标签名
+ 组件必须注册之后才能使用
+ 组件的模板`template`中有且只能有一个根节点

1.1 Vue.extend方法(不推荐, 太麻烦了)

```js
/* 创建组件的第一种方法 */
/* 1.创建组件 js代码:*/
	var com = Vue.extend({
		template:'<h1>这是创建的模板里面的html代码,无提示</h1>'
	})
    
/* 2.注册组件 js代码:*/
	Vue.component('mycom',com)

/* 3.使用组件:在vm实例控制的区域,用组件名作为标签名,写一对标签就行 html代码:*/
		<div id="app">
            <mycom></mycom>
        </div>
```

1.2 直接使用带有`template` 模板字符串的对象作为参数

```js
/* 1.注册组件 */
Vue.component('mycom',{
	template:'<h2>这是模板里的字符串</h2>',
    data(){
        return {}
    },
    methods:{}
})
/* 2.使用组件:在vm实例控制的区域,用组件名作为标签名,写一对标签就行 html代码:*/
		<div id="app">
            <mycom></mycom>
        </div>
```

1.3 在app区域外定义好模板后, 直接通过template属性引用

```js
 /* 1.注册全局组件 */
 Vue.component('mycom',{
 	template:'#tpl',
     data(){
        return {}
    },
    methods:{}
 })

/* 2.写模板,注意要在app区域以外写模板标签 */
/* 注意: 模板内部必须有且只有一个根标签 */
<template id="tpl">
     <h3>这是在template模板标签中写的模板内容,有代码提示</h3>
</template>

/* 3.使用组件:在vm实例控制的区域,用组件名作为标签名,写一对标签就行 html代码:*/
		<div id="app">
            <mycom></mycom>
        </div>
```

1.4 创建私有组件

```js
//1.在vm实例中注册私有组件
var vm = new Vue({
	el:"#app",
	data:{},
	methods:{},
    components:{
    //com1 是组件名,调用组件就是使用组件名作为标签
        com1:{
            template:"#tpl1",
            data(){
        		return {}
    		},
    		methods:{},
        }
    }
})
//2.在app外面定义模板字符串,模板要有一个根标签
		<template id="tpl1">
            <div>
                <h1>这是登录组件</h1>
            </div>
        </template>
//3.调用此组件的方法就是把组件名作为标签名,在app内部使用
		<div id="app">
                <login></login>
        </div>
```



### 2 组件中的data 和 methods

组件内部的成员,基本上和VM实例类似, 有data/methods/filters/directives/八个生命周期函数等,都是一样的

但是组件中的data与实例的data不同, 必须是一个函数, 并且内部必须返回一个对象 {} ,相当于 new Object()  意味着新创建了一个对象,就可以保证每个组件中的data都不一样, 组件中的data职能在组件的模板内部使用

组件中的methods 也是一个对象,这个和实例中的一样

```
Vue.component('mycom1',{
    template:"#tpl",
    data:function(){
        return {
            msg:"这是组件的data中的msg信息"
        }
    },
    methods:{
        
    }
})
```



### 3 组件的切换

```js
/*方法1. 用 v-if 和 v-else来控制组件的切换,只能切换两个组件
如果要展示多个组件的切换,就不能用布尔值进行判断了,可用number值,但是判断时和麻烦,要一直用 v-else-if */
<div class="contain">
     <input type="button" value="登录" @click="flag = true">
     <input type="button" value="注册" @click="flag = false">
     <login v-if="flag"></login>
     <register v-else></register>
</div>
```

```js
/*方法2: Vue提供了 component 标签,是一个占位符,可以展示指定名称的组件*/
<div class="contain">
    <input type="button" value="登录" @click="componentId = 'login'">
    <input type="button" value="注册" @click="componentId = 'register'">
        
    <component :is="componentId">	        </component>
</div>
```

#### 返回上一页

```
this.$router.go(-1)
```



### 4 组件切换 - 切换动画

```js
//组件切换动画和单元素动画一样,都是将元素包裹在 transition 标签之中,再设置类样式实现,可以通过name属性设置类名前缀, 组件也一样,不过还有一个mode属性
//通过mode属性设置组件切换时的模式 out-in  或者 in-out
<transition mode="out-in">
	<component :is="comName"></component>
</transition>
```

### 5 组件的传值

父子组件中不能共享数据

#### 1 父组件向子组件传值

Prop 是你可以在组件上注册的一些自定义特性。  当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。

```js
//1 父组件引入子组件的时候通过属性绑定(v-bind:)的形式, 把需要传递给子组件的数据, 以属性绑定的形式,传递到子组件内部,供子组件使用
//2 子组件要把父组件传递过来的属性在子组件中的props中定义一下,才能使用
<div id="#app">
	<!-- 注意:这里的属性不能是驼峰命名,如果在props里面是驼峰,那么在绑定属性的时候,要用横线隔开,不要首字母大写 -->
	<com1 v-bind:parent-msg="msg"></com1>
</div>

var vm = new Vue({
	el:"#app",
	data:{
        msg:"这是父组件的数据"
	},
	methods:{},
    components:{
        com1:{
            template:"<h1> {{parentMsg}} </h1>",
        	data(){
            	return {}
        	},
        // props 这里面的数据都是父组件传递过来的数据 , 都是只读(单向下行绑定)的,不能重新赋值 , 就算重新赋值了,但是父组件里面的数据不会改变
       		 props:['parentMsg']
    	}
    }
})
```

props 中定义的数据都是单向下行的, 这是为了避免子组件中修改数据导致父组件或者其他子组件数据被篡改 , 所以vue中设计的时候就考虑了单向下行绑定 ; 

只能从父到子,父组件数据修改,所有子组件数据就自动修改,但是在子组件中修改数据,父组件和其他子组件数据不会修改

#### 2 父组件向子组件传递方法

```js
核心原理是:自定义事件  v-on 指令
<div id="#app">
	<!-- 注意:这里的属性不能是驼峰命名,如果在props里面是驼峰,那么在绑定属性的时候,要用横线隔开,不要首字母大写 -->
	<com1 @func="show"></com1>
</div>

<template id="tpl">
	<input type="button" value="点击,调用父组件的show方法,并将子组件的数据党参数传递过去" @click="myclick">
</template>
var vm = new Vue({
	el:"#app",
	data:{
        msg:"这是父组件的数据"
	},
	methods:{
        show(agr){
            console.log("这是父组件中的方法"---agr)
        }
	},
    components:{
        com1:{
            template:"#tpl"
        },
        data(){
            return {
            }
        },
        props:['parentMsg'],
        methods:{
            myclick(){
            	// this.$emit( ) 
                //这里调用父组件函数的时候还传递了参数,参数是子组件的数据,这就完成了子组件向父组件传值
                this.$emit('func',123)
            }
        }
    }
})
```

#### 3 子组件向父组件传值

核心原理: 自定义事件 v-on 指令绑定,将函数传递给子组件,子组件找个合适的时机触发事件并携带数据

1.先给子组件绑定事件, 'gotIt' 函数需要在父组件的 methods 中定义好

2.在子组件内部,某个时机调用 $emit()  方法触发父组件绑定的 foo 事件

​	$emit() 方法有多个参数: 

​		参数1: 要触发的事件名 ;   参数2及以后: 事件所需的参数



#### 4 父组件监听子组件和调用子组件的方法/值

  一个非常方便的v-ref，vue子组件用了定义模板组件功能，然后在父组件里定义一个HTML元素绑定这个子组件后才能在父组件通过这个HTML元素使用。 

```html
<!DOCTYPE html> 
<html lang="en"> 
<head> 
  <meta charset="UTF-8"> 
  <title>Document</title> 
  <script src="vue.js"></script> 
</head> 
<body> 
<div id="parent">  
  <input type="text" name="" id="" v-model="msg" /> 
  <input type="button" id="" value="dianji" @click="clickDt" /> 
  <user-profile ref="profile"></user-profile>  
</div>  
   
<script>  
  Vue.component('user-profile', {  
    template: '<span>{{ msg }}</span>',  
    data: function () {  
      return { 
        msg: 123 
      }; 
    },  
    methods: {  
      greet: function (msg) {  
        console.log(msg);  
      }  
    }  
   
  })  
//   var parent = new Vue({el: '#parent'});  
//   var child = parent.$refs.profile;  
//   child.greet();  
  new Vue({ 
    el:"#parent", 
    data:{ 
      msg:"" 
    }, 
    methods: { 
        clickDt(){ 
        this.$refs.profile.greet(this.msg); 
      } 
    } 
  }) 
</script>  
</body> 
</html>
```





### 6  ref--Vue中获取DOM元素和组件

ref : reference 引用

Vue在设计之初也考虑到了,很难完全避免DOM操作,只有在一些基础的业务处理上可以省去DOM操作,但是在一些特定场景下还是需要用到DOM操作,所以保留了一个 ref 的设计来获取DOM元素

这个方法也可以获取组件对象,那么在父组件也可以获取到子组件中的数据和方法

```js
<div id="app">
    <input type="text" v-model="msg">
    <input type="text" v-model="com">
    <input type="button" @click="getp" value="获取DOM元素内容和组件">
    <p ref="p">这是p标签的内容</p>
	<login ref="mylogin"></login>
</div>

/* 定义一个组件 */
var login = {
    template:"<p>登录</p>"
}
var vm = new Vue({
    el: '#app',
    data: {
         msg:"",
         com:""
    },
    methods: {
          getp(){
               console.log(this.$refs);
               //获取DOM元素的内容
               this.msg = "这是DOM中的内容: " + this.$refs.p.innerText
               //获取组件中的内容
               this.com = "这是组件中的内容: "+ this.$refs.mylogin.$el.innerText
           }
     },
     components:{
          login
     }
})
```



## 13 路由

前端路由 : 对于单页面应用程序SPA(single page application)来说 , 主要通过URL地址中的hash(#号) 来实现不同页面之间的切换, 同时 hash 有一个特点

后端路由 : 对于普通网站.所有的超链接都是URL地址,所有的URL地址都对应服务器上对应的资源

### 1 路由的基本使用

```js
//1. 在 vue.js 后面引入 vue-router.js
//2. 引入文件后,在window全局对象中就有了一个 路由的构造函数,叫做 VueRouter
//3. 创建路由对象
 var routerObj = new VueRouter({
     routes : [		//路由匹配规则
     	//每个路由规则,都是一个对象,这个规则对象身上,有两个必须的属性:
     	//属性1:  path  表示监听 哪个路由链接地址
     	//属性2: 是component , 表示路由是前面匹配到的path , 则展示 component 属性对应的那个组件
     	//注意: component的属性值,必须是一个组件的模板对象,不能是组件的引用名称
     	{path:'/', component: login},
         //上面访问根路径到了登录页面也可以,但是没有点击登录页面的样式了,所以使用路由重定向,
     	{path:'/', redirect: '/login'},
     	{path:'/login', component: login},
     	{path:'/register', component: register},
         
     ],
     linkActiveClass:"myActive"  //修改激活的类名,在mui或者bootstrap框架中自带了当前高亮的类名,将路由的高亮类名跟框架的高亮类名改成一样的,就不用自己写样式了
 })
 
//4.将创建的路由对象注册到vm实例上
	var vm = new Vue({
        el:"#app",
        data:{},
        router: routerObj
    }
    
//5. 在页面上展示 router-view 标签,就是一个占位符, 这个标签里面就是你的路由匹配到的组件
	<div id="app">
        /*<a href="#/login">登录</a>
        <a href="#/register">注册</a> */
        //vue-router还提供了专门的标签写路径,默认渲染成 a 标签 还可以用tag属性改变 , 另外还自带点击哪个就自动给哪个添加类名,可以轻松排他高亮
        <router-link to="/login"> 登录 </router-link>            
		<router-view></router-view>
	</div>

                     
//这里没有注册组件, 我之前注册组件是为了在模板中使用<login></login> 这样的方式使用
                     
//6. 要想切换组件的时候有动画,还是向之前的单元素一样
<transition>
     <router-view></router-view>  
</transition>
```



### 2 路由的传参

1 使用 `query` 在路由中使用查询字符串('/login?id=2') 传参,不用修改路由中的path属性 ;  用 this.$route.query 可以获取到参数,是一个对象 {id:2}

```js
// 1 定义路由
var router = new VueRouter({
    routes:[
        {path : '/login' , component : login},
        {path : '/register' , component : register},
    ]
})

/* 2 切换组件时携带参数*/
<router-link class="li-list" v-for="item in list" :key="item.id" tag="li" :to="'/detail?id='+item.id">
         <h4>标题: {{item.title}}</h4>
         <p>标题: {{item.content}}</p>
</router-link>

/* 3 接收参数 */
<template id="detailtpl">
     <!-- 1.使用 query 传参来接收参数 -->
     <h1>这是详情页---{{$route.query.id}}</h1>
</template>
```

2 使用 `params`传参,需要修改路由的匹配规则,严格按照此规则来定义路由,不然跳转不了 ; 用 this.$route.params 来获取传递过来的参数

```js
// 1 定义路由
var router = new VueRouter({
    routes:[
        {path : '/login' , component : login},
        {path : '/register/:id' , component : register},
    ]
})

/* 2 切换组件时携带参数*/
<router-link class="li-list" v-for="item in list" :key="item.id" tag="li" :to="'/detail/'+item.id">
         <h4>标题: {{item.title}}</h4>
         <p>标题: {{item.content}}</p>
</router-link>

/* 3 接收参数 */
<template id="detailtpl">
     <!-- 使用 params 传参来接收参数 -->
     <h1>这是详情页---{{$route.params.id}}</h1>
</template>
```

### 3 路由嵌套

```html

<div id="app">
    <!-- router-link 提供了专门的标签写路径,可以添加类名,自己写排他高亮的样式 -->
    <router-link to="/account">Account</router-link>
    <!-- 路由匹配到的组件会在下面的这个标签中展示出来 -->
    <router-view></router-view>
 </div>

<template id="tmpl">
    <div>
      <h1>这是 Account 组件</h1>

      <router-link to="/account/login">登录</router-link>
      <router-link to="/account/register">注册</router-link>

      <router-view></router-view>
	</div>
</template>
```

```js
/* 定义组件 */
var home = {
    template:"#tpl"
}
var login = {
    template:"<h3>这是登录组件</h3>"
}
var register = {
    template:"<h3>这是注册组件</h3>"
}

/* 配置路由 */
var router = new VueRouter({
    routes:[
        //定义父组件中的子组件的路由:
        {
            path:'/home' ,
            component: home , 
            //这里用children 属性实现子路由 注意这里的path值不要前面的 / ,否则会以根路径去请求 
            children : [
                { path:'login' , component: login},
                { path:'register' , component: register}  				//或者这样写也可以:
                { path:'/home/login' , component: login},
                { path:'/home/register' , component: register} 
            ]
        }
    ]
})
var vm = new Vue({
    el: '#app',
    data: {

    },

    /* 注册组件 */
    components:{
        home,
        login,
        register
    },
    /* 注册路由 */
    router
})
```





### 4 命名视图

一条路由显示多个组件,并安排每一个组件的位置

```js
//1. 定义路由
var router = new VueRouter({
    routes:[
    //在一条路由中,定义多个路由
        {path:'/', components:{
            'default' : header,
            'left' : leftBox,
            'main' : mainBox,
        }}
    ]
})

//2.挂载路由,定义路由
//3. 展示路由
	<div id="app">
	/* 如果不加name属性,就都是展示默认的组件,展示三个header组件 */
		<router-link></router-link>
		<router-link name="left"></router-link>
		<router-link name="main"></router-link>
	</div>
```







## 14.案例: todoMVC

https://todomvc.com/examples/vue/

```html
<!--1. vue中怎样动态渲染出input 的checked属性 ?
input 的 checked属性的值不管是为true还是false都是一样的,只要有值,就会有这个属性,就会选中,要用属性绑定来决定有没有这个属性,没有的话就不会选中 -->
<input type="checkbox" :checked="item.isDone">
<!-- item.isDone为true时就渲染出这个属性,否则就 不渲染这个属性 -->
```

## 15  watch   computed  methods

### 1 watch 监视数据的变化 

--> 是vm 实例中的属性 , 可以监视指定数据变化, 是一个对象,在对象中添加方法, 方法名就是要监视的数据(该数据必须存在, 可以是data中的数据, 也可是是vm实例上的数据例如:$route)

```js
var vm = new Vue({
    el:"#app",
    data:{
        msg:123
    },
    watch:{
        //方法名需要和监视数据同名,且监视的数据在data中定义了
        'msg':function( newVal , oldVal){
            console.log('这是新数据: ' + newVal)
            console.log('这是旧数据: ' + oldVal)
        }
    }
})
```

### 2 watch 监视路由的变化

--> 可以监视vm 实例上的数据 , 比如说 路由的  this.$route 这个对象

```js
var vm = new Vue({
    el:"#app",
    data:{
        msg:123
    },
    watch:{
    	//监听路由的改变
    	'$route.path':function(newVal , oldVal){
            if(newVal == '/login'){
                console.log('欢迎进入登录页面')
            } else if(newVal == '/register'){
                console.log('欢迎进入注册页面')
            }
    	}
    },    
})
```



### 3  computed  计算属性

```js
var vm = new Vue({
    el:"#app",
    data:{
        aa:11,
        bb:22,
        //msg:123
    },
    watch:{},
    computed:{
        //1 计算属性虽然看起来是一个方法,但是在引用的时候,一定不要用()去调用,直接把它当做普通属性使用
        //2 只要计算属性这个 function 内部,所用到的任何 data 中的数据发生了变化, 就会立即重新计算这个计算属性的值
        //3 计算属性的求值结果,会被直接缓存起来,方便下次直接使用,如果计算属性方法中的数据没有任何改变, 则不会对计算属性重新求值
        //4 这个计算属性默认是只读的,不能手动改变,毕竟是return回来的
        //5 在data中定义了的属性名, 在computed中不能定义重名属性,否则会冲突,报错
        'msg':function(){
            return this.aa + '-' + this.bb
        }
    }
}) 
```

### 4 watch  computed  methods  三者的区别

```js
//1. methods 表示一个具体的操作，主要内容为书写业务逻辑; 监听数据的本质是监听事件,而不是监听数据,要是不通过触发事件导致的数据改变,就监听不到了;
//2. watch 中监听的数据必须存在,要么在data中定义过,要么是$route这种挂载在 vm 实例上的数据
//3. computed 中监听的数据必须是data中不存在的,该function中必须有一个返回值,这个返回值就是计算结果,而且其计算结果会被缓存
//默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch
```



## 16 webpack--模块化工具

webpack 是前端的一个项目构建工具,它是基于 Node.js 开发出来的一个前端工具

### 1 安装 webpack  

```
npm i webpack -D  //安装到局部开发依赖环境
```

### 2 导入其他模块  import

```
import $ from 'jquery'
这是 es6 的语法, 浏览器可能不识别,有兼容性问题
```

### 3  用webpack 打包

```
webpack  源文件  --output  目标文件   webpack 版本4的写法
webpack  源文件  -o  目标文件
//可以把浏览器不支持的语法变成支持的语法,解决兼容性问题
此时的模式默认是 production 上线模式  ,文件都已经压缩;
还有另外一个模式 development 开发模式
要想设置开发模式,:
webpack  源文件  -o  目标文件 -d
或者在配置文件中直接设置 mode 为 development
//这样有缺点,只要文件一改变,就要重新打包
```

### 4 直接用webpack.config.js,不用手动指定入口和输出

```js
直接在项目根目录创建一个 webpack.config.js配置文件
在配置文件中:
	module.exports = {
        //手动指定入口和出口,路径要用path模块
        //entry 入口可以用相对路径或者绝对路径
        entry: path.join(__dirname,'./src/main.js'),
        // output 输出只能用绝对路径
        output:{
            path:path.join(__dirname,'./dist), //指定打包好的文件
            filename:'bundle.js'  //指定输出的文件的路径
        }
	}
配置完成后,再次修改项目之后,直接在终端运行 webpack 就可以自动刷新了,不用再手动指定入口和出口
```

### 5 webpack-dev-server  实现 实时编译打包

实现边改代码,实现实时刷新,不需要再在终端输入指令,直接打开浏览器刷新就行

```js
//使用 webpack-dev-server 这个工具,实现自动打包编译的功能
//运行 npm i webpack-dev-server -D 把这个工具安装到项目本地开发依赖,上线之后不用这个工具,如果是-S安装到本地就是上线之后也要用
//安装完之后,这个工具的用法和 webpack 命令的用法完全一样
//在终端输入 webpack-dev-server 报错,无法把它当做脚本命令.在终端中直接运行,(只有那些安装到 全局的工具 才能直接在终端中运行)
//所以需要在package.json 中的"scripts"节点下编写一些项目中用的脚本, "dev":"webpack-dev-server" , 之后运行 npm run dev就可以了
//webpack-dev-server 依赖于 webpack@^4.0.0,所以不管你之前有没有全局安装,项目中都要再安装一遍
```



注意: 此方式不需要全局安装webpack , 但是需要在每个项目中的开发依赖环境中安装 webpack 和 webpack-cli  , 都是 npm i xxx -D进行安装 , 而不是 npm i xxx -S    

### 6 总结webpack的使用

```js
//1. 一次性安装三个包: 
npm i webpack webpack-cli webpack-dev-server -D
//2. 在package.json的scripts节点下新建一个脚本:
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    //安装到项目中的包不同于全局安装的包可以直接在终端中运行,需要在package.json中写一些脚本之后才能运行
    "build": "webpack",
    "dev":"webpack-dev-server"
  }
//配置完之后, 在终端中运行 npm run dev  或者 npm run build 就行
//注意: 如果这里配置的是 "start" 就可以直接npm start 运行,就只有这一个比较特殊
```





第一次运行了devServer的时候,将入口文件打包编译,放在服务器根目录下与输出文件名同名的文件,所以在项目中引入时,也要引入服务器根目录下的输出文件,而不是物理磁盘中的文件

每次修改了webpack的配置文件 webpack.config.js ,或者是 package.json 之后,都要手动重新运行 npm run dev

### 7 webpack-dev-server的相关指令

设置运行命令之后自动打开浏览器,项目托管到3000端口 , 将src托管为项目根目录 , 设置热替换(不重新编译整个bundle.js,只是打补丁)

"dev":"webpack-dev-server --open --port 3000 --contentBase ./src --hot"

上面的关于devServer的指令都可以放在配置文件webpack.config.js 中,这是官方推荐的,这里面可以写注释(虽然麻烦,但是推荐这样做)

```js
const path = require("path")

//第二步,在配置文件最上面导入webpack模块
const webpack = require('webpack')

module.exports = {
    //手动指定入口和出口,路径要用path模块
    //entry 入口可以用相对路径或者绝对路径
    entry: path.join(__dirname,'./src/main.js'),
    // output 输出只能用绝对路径
    output:{
        path:path.join(__dirname,"./dist"), //指定打包好的文件
        filename:'bundle.js'  //指定输出的文件的路径
    },
    mode:"development",
    //在配置文件中配置devServer的指令
    devServer:{
        open:true,
        port:3002,
        contentBase:'./src',
        //配置热替换开启这里有三步
        //第一步:hot:true
        hot:true
        //第二步,在配置文件最上面导入webpack模块
        //第三步,在plugins节点中,创建热替换对象
    },
    //在plugins节点下创建插件对象,在webpack中装插件都是这个分数
    plugins:[
        //开启器热替换第三步,在plugins节点中,创建热替换对象
        new webpack.HotModuleReplacementPlugin()
    ]
}
```

### 8安装html-webpack-plugin

目前bundle.js已经托管到内存中了,但是index.html还是物理磁盘上的文件,而且每次还需要通过contentBase来指定托管的根目录,程序员还需要操心bundle.js的路径问题

下载插件 html-webpack-plugin,将物理磁盘上的HTML页面生成在内存中的HTML页面,并且将我们打包好的bundle.js文件在页面中自动引用了,所以程序员不需要再操心bundle.js的引用问题了,写HTML的时候不需要引用bundle.js同样可以实现js的效果

1.装包:

​	npm i html-webpack-plugin -D

2.在配置文件 webpack.config.js 中导入

```js
//导入html-webpack-plugin插件,再去plugins创建插件对象
const htmlWebpackPlugin = require('html-webpack-plugin') 

```

3.安装插件

```js
plugins:[
    //开启器热替换第三步,在plugins节点中,创建热替换对象
    new webpack.HotModuleReplacementPlugin(),
    //创建html-webpack-plugin插件对象
    new htmlWebpackPlugin({
    //创建一个内存中的html页面,其中会自动引入之前打包好放在内存中的bundle.js
    	template: path.join(__dirname,'./src/index.html'), //指定模板页面
    	filename:'index.html' //指定在内存中生成的页面的名称
    })
]
```



### 9 loader加载器

#### 1 加载css文件

当我们在项目中写css文件时,要引入到页面中,又碰到了与js文件引入一样的问题,为了减少css的二次请求,我们需要将css文件也进行打包,但是 webpack 默认只支持 JS 文件的打包,所以我们需要安装第三方loader加载器来打包css文件

1 在 main.js文件中导入css文件

```
import './css/index.css'
```

2 安装包:

```js
npm i style-loader css-loader -D
//css-loader是允许你将css文件进行编译,
//style-loader 用于将css代码用js动态创建style标签插入到index.html页面中,让其起作用,减少请求外部资源的次数
```

3 在 webpack.config.js配置文件中新增配置节点,叫module,它是一个对象,用于配置所有的第三方模块加载器, 这个对象里面有个rules 属性,是个数组,在这个数组中设置第三方模块的匹配规则 

```js
module:{
    rules:[
        /* use 使用 loader时,顺序是固定的从右到左的加载 */
        /* 所以这里的style-loader 和css-loader的顺序不能颠倒 */
        {test: /\.css$/,use:['style-loader','css-loader']}
    ]
}
```

 

#### 2 加载 less 文件

1 安装包:(两个,一个是less可以在项目中使用less,一个是less-loader可以让webpack对其进行编译)

```js
npm i less-loader less -D
```

2 在配置文件的module节点中的rules属性中匹配规则

```js
module:{
    rules:[
        /* 配置less文件 */
        {test: /\.less$/,use:['style-loader','css-loader','less-loader']}
    ]
}
```

#### 3 加载 scss 文件

sass文件与less文件作用一样,都是预处理语言,要注意的是,现在的sacc升级为scss后缀了,但是加载器的名字还是sacc

1 安装包:两个,一个是node-sacc可以在项目中使用sacc,一个是sacc-loader可以让webpack对其进行编译)

```js
npm i node-sass sass-loader -D
//这里下载的两个包用npm下载很难下载下来,建议用cnpm下载,之后就只能一直用cnpm下载了
```

2 在main.js中导入scss文件

```js
import './src/main.scss'
```

3 匹配规则

```js
module:{
    rules:[
        {test: /\.scss$/,use:['style-loader','css-loader','sass-loader']}
    ]
}
```



#### 4 加载图片和字体图标 url-loader 

在项目的css文件中设置背景图或者直接插入图片时报错,webpack不支持 jpg后缀名

直接加载图片又会有二次请求,用url-loader可以在图片大小在某个限度一下时,将图片转换成 base64 encodedURL --二进制;  并将图片放在了服务器的根目录下,并对图片重新命名了

1 安装包(url-loader中依赖到了 file-loader)

```js
npm i url-loader file-loader -D
```

2 匹配图片规则

```js
module:{
    rules:[
        {
    		test : /\.(png|jpg|gif|bmp|jpeg)$/,
    		use:[
        		{
        			loader:'url-loader',
        			options:{
                		limit:81920 //限制图片大小为81920字节,也就是80kb,在这个大小以内的图片会被转化为二进制字符--base64
        			}
        		}
    		]
		}
    ]
}
```

3 匹配字体图标规则

```
import 'bootstrap/dist/css/bootstrap.css'
{
	//这里的后缀是bootstrap中的字体图标的后缀
    test : /\.(eot|svg|ttf|woff|woff2)$/,
    use:[
        {
        	loader:'url-loader'
        }
    ]
}
```

### 10 转义工具 babel

在webpack中,默认只能处理一部分 ES6 的新语法.一些更高级的ES6语法或者ES7的语法,webpack是处理不了的,这时候,需要借助于第三方的loader 来帮助 webpack 出路这些高级的语法,当第三方 loader把高级语法转换为低级的语法之后,会把结果交给webpack去打包到 bundle.js中

通过 Babel , 可以帮助我们将高级的语法转换为低级的语法 , 为了浏览器的兼容性

```js
//1. 在webpack中,运行一下指令:安装核心包和loader,去安装Babel相关的loader功能 ; 由于babel7目前还有很多问题, 所以选择 babel6
//1.1  cnpm i babel-core babel-loader@7 -D
//1.2  cnpm i babel-preset-stage-0 -D

//2. 打开webpack中的配置文件,在module节点下的rules数组中,添加一个新的匹配规则:
//2.1  {test:/\.js$/,  use:'babel-loader',exclude:/node_modules/,loader:'babel-loader'}

//3 配置 babel
//3.1 安装语法包:
	cnpm i babel-preset-env -D
//3.2 创建babel配置文件 ,在项目根目录创建 .babelrc 文件
{
    "presets": ["env", "stage-0"]
}


//3.3 在配置文件中匹配规则
{ test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }, // 配置 Babel 来转换高级的ES语法

```



### 11 在webpack构建的项目中使用 vue 框架

1.安装包  vue

cnpm i vue -S

2.由于在webpack中推荐使用 .vue 这个组件模板文件定义组件.所以,需要安装 能解析这种文件的loader , 由于vue-loader 这个包需要依赖 vue-template-compiler 这个包,所以需要下载两个包

cnpm i vue-loader vue-tempalte-compiler -D



配置 vue-loader  并安装 VueLoaderPlugin 插件

3.在main.js中导入 vue 模块, 

import Vue from 'vue'

4.定义一个 .vue结尾的组件,其中,组件有三个部分组成 : template  , script,  style

5.使用 import login from './login.vue' 导入这个组件

6.创建 vm 实例, var vm = new Vue({el:"#app",render:c=>c(login)})

7.在页面中创建一个id为app的div元素,作为我们vm实例要控制的区域

12 CommonJS 与 ES6 模块化规范

1. CommonJS 模块化规范的导入和导出:

   + 导入:  require
   + 导出: module.exports={}

2. ES6 模块化规范的导入和导出

   + 导出: export const name="张三" 
   + 导入: import {name} from './test.js'     

   或者:

   + 导出: export default {name:"zs"}
   + 导入: import info from './test.js'  

  

**注意:**

```

```

webpack中的路由

### 12 vue-cli  脚手架

是由Vue官方提供的一键生成的webpack工程化模板项目

目前最新的版本是v3.0 , 18年8月份发布的正式版

```js
//1. 全局安装 vue-cli 
npm i vue-cli -g
//接下来可以在某个文件夹下面打开命令窗口,可以用vue来查看相关命令
//2. 执行 vue-init 初始化创建一个项目vue-cli-demo
vue init webpack vue-cli-demo
//3. 配置项目,回车3次,第四次选择下面面的runtime-only模式回车;之后都选 y n n n n 
//4.当配置好之后会立即开始使用npm装包, 但是用npm 装包速度会很慢,所以自己用 cnpm i  来装包,注意装包前自己切换一下路径,但是用cnpm装包可能会有问题,还是用npm装包保险
//5. 使用 npm run dev 运行项目
```

### 13 使用mint-ui组件

mint-ui是基于vue封装的组件,这一点与bootstrap,Mui彻底不同

在main.js中安装所有的mint-ui中的组件

```
npm install mint-ui -S

// 引入全部组件 在main.js中引用
import Mint from 'mint-ui'
import 'mint-ui/lib/style.css'
Vue.use(Mint)
```

按需引入

```
//1.借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。
npm install babel-plugin-component -D
//2.然后，将 .babelrc 修改为：
{
  "presets": [
    ["es2015", { "modules": false }]
  ],
  "plugins": [["component", [
    {
      "libraryName": "mint-ui",
      "style": true
    }
  ]]]
}
```

使用mint-ui中的js功能片段,需要在要使用该功能的组件中的script标签中引入该组件对象,例如在 App.vue中使用Toast提示功能 ; 而不是在main.js中引入

```
<script>
import { Toast } from 'mint-ui'
export default {
  name: 'App',
  methods:{
    dian(){
      Toast('提示')
    }
  }
}
</script>
```

### 14 this.$nextTick

在vue中

在下次DOM更新循环结束之后执行延迟回调,在修改数据之后立即执行这个方法,获取到最新的DOM

使用better-scroll时需要在mounted中使用这个回调,在这个回调中初始化better-scroll , 但是这个的体验没有vue-scroller的体验好



### 15 Element-UI

```
npm i element-ui -S
//在main.js中导入
import ElementUI from 'element-ui'
import from '.../'
Vue.use(ElementUI)
```

完成登录页面布局之后,开始实现登录功能

### 16 vue-cli@3

我们学的是2.9的版本 , 3就是把webpack的配置都隐藏起来了



如果已经安装了旧版本的vue-cli就要先卸载,否则会冲突,而且3.0版本的名字改为了@vue/cli

```
npm i @vue/cli -g  /  yarn global add @vue/cli
vue create 项目名称  
选择下面的手动选择
选择 babel Router Vuex CssPre-processors 再回车
是否使用历史模式使用路由?  no
选择css预处理器   :   Less
这些配置文件放在哪里?  选择第一个,放在专用的配置文件中
是否帮你把这些配置都保存起来,以后生成项目自动选择这些选择? no
选择装包的工具  npm
安装完之后,本地仓库已经帮我们创建好了,而且已经帮我们提交了一次,所以我们只需要添加夜歌远程仓库,然后将远程仓库和本地仓库联系起来,就可以直接git push 
```

```
或者用图形化界面创建项目
在命令窗口输入: 
vue ui
```

项目创建好之后,首先把不需要的组件,路由都删掉,在处理一下 css reset , 在main.js中导入common.css文件

### 17 登录状态保持

http是无状态的协议,每一次通信都是基于请求-响应 ; 每一次通信都是完全独立的,上一次的状态不会保留 , 就算登录成功了,只要一刷新就又要重新登录

有状态的例子就是:语音助手 , 它会联系上下文来回复你的话

session 和 cookie 就是为了解决这个问题出现的 , 利用cookie的特性 , 在内存中开辟一块空间,将session_id存储到浏览器,

```js
之前的登录业务:
//1.浏览器捕获用户输入的账号密码(表单校验)
//2.将用户输入的账号信息发送给服务器(post请求)
//3.服务器收到客户端提交过来的数据
//4.对账号密码进行校验(判断是否登录成功)
//5.登录成功后,将用户信息存储到session 中,同时将sessionID以cookie形式携带给浏览器
//6.客户端收到服务器响应的数据后,做出相应的处理(显示个人信息等),由于响应了cookie过来,所以浏览器会自动存储sessionID,将来每次向这个风气发送请求时,都会自动携带相关信息(sessionID)
//7.将来服务器收到客户端请求时,如果有携带sessionID, 就会自动取出相应的存储信息
```

上面的原理有一些弊端

```js
//如果要采用前端渲染,一般都会设计成前后端分离的模式,而且为了让前后端彻底分离,并且实现前端模块化
//一般情况下,前后端通信都是通过接口进行
//此时一般会有跨域的问题,跨域一般直接通过CORS解决了
//但是,session 和 cookie不能跨域
//此时出现了一个更好的一个解决方案: JWT : JSON Web Token
```

session 和 JWT 的区别和优缺点:

```

```

所以新的登录状态保持业务逻辑是:

```js
//1.浏览器捕获用户输入的账号密码(表单校验)
//2.将用户输入的账号信息发送给服务器(post请求)
//3.服务器收到客户端提交过来的数据
//4.对账号密码进行校验(判断是否登录成功)
//5.登录成功后,在服务器生成一个 token ,将token存储在数据库中,与当前用户进行绑定,将token和登录成功的信息的携带返回给客户端
//6.客户端收到token后,将token存储到localStorage中
//7.将来如果要获取一些需要登录的信息(例如当前用户的订单信息),此时只需要将token从localStorage中取出来并携带给服务器即可获取
//8.将来服务器收到这些需要登录才能获取信息的请求后,会对token进行校验,从而获取到当前的用户信息,根据用户返回对应的订单信息
```

总结:

```js
前端要做的事:
//1.点击登录按钮进行变淡校验
//2.将用户信息提交给服务器
//3.服务器返回token和当前用户信息,将其存储到localStorage中
//4.提醒用户登录成功,并跳转到首页
```



### 18 axios基础

vue-resource 和 axios 的区别 :

```js
vue-resource:
1.体积小
vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。
2.支持主流的浏览器
和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。
3.支持Promise API和URI Templates
Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。
URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。
4.支持拦截器
拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。
拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。
```



```js
axios: 基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 Node.js 中使用。
1、在浏览器中发送 XMLHttpRequests 请求
2、在 node.js 中发送 http请求
3、支持 Promise API
4、拦截请求和响应
5、转换请求和响应数据
6、取消请求
7、自动转换 JSON 数据
8、客户端支持保护安全免受 CSRF/XSRF 攻击
```

axios 的使用:

```js
npm i axios -S
//在哪个组件中使用,就在哪个里面导入,不用在main.js中导入,是一个完全独立的库
import axios from 'axios'
//axios.post(url , 携带的参数).then().catch()
axios.post(url , {username:'zs' , password:'123456'}).then().catch()

//如果想在很多组件中使用axios,但是不想在每个组件中导入,可以在main.js中设置:将axios挂载到全局中
import axios from 'axios'
Vue.prototype.$http = 'axios'
//这样的话,之后的请求就和vue-resource 一样了
```

退出登录,此时将本地缓存中的token 和用户信息删除,并跳转到登录页

登录拦截: 直接在地址栏输入想跳转页面,如果没有登录的话,需要拦截下来,让它去登录 , 以前都是后端人员做,但是用了token之后,前端就可以做了 , 使用路由的导航守卫

### 19 路由的高级应用 - 导航守卫

"导航"表示路由正在改变 ; `vue-router` 提供的导航守卫主要用来通过跳转或取消的方式守卫导航 

全局前置守卫 --- 路由跳转之前的钩子函数(在main.js中配置)

业务需求: 

1 登录状态拦截 : 如果已经登录了,再次访问登录页时就直接跳转到'/home' , 不再对此用户显示登录页

2 未登录状态拦截 : 如果还没有登录 , 就不能访问某些需要登录状态的页面,让它跳转到登录页登录 , 所以如果没有登录状态要访问登录页的时候,要允许访问

注意:这里的登录状态判断是根据本地缓存中是否有token

```js
//由于在router.js中已经对外暴露出了 router对象,所以可以直接使用
router.beforeEach((to, from, next) => {
  // to 是要跳转的路由 , from是原来的路由 , next方法是允许路由跳转,是一个方法,如果不调用这个方法的话,就跳转不了
  let token = localStorage.getItem('token') || ''
  //登录状态拦截
  if(token && to.path === '/signIn'){
      next('/home')
      return	// 不再进行下面的未登录状态拦截的判断
  }
   //未登录状态的拦截
    if(token || to.path == '/signIn'){
        next()
    } else{
        next('/signIn')
    }
})
```



### 20 axios高级应用

1 全局的axios的默认值(设置请求根路径) (在main.js中设置)

axios.defaults.baseURL = "http://www:8899/v1"

2 拦截器  (在main.js中设置)

请求拦截器 : 在请求发送之前做些什么

在发送请求之前全都设置一个请求头,还可以添加参数...

```
axios.interceptors.request.use(function(config){
    let token = localStorage.getItem('token') || ''
    config.headers.Authorization = token
    return config
},function(err){	
	//对请求错误做些什么
    return Promise.reject(error);
})
```

响应拦截器 : 在收到数据之后,先对数据做些什么

```
axios.interceptors.response.use(function(response){
	// 对响应数据做点什么
    return response;
},function(error){	
	//发生错误时调用 ,每次请求发生错误的时候,就提示用户错误 , 这里配置了一次之后,就不用每次请求之后就catch错误了
	//注意,$message 是在 Vue的原型身上,这里的this是指向window
    Vue.prototype.$message({
        type:"error"
        message:error.response.data.errMsg
    })
})
```



### 19 Vuex的模块化







### 21 上拉加载和下拉刷新 vue-scroller

```js
npm i vue-scroller -S
//在main.js中配置
import VueScroller from 'vue-scroller'
Vue.use(VueScroller)
//将整个需要进行滑动的页面全都放在下面这个标签中
<scroller 
  :on-refresh="refresh"
  :on-infinite="infinite">
  <!-- content goes here -->
</scroller>
```

先修改样式,让很高的那个盒子在页面上正确显示 , 要把style中的scoped去掉

在scroller 上加上 ref 属性 , 方便获取这个组件的实例,才能调用这个实例上的方法 , 比如停止下拉刷新和上拉加载 ; 还可以添加refreshText="用点力拉啊"   noDataText="没有更多数据了"  这两个属性

在 methods中定义好 refresh 和 infinite 这两个方法

```
//最开始就有获取商品列表的方法 , 要先在created中调用一次
//要将原来的改造一下,刷新和加载更多的时候都要调用这个方法,区别在于 , 刷新只需要将pageIndex初始化为1,让 goodsList 被重新赋值就行 ; 而加载更多是要让pageIndex++ , 而且 goodsList 也要将原来的拼接起来
//所以在这个方法中传入一个 refresh 参数 , 先判断一下 , 如果是true的话,就表示刷新操作
getGoodsList(refresh){
	return this.$http.get('api/getgoods?pageindex='+this.pageIndex)
	.then(result=>{
		if(refresh){    //如果是上拉刷新的话,就不拼接了
			//点击加载更多的时候,要将之前的数据拼接到一起,而不是覆盖
			console.log("下拉刷新");
			this.goodsList = result.body.message
		} else{ //如果是加载更多时获取数据,就要拼接
			console.log("上拉加载",this.goodsList)
			this.goodsList = this.goodsList.concat(result.body.message)
		}
	})
}
```



```
refresh(){  //下拉刷新
	setTimeout(()=>{
		//下拉刷新,就是重新加载列表页,而且只加载第一页
		this.pageIndex = 1
		//重新请求数据,成功后,结束下拉刷新finishPullToRefresh  但这个这个scroller组件的实例的方法,并不是这个页面组件的方法,所以要先获取这个scroller组件,用$refs
		//这里调用getGoodsList的方法的时候,只获取第一页,不用拼接,所以传入true
		this.getGoodsList(true).then(()=>this.$refs.sc.finishPullToRefresh())
	},2000)
}
```



```
infinite(){ //上拉加载
	setTimeout(()=>{
		this.pageIndex++			
		this.getGoodsList().then(()=>
			this.$refs.sc.finishInfinite(this.goodsList.length === 15))
	},2000)
}
```



```
mounted(){
	//手动下拉刷新
	this.$refs.sc.triggerPullToRefresh()
},
```



# 微信小程序

## 绑定事件

1 key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在非原生组件中，bind和catch后可以紧跟一个冒号，其含义不变，如bind:tap、catch:touchstart。
2 value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。
3 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。

# 前端面试题

## 1.CSS实现垂直水平居

```css
CSS实现垂直水平居中:

一道经典的问题，实现方法有很多种，以下是其中一种实现：

HTML结构：

<div class="wrapper">

     <div class="content"></div>

</div>

CSS：

.wrapper {

    position: relative;

    width: 500px;

    height: 500px;

    border: 1px solid red; 

 }

.content{

    position: absolute;

    width: 200px;

    height: 200px;

    /top、bottom、left和right 均设置为0/

    top: 0;

    bottom: 0;

    left: 0;

    right: 0;

    /margin设置为auto/

    margin:auto;

    border: 1px solid green;    

} 

```



## 2.三个盒子，左右定宽，中间自适应有几种方法





```css
三个盒子，左右定宽，中间自适应有几种方法

第一种：左右侧采用浮动 中间采用margin-left 和 margin-right 方法。

代码如下：(中间的盒子一定要放在最下面写,否则两边的盒子会有一个掉下来)

<div style="width:100%; margin:0 auto;"> 

 

       <div style="width:200px; float:right; background-color:#960">这是右侧的内容 固定宽度</div>

 

       <div style="width:150px; float:left; background:#6FF">这是左侧的内容 固定宽度</div>

 

       <div style="margin-left:150px;margin-right:200px; background-color:#9F3">中间内容，自适应宽度</div>

</div>


第二种: 用flex进行弹性盒子设置,父盒子设置弹性布局:dispaly:flex;
左右盒子设置宽度,中间盒子设置flex:1;

第三种: 左右盒子设置固定宽度,然后定位到父盒子的左右两边,中间盒子设置width:100%, 再设置padding-left和padding-right

```









## 3.数组的常用方法



```javascript
Array 数组的常用方法
concat() 连接两个或更多的数组，并返回结果。
join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
pop() 删除并返回数组的最后一个元素。  
shift() 删除并返回数组的第一个元素
push() 向数组的末尾添加一个或更多元素，并返回新的长度。
unshift() 向数组的开头添加一个或更多元素，并返回新的长度。
reverse() 颠倒数组中元素的顺序。
slice() 从某个已有的数组返回选定的元素
sort() 对数组的元素进行排序
splice() 删除元素，并向数组添加新元素。从哪个索引开始,删除几个,要添加到数组的元素
toString() 把数组转换为字符串，并返回结果。
```

## 4.编写一个方法 去掉一个数组的重复元素

```javascript
编写一个方法 去掉一个数组的重复元素
方法一：
var arr = [0,2,3,4,4,0,2];
var obj = {};
var tmp = [];
for(var i = 0 ;i< arr.length;i++){
   if( !obj[arr[i]] ){
      obj[arr[i]] = 1;
      tmp.push(arr[i]);
   }
}
console.log(tmp);
```

## 5.怎样添加、移除、移动、复制、创建和查找节点？

```javascript
怎样添加、移除、移动、复制、创建和查找节点？

 1）创建新节点

　　createDocumentFragment() //创建一个DOM片段

　　createElement() //创建一个具体的元素

　　createTextNode() //创建一个文本节点

2）添加、移除、替换、插入
　　appendChild() //添加
　　removeChild() //移除
　　replaceChild() //替换
　　insertBefore() //插入

3）查找
　　getElementsByTagName() //通过标签名称
　　getElementsByName() //通过元素的Name属性的值
   getElementById() //通过元素Id，唯一性
   getElementByClassName() //通过元素类名
   querySelector()	//查询选择器,返回查找到的第一个元素
	querySelectorAll()	//查询选择器,返回查找到元素组成的数组

写出3个使用this的典型应用

（1）、在html元素事件属性中使用，如：

<input type=”button” onclick=”showInfo(this);” value=”点击一下”/>

（2）、构造函数

function Animal(name, color) {
　　this.name = name;
　　this.color = color;
}

（3）、input点击，获取值

<input type="button" id="text" value="点击一下" />
<script type="text/javascript">
    var btn = document.getElementById("text");
    btn.onclick = function() {
        alert(this.value);    //此处的this是按钮元素
    }
</script>

(4)、apply()/call()求数组最值

var  numbers = [5, 458 , 120 , -215 ]; 
var  maxInNumbers = Math.max.apply(this, numbers);  
console.log(maxInNumbers);  // 458
var maxInNumbers = Math.max.call(this,5, 458 , 120 , -215); 
console.log(maxInNumbers);  // 458

```





## 6.new操作符到底到了什么?



------

```javascript
new操作符到底到了什么?

先看代码

[javascript] view plain copy

1. var Func=function(){  
2. };  
3. var func=new Func ();  

new共经过了4几个阶段

1、创建一个空对象

[javascript] view plain copy

1. var obj=new Object();  

2、设置原型链

[javascript] view plain copy

1. obj.proto= Func.prototype;  

3、让Func中的this指向obj，并执行Func的函数体。

[javascript] view plain copy

1. var result =Func.call(obj);  

4、判断Func的返回值类型：

如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。

[javascript] view plain copy

1. if (typeof(result) == "object"){  
2. func=result;  
3. }  
4. else{  
5. func=obj;;  
6. }  

```



## 7 js 定义函数的几种方法 以及如何调用



```javascript
/*1.方法调用模式：
    先定义一个对象，然后在对象的属性中定义方法，通过myobject.property来执行方法，this即指当前的myobject 
    对象。*/
        var car = {
            carId:123,
            carName:"奥迪",
            carColor:"red",
            say:function(){
                console.log(this.carName+" color is "+this.carColor);
            }
        };
        car.say();

    /*2.函数调用模式
    定义一个函数，设置一个变量名保存函数，这时this指向到window对象。*/
        var mycar = function(name,color){
        　　return "my car is " +color+" and "+name ;
        }
        console.log(mycar("奥迪","红色"));

    /*3.构造器调用模式
    定义一个函数对象，在对象中定义属性，在其原型对象中定义方法。在使用prototype的方法时，必须实例化该对象才能调用其方法。*/
        var yourcar = function(name,color){
            this.name = name;
            this.color = color;
        };
        yourcar.prototype ={
            say:function(){
                console.log("your car is " +this.name + " and " +this.color);
            }
        };
        var yourcar = new yourcar("奔驰","蓝色");
        yourcar.say();

    /*4.apply,call调用模式*/
        function count(num1, num2) { 
            return num1 + num2; 
        } 
        console.log(count.call(window, 10, 10)); //20 
        console.log(count.apply(window,[10,20])); //30

        window.a=100;
        window.b=300;
        var myobject={a:40,b:50};
        var sum = function(){
        　　return this.a+this.b;
        };
        var sum1 = sum.call(window); 
        // var sum2 = sum.call(myobject);
        var sum2 = sum.apply(myobject); 
        console.log(sum1+"========="+sum2);

        // 发现apply()和call()的真正用武之地是能够扩充函数赖以运行的作用域，如果我们想用传统的方法实现
        window.a=100;
        window.b=300;
        var myobject={a:40,b:50};
        function sum(){
            console.log(this.a+this.b);
        }
        console.log(sum());
        myobject.sumnumber = sum;
        console.log(myobject.sumnumber());

        window.color = "red"; 
        var o = { color: "blue" }; 
        function sayColor(){ 
            console.log(this.color); 
        } 
        sayColor();
        var OSayColor = sayColor.bind(o); 
        OSayColor(); //blue
```

 

## 8 JS对象创建的几种方式整理



```javascript
#第一种：Object构造函数创建

var Person = new Object();
Person.name = 'Nike';
Person.age = 29;

这行代码创建了Object引用类型的一个新实例，然后把实例保存在变量Person中。

#第二种：使用对象字面量表示法

var Person = {};//相当于var Person = new Object();
var Person = {
 name:'Nike';
 age:29;  
}

对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同

在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。

#第三种：使用工厂模式创建对象

function createPerson(name,age,job){
 var o = new Object();
 o.name = name;
 o.age = age;
 o.job = job;
 o.sayName = function(){
  alert(this.name); 
 };
 return o; 
}
var person1 = createPerson('Nike',29,'teacher');
var person2 = createPerson('Arvin',20,'student');

在使用工厂模式创建对象的时候，我们都可以注意到，在createPerson函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。

#第四种:使用构造函数创建对象

function Person(name,age,job){
 this.name = name;
 this.age = age;
 this.job = job;
 this.sayName = function(){
 alert(this.name);
 }; 
}
var person1 = new Person('Nike',29,'teacher');
var person2 = new Person('Arvin',20,'student');


对比工厂模式，我们可以发现以下区别：

1.没有显示地创建对象

2.直接将属性和方法赋给了this对象

3.没有return语句

4.终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符，我们来进行自主检测：

?

同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。



```



## 9 对象的几种常用操作方法？



```javascript
#查找对象中的属性和方法,先for in 遍历对象,用obj.key
#for-in循环遍历对象属性语法：

for (var key in object) {
    code to be executed
}
　#添加属性

person.nationality = "English";
　　但你不能用保留字作为属性名，利用js命名规则。

#删除属性



var person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
delete person.age;   // or delete person["age"]

#给对象添加属性和方法

有时你想添加新属性或方法给一个存在的对象，给所有给定类型的存在对象，或者给一个对象原型。

myFather.nationality = "English";//给一个存在的对象，仅仅对此对象
 
myFather.name = function () {
    return this.firstName + " " + this.lastName;
};//添加一个方法，仅仅对此对象
```



## 10.ajax过程



```javascript
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.
```



## 11.写出一个简单的$.ajax()的请求方式？



------

```javascript
写出一个简单的$.ajax()的请求方式？

$.ajax({

    url:'http://www.baidu.com',

    type:'POST',

    data:data,

    cache:true,

    headers:{},

    beforeSend：function(){},

    success:function(){},

    error:function(){},

    complete:function(){}

}); 



```



## 12.jquery中.get()提交和.post()提交有区别吗？



```javascript
 jquery中.get()提交和.post()提交有区别吗？

相同点：都是异步请求的方式来获取服务端的数据；

异同点：

1、请求方式不同：.get() 方法使用GET方法来进行异步请求的。.post() 方法使用POST方法来进行异步请求的。

2、参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。

3、数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多

4、安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。

```



## 13.什么是跨域？跨域请求资源的方法有哪些？

  

```javascript
什么是跨域？跨域请求资源的方法有哪些？

1、什么是跨域？

由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：

网络协议不同，如http协议访问https协议。

端口不同，如80端口访问8080端口。

域名不同，如qianduanblog.com访问baidu.com。

子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。

域名和域名对应ip,如www.a.com访问20.205.28.90.

2、跨域请求资源的方法：

(1)、porxy代理

定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。

实现方法：通过nginx代理；

注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。

(2)、CORS 【Cross-Origin Resource Sharing】

定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。

使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：

res.writeHead(200, {

    "Content-Type": "text/html; charset=UTF-8",

    "Access-Control-Allow-Origin":'http://localhost',

    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',

    'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'

});

(3)、jsonp
本质是函数的调用,前端定义一个函数,后端返回一个参数,
定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。

特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。

实例如下：

<script>

    function testjsonp(data) {

       console.log(data.name); // 获取返回的结果

    }

</script>

<script>

    var _script = document.createElement('script');

    _script.type = "text/javascript";

    _script.src = "http://localhost:8888/jsonp?callback=testjsonp";

    document.head.appendChild(_script);

</script>

缺点：

　　1、这种方式无法发送post请求（这里）

    2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。


```



## 14.Ajax的优缺点及工作原理？



```javascript
Ajax的优缺点及工作原理？

定义和用法:

AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。

传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。

优点：

1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求

2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验

3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离

缺点：

1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.

2.AJAX只是局部刷新,所以页面的后退按钮是没有用的.

3.对流媒体还有移动设备的支持不是太好等

AJAX的工作原理：

1.创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）

2.判断数据传输方式(GET/POST)

3.打开链接 open()

4.发送 send()

5.当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数

```

##  

## 15.如何理解闭包？



```html
如何理解闭包？

1、定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。

2、表现形式：使函数外部能够调用函数内部定义的变量。

3、实例如下：

(1)、根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count 。

var count=10;   //全局作用域 标记为flag1

function add(){

    var count=0;    //函数全局作用域 标记为flag2

    return function(){

        count+=1;   //函数的内部作用域

        alert(count);

    }

}

var s = add()

s();//输出1

s();//输出2

4、变量的作用域

要理解闭包，首先必须理解Javascript特殊的变量作用域。

变量的作用域分类：全局变量和局部变量。

特点：

1、函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。

2、函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

 5、使用闭包的注意点

1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

 
 
```





## 16.sessionStorage 、localStorage 和 cookie 之间的区别



```
 9、sessionStorage 、localStorage 和 cookie 之间的区别

 共同点：用于浏览器端存储的缓存数据

不同点：

(1)、存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；

        web storage,会将数据保存到本地，不会造成宽带浪费；

(2)、数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;

(3)、数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；

        sessionStorage,仅在关闭浏览器之前有效；localStorage,数据存储永久有效；

(4)、作用域不同：cookie和localStorage是在同源同窗口中都是共享的；sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；

```



------

## 15.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？



```
* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

* 拖拽释放(Drag and drop) API 
  语义化更好的内容标签（header,nav,footer,aside,article,section）
  音频、视频API(audio,video)
  画布(Canvas) API
  地理(Geolocation) API
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除

  表单控件，calendar、date、time、email、url、search  
  新的技术webworker, websocket, Geolocation

* 移除的元素

纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；

支持HTML5新标签：

* IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，

  浏览器支持新标签后，还需要添加标签默认的样式：

* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
   <!--[if lt IE 9]> 
   <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script> 
   <![endif]--> 
如何区分： DOCTYPE声明\新增的结构元素\功能元素
```

## 16.js操作获取和设置cookie



```
//创建cookie
function setCookie(name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value);
    if (expires instanceof Date) {
        cookieText += '; expires=' + expires;
    }
    if (path) {
        cookieText += '; expires=' + expires;
    }
    if (domain) {
        cookieText += '; domain=' + domain;
    }
    if (secure) {
        cookieText += '; secure';
    }
    document.cookie = cookieText;
}

//获取cookie
function getCookie(name) {
    var cookieName = encodeURIComponent(name) + '=';
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieValue = null;
    if (cookieStart > -1) {
        var cookieEnd = document.cookie.indexOf(';', cookieStart);
        if (cookieEnd == -1) {
            cookieEnd = document.cookie.length;
        }
```



## 17.js 中的深拷贝跟浅拷贝



```javascript
在js中，我们经常复制一个对象，复制数据，那么就会有人问了，怎么复制，今天鹏哥就带来js中的复制方法。

JS中对象分为基本类型和复合（引用）类型，基本类型存放在栈内存，复合（引用）类型存放在堆内存。

堆内存用于存放由new创建的对象，栈内存存放一些基本类型的变量和对象的引用变量。

至于堆内存和栈内存的区别介绍，你们可以百度看看。

下面开始讲解复制：

这种只是简单的变量，内存小，我们直接复制不会发生引用。

    var a=123;
    var b=a;
    a=123456;
    alert(a); //123456
    alert(b); //123
    
    //或者是
    
    var a='afafas';
    var b=a;
    a='fgfdsdsgs';
    alert(a); //fgfdsdsgs
    alert(b); //afafas

而对于对象这种内存占用比较大的来说，直接让复制的东西等于要复制的，那么就会发生引用，因为这种复制，只是将复制出来的东西的指向指向了要复制的那个东西，简单的说，就是两个都同时指向了一个空间，如果改变其中一个，另一个也会发生变化。这就发生了引用。

引用只发生在对象的身上：

    var arr1=[1,2,3];
    var arr2=arr1;
    arr1.push(4);
    alert(arr1); //1234
    alert(arr2); //1234
    arr2.push(5);
    alert(arr1); //12345
    alert(arr2); //12345


所谓的浅复制，只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”。

而深复制的话，我们要求复制一个复杂的对象，那么我们就以利用递归的思想来做，及省性能，又不会发生引用。



# 解决方案深拷贝,浅拷贝

两种方法实现深拷贝（深复制）

（1）方法一：兼容性好,请仔细看代码（网上大部分代码有Bug）

（2）方法二：需要对象满足JSON数据格式。JOSN数据格式：http://www.cnblogs.com/mengfangui/p/8257269.html

（3）使用类库，如lodash的_.cloneDeep(value)方法。

 

2、代码

复制代码
<!DOCTYPE html>
<html lang="zh">

    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>JavaScript实现深拷贝（深复制）</title>
    </head>

    <body>

        <script>
            var obj = {
                name: null,
                age: 10
            }
            //方法一：兼容性好
            function deepClone(obj) {
                var o = obj instanceof Array ? [] : {};
                for(var k in obj) {
                    //有bug（属性的值为null时）
                    //o[k] = typeof obj[k] === 'object'?deepClone(obj[k]):obj[k];
                    if(typeof obj[k] === 'object' && obj[k] != undefined) {
                        o[k] = deepClone(obj[k]);
                    } else if(typeof obj[k] === 'object' && obj[k] == undefined) {
                        o[k] = null;
                    } else {
                        o[k] = obj[k];
                    }
                }
                return o;
            }
            //方法二：只能处理符合JSON格式的对象
            function deepClone2(obj) {
                return JSON.parse(JSON.stringify(obj))
            }
            console.log(deepClone(obj));
            console.log(deepClone2(obj));
        </script>
    </body>

</html>
复制代码

 3、浅拷贝；
Object.assign()函数






```

## 18.网站重构的理解？



```
网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。

对于传统的网站来说重构通常是：

表格(table)布局改为DIV+CSS
使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)
对于移动平台的优化
针对于SEO进行优化
深层次的网站重构应该考虑的方面

减少代码间的耦合
让代码保持弹性
严格按规范编写代码
设计可扩展的API
代替旧有的框架、语言(如VB)
增强用户体验
通常来说对于速度的优化也包含在重构中

压缩JS、CSS、image等前端资源(通常是由服务器来解决)
程序的性能优化(如数据读写)
采用CDN来加速资源加载
对于JS DOM的优化
HTTP服务器的文件缓存
```



## 19.开发及性能优化以及解决方案



```
开发及性能优化

1、规避javascript多人开发函数重名问题

命名空间

封闭空间

js模块化mvc（数据层、表现层、控制层）

seajs

变量转换成对象的属性

对象化

2、请说出三种减低页面加载时间的方法

压缩css、js文件

合并js、css文件，减少http请求

外部js、css文件放在最底下

减少dom操作，尽可能用变量替代不必要的dom操作

3、你所了解到的Web攻击技术

（1）XSS（Cross-Site Scripting，跨站脚本攻击）：指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。

（2）SQL注入攻击

（3）CSRF（Cross-Site Request Forgeries，跨站点请求伪造）：指攻击者通过设置好的陷阱，强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新。

 4、web前端开发，如何提高页面性能优化？

内容方面：

1.减少 HTTP 请求 (Make Fewer HTTP Requests)

2.减少 DOM 元素数量 (Reduce the Number of DOM Elements)

3.使得 Ajax 可缓存 (Make Ajax Cacheable)

针对CSS：

1.把 CSS 放到代码页上端 (Put Stylesheets at the Top)

2.从页面中剥离 JavaScript 与 CSS (Make JavaScript and CSS External)

3.精简 JavaScript 与 CSS (Minify JavaScript and CSS)

4.避免 CSS 表达式 (Avoid CSS Expressions)

针对JavaScript ：

1. 脚本放到 HTML 代码页底部 (Put Scripts at the Bottom)
2. 从页面中剥离 JavaScript 与 CSS (Make JavaScript and CSS External)
3. 精简 JavaScript 与 CSS (Minify JavaScript and CSS)
4. 移除重复脚本 (Remove Duplicate Scripts)



6、浏览器是如何渲染页面的？

渲染的流程如下：

1.解析HTML文件，创建DOM树。

   自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。

2.解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式；

3.将CSS与DOM合并，构建渲染树（Render Tree）

4.布局和绘制，重绘（repaint）和重排（reflow）



```

```
另外还可以说:
## 前端性能优化
   1. css方面优化
      1. 写一些公共的类，公共的css文件
      2. 做一些自己的组件
      3. 图标字体
      4. css压缩
   2. 图片优化
      1. 图片压缩
      2. 精灵图
      3. 把图片转为base64减小http请求
      4. 把图片放到cdn减少用户等待时间
      5. 图片的懒加载
   3. js优化
      1. 做一些自己的函数封装
      2. 用一些设计方法如原型和构造函数的式封装
      3. 用一些异步加载数据
      4. js代码压缩
      5. 及时释放闭包中不用的内存
      6. 少用一些字符串拼接
   4. 总体的优化
      1. cdn文件[cdn](http://img.blog.csdn.net/20160521222226952)
      2. 使用浏览器缓存，比如离线缓存
      3. CSS放在页面最上部，javascript放在页面最下面
      4. 预加载或懒加载
      5. 避免一些空的src
      6. 尽量减少HTTP请求数量
```



## 20 jquery 操作DOM 元素的常用方法



```javascript
jQuery操作DOM元素
　　HTML DOM常见操作:
　　查找节点,插入节点,删除节点,复制节点,替换节点,包裹节点.
  #jQuery查找元素的方法:
         $("#myELement")    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 
        $("div")           选择所有的div标签元素，返回div元素数组 
        $(".myClass")      选择使用myClass类的css的所有元素 
        $("*")             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass")

　　#jQuery插入元素的方法:
　　append(): 向每个匹配的元素内部追加内容.
　　appendTo(): 将所有匹配的元素追加到指定的元素中,即$(A).appendTo(B),是将A追加到B中.
　　prepend(): 向每个匹配的元素内部前置内容.
　　prependTo(): 将所有匹配的元素前置到指定的元素中,即$(A).prependTo(B),是将A前置到B中.
 
　　前面几个方法都是插入子元素,后面的这几个方法是插入兄弟元素.
　　after(): 在每个匹配的元素之后插入内容.
　　insertAfter(): 将所有匹配的元素插入到指定元素的后面.
　　before(): 在每个匹配的元素之前插入内容.
　　insertBefore(): 将所有匹配的元素插入到指定元素的前面.
 
　　

 
　　插入已有节点->移动节点
　　除了可以插入新建的节点之外,还可以选择已有节点,插入到别的地方,以完成节点的移动操作.
　　注意这里是移动操作,即原来的节点会改变位置:

<!DOCTYPE html>
<html>
	<head>
		<script src="/jquery/jquery-1.11.1.min.js">
		</script>
		<script>
			$(document).ready(function() {

				$("ul li:eq(0)").appendTo("ul");

			});
		</script>
	</head>
	<body>
		<ul>
			<li title="li1">1</li>
			<li title="li2">2</li>
			<li title="li3">3</li>
			<li title="li4">4</li>
			<li title="li5">5</li>
		</ul>
	</body>
</html>

 
　

 
#删除节点
　　jQuery中删除节点的方法:
　　remove(): 移除所有匹配的元素.
　　empty(): 删除匹配的元素集合中所有内容,包括子节点.注意,元素本身没有被删除.
 
　　关于remove()方法,有几点需要说明一下:
　　1.remove()方法的返回值:
　　remove()方法会返回被删除节点的jQuery对象.可以把这个对象插入到其他的地方.
　　所以也可以用这种方法来移动节点:
代码
<!DOCTYPE html>
<html>
<head>
<script src="/jquery/jquery-1.11.1.min.js">
</script>
<script>
$(document).ready(function(){

$("ul li:eq(0)").appendTo("ul");//move li method1

//move method2:
var removeLi = $("ul li:eq(0)").remove();//delete li
removeLi.appendTo($("ul"));//add removed li


});
</script>
</head>
<body>
<ul>
<li title="li1">1</li>
<li title="li2">2</li>
<li title="li3">3</li>
<li title="li4">4</li>
<li title="li5">5</li>
</ul>
</body>
</html>
代码

运行结果为:

　　注意直接写标签名(例如:appendTo(“ul”))和取jQuery对象(例如:appendTo($(“ul")))的结果一样.
 
　　2.remove()方法的参数:
　　remove()方法默认情况下会删除选择器选中的所有元素.
　　比如下面的代码将删除所有<ul>下的<li>:
//remove all li
$("ul li").remove();
　　remove()方法还可以接收参数,设置一些筛选条件,指定到底要删除其中的哪些节点.
　　比如除了指定title的,其他全部移除:
//remove some
$("ul li").remove("li[title!='li2']");
 

　　empty()方法:删除匹配元素集合中的所有子节点,清空内容.但是元素本身还存在.
　　比如:
//empty children
$("ul").empty();
　　会删除<ul>中的所有子节点.

　　而:
//empty content
$("ul li:eq(3)").empty();
　　会得到这样的效果:



 
 
#复制节点
　　jQuery中复制节点的方法:
　　clone(): 创建匹配元素集合的副本.
　　clone()方法返回被复制的节点.
　　看一个例子,每次点击<li>都复制同样的元素并添加在<ul>末尾:
代码
<!DOCTYPE html>
<html>
<head>
<script src="/jquery/jquery-1.11.1.min.js">
</script>
<script>
$(document).ready(function(){
$("ul > li").click(function(){
$(this).clone().appendTo("ul");
});
});
</script>
</head>
<body>
<ul>
<li title="li1">1</li>
<li title="li2">2</li>
<li title="li3">3</li>
<li title="li4">4</li>
<li title="li5">5</li>
</ul>
</body>
</html>
代码
 
　　注意,clone出来的<li>对象就没有click事件了,即点击复制添加出来的<li>,不会再添加新的<li>.
 
　　jQuery考虑到有时候会有需要clone所有的事件,所以clone方法可以带一个参数.
　　clone(true): 复制节点,包括所有的事件处理.
　　clone(false): 复制节点,但不包括事件处理.不带参数时默认是这种情况.
 
 
#替换节点
　　jQuery中替换节点的方法:
　　replaceAll(): 用指定的HTML内容或元素替换被选元素.
　　语法: $(content).replaceAll(selector).
　　replaceWith(): 用新内容替换所匹配到的元素.
　　语法: $(selector).replaceWith(content).
 
　　其中的content可以是HTML代码,可以是新元素,也可以是已经存在的元素.
 
　　关于用已有元素替换:
　　w3school的相关文档(http://www.w3school.com.cn/jquery/manipulation_replaceall.asp)中说:
　　"已经存在的元素不会被移动,只会被复制."这种说法是不正确的.
 
　　实际做了实验之后,发现用已有元素替换,原来的元素是会被移除的:
复制代码
<html>
<head>
<script type="text/javascript" src="/jquery/jquery.js"></script>
<script type="text/javascript">
$(document).ready(function(){
$("#button1").click(function(){
alert("click event");
$("#button1").replaceAll($("div"));

});
});
</script>
<style>
div{height:20px;background-color:yellow}
</style>
</head>
<body>
<p>
This is paragraph:
<div id="div1">This is a div 1</div>
<div id="div2">This is a div 2</div>
<p>
This is button area:
<br><button id="button1" class="btn1">Button1</button>


</body>
</html>
代码
　　页面初始状态:

　　点击按钮之后:

　　点击新得到的两个Button1,是可以弹出alert的,说明替换节点的时候连同节点事件一起放到了新的地方.
 
　　查看官方文档:
　　replaceAll(): http://api.jquery.com/replaceAll/
　　replaceWith(): http://api.jquery.com/replaceWith/
　　可以看到使用已有节点是不会复制该节点的,而是会移动该节点到新的地方.
 
 
 
相关杂项知识
　　1.关于变量命名的一点题外话:
　　变量命名习惯(不是标准):
　　var $v jQuery对象变量以$符号开头命名.
　　var v 普通HTML DOM对象变量.
　　但是个人觉得初学者用这样的命名可能会有点混乱,会比较难以区分什么时候是命名,什么时候是jQuery操作符.
　　所以目前的例子里先不这样用.
 
　　2.小知识: 在HTML标签的字符串前面加上$符号即可将其转换为jQuery对象,比如:
　　var child = $("<input type='text'/><br/>");
 
　　3.从第一个例子可以看出,JavaScript操纵DOM元素的方法和jQuery的相关方法名称区别如下:
　　JavaScript: appendChild(), removeChild().
　　jQuery: append(), remove(). 不过这个remove()移除的是自身.
 
 
 
```



## 21常见的布局方式

栅格布局

```

```

骰子

垂直居中

双飞翼布局

```
双飞翼布局实际上就是圣杯布局的变体,三列布局，两边定宽，中间自适应
```

圣杯布局

```
圣杯布局是一种三列布局，两边定宽，中间自适应：
圣杯布局的原理就是当子元素处于浮动状态时，设置负margin，子元素会叠盖到兄弟元素之上。
```

流式布局

sticky footer布局

移动端导航栏案例

移动端图文列表实例

# 前端人事题

## 1.为什么从上一家公司离职



# 午间提问

## 1.jquery中的增删改查

```
查:
    找标签: 	$("div"),$("#box"),$(".box")
    选择器筛选: $('.box li:eq(4)')  获取索引为4的li
              $('.box li:last')   box里最后一个li
              $('.box li:first')  box里第一个li
    表单筛选:   $('.box input:checkbox') 多选框
    方法找标签: 	
            $('.box li').eq(0)      box里的第一个li 
            $('.box li').first()    box里的第一个li 
            $('.box li').last()     box里的最后一个li
删:
        标签.remove()
        
改:		标签.html("") 
        标签.text()设置为空字符串
```

## 2.jquery封装的ajax的参数

```js
data : 传递参数
type : 发送请求的方式
url : 地址栏
dataType : 返回数据的格式
success : function(){} 成功响应的函数

/*封装的时候考虑到跨域的问题,可以设置dataType为jsonp,来解决,会动态创建一个script标签,利用了src属性的天然可跨域的特点,发送异步请求,局限是只对get请求有效;
第二种方法是设置cors模块,本质是设置了请求头,可以允许特定页面或者所有的页面都能发送跨域请求/*

/*另外还有一个问题,就是回调地狱,这种重重嵌套的请求不仅可读性不强,维护也比较困难,可以用es6中的promise解决这个问题,promise是先创建一个promise对象,要传入一个函数,此函数有resolve 和 reject两个形参,在这个函数发送异步请求,再用.then()的方法单独处理请求回来的数据或结果,让请求和处理分开,没有回调地狱的问题*/

```

## 3.使用模板引擎的步骤

```
1.引入js文件
2.创建script模板,写一个id
3.在模板中写入结构,将数据添加进去
4.调用方法:template(模板id,数据)
```

## 4.数组的增删改查

```
push()		从最后追加
pop()		从最后删除
unshift()	从开头追加
shift()		从开头追加
arr[旧索引]=值	
arr[新索引]=新值
```

## 5.对象的增删改查

```
对象.属性 = "";
对象.方法 = function()[};
如果属性原来有,就是修改,没有就是增加
```

## 6.数据类型

```
简单数据类型:字符串String,数值Number,布尔Boolean,未定义Undefined,Null 
存在栈中
复杂数据类型:数组,函数,对象
存在于堆中
```

## 7.DOM中的增删改查

```
removeChild()	删
replaceChild()	改
createElement() 增
appendChild()	增
getElementById (TagNmae || Name || ClassName)	查
querySelector()		查
querySelectorAll()	查
```

## 8.函数的几种定义方法,几种调用方式和this的指向



| 调用方式     | 非严格模式     | 备注                         |
| ------------ | -------------- | ---------------------------- |
| 普通函数调用 | window         | 严格模式下是 undefined       |
| 构造函数调用 | 实例对象       | 原型方法中 this 也是实例对象 |
| 对象方法调用 | 该方法所属对象 | 紧挨着的对象                 |
| 事件绑定方法 | 绑定事件对象   |                              |
| 定时器函数   | window         |                              |

## 9.display none和visibility hidden的区别

```
display none和visibility hidden 都是让元素隐藏
display none 元素隐藏之后不占位置
visibility hidden 元素隐藏之后占位置
```

## 10.ajax的几个属性

```
type : 请求方式,
dataType : 返回数据格式,
url : 请求地址,
data : 传递参数{},
async:false 将此次请求变为同步请求
beforeSend:function(){}, 发送请求之前执行的函数
success : function(){}  响应成功后要执行的函数
```

## 11.循环遍历的方法

```
1.DOM中的for循环
<script src="js/jquery-1.12.2.min.js"></script>
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
    </ul>
    <script>
        var lis = document.getElementsByTagName("li");
        for (var i = 0; i < lis.length; i++){
            console.log(lis[i]);
            
        }
        var arr = [10,22,12,14,31,51,28]
    </script>
</body>
```

```
2.DOM中的forEach方法 等价于for
	arr.forEach(function(item,index){
        
	})
```

```
3. filter 过滤
var arrFilter = arr.filter(function(item,index){
    //一定要有return,返回满足条件的结果,是数组
    return item > 50;
});
```

```
4. map 映射
var arrMap = arr.map(function(item,index){
    return item > 50; //返回的是数组
})
```

```
5. every 是每一个的意思,全都满足就返回true,有一项不满足就返回false会返回true/false
varflagEvery= arr.every(function( item,index){
    retrun item > 2
});
```

```
6. some 一些,只要有一个条件满足就返回true,全都不满足就返回false
var flagSome = arr.some(function(item.index){
	return item > 2;
});
```

```
7. findIndex  的特点:当回调函数return true时,会结束循环并把当前遍历到的元素索引返回给调用者,
var index = arr.some(function(item.i){
	if(i == id){
        retrun true
	}
});
```



## 12.上传代码到码云的步骤

1. git clone http://...
2. 将要上传的文件拖到复制出来的文件夹根目录中,git add * 
3. git commit -m '注释'
4. git push

## 13.动态创建表格

先用createElement创建table,追加到body中,再分别创建thead , tbody,追加到table中,创建th追加到thead中,创建tr追加到tbody中,创建td追加到tr中

```js
<script>
    // var s = {name: 'zs', subject: '语文', score: 90};
    // 模拟数据
    var datas = [
      {name: 'zs', subject: '语文', score: 90},
      {name: 'ls', subject: '数学', score: 80},
      {name: 'ww', subject: '英语', score: 99},
      {name: 'zl', subject: '英语', score: 100},
      {name: 'xs', subject: '英语', score: 60},
      {name: 'dc', subject: '英语', score: 70}
    ];

    // 表头数据
    var headDatas = ['姓名', '科目', '成绩', '操作'];

    // 1 创建table 元素
    var table = document.createElement('table');
    my$('box').appendChild(table);
    table.border = '1px';
    table.width = '400px';

    // 2 创建表头
    var thead = document.createElement('thead');
    table.appendChild(thead);

    var tr = document.createElement('tr');
    thead.appendChild(tr);
    tr.style.height = '40px';
    tr.style.backgroundColor = 'lightgray';

    // 遍历头部数据，创建th
    for (var i = 0; i < headDatas.length; i++) {
      var th = document.createElement('th');
      tr.appendChild(th);
      // th.innerText
      setInnerText(th, headDatas[i]);
    }
    
    // 3 创建数据行
    var tbody = document.createElement('tbody');
    table.appendChild(tbody);
    for (var i = 0; i < datas.length; i++) {
      // 一个学生的成绩 {name: 'zl', subject: '英语', score: 100},
      var data = datas[i];
      tr = document.createElement('tr');
      tbody.appendChild(tr);
      /*var datas = [
          {name: 'zs', subject: '语文', score: 90},
          {name: 'ls', subject: '数学', score: 80},
          {name: 'ww', subject: '英语', score: 99},
          {name: 'zl', subject: '英语', score: 100},
          {name: 'xs', subject: '英语', score: 60},
          {name: 'dc', subject: '英语', score: 70}
      ];*/
      // 遍历对象
      for (var key in data) {
        console.log(key, data[key])
        var td = document.createElement('td');
        tr.appendChild(td);
        setInnerText(td, data[key]);
      }
      // 生成删除对应的列
      td = document.createElement('td');
      tr.appendChild(td);
      // 删除的超链接
      var link = document.createElement('a');
      td.appendChild(link);
      link.href = 'javascript:void(0)';
      setInnerText(link, '删除');
    }
  </script>
```

## 14. TCP三次握手

## 15.三个盒子在一个父盒子中,父盒子100% ,高40px,左右盒子固定,左右盒子都设置宽高100px,怎样让中间盒子自适应, 

方法一: 父盒子设置弹性布局,中间盒子不用设置宽,设置flex:1,占据剩余空间的100%;

方法二: 左右盒子定位在父盒子左右两边 , 给中间盒子设置盒模型,宽度100%,再设置padding:0 100px;

方法三: 左右盒子定位在父盒子左右两边 , 给中间盒子设置盒模型,再设置margin:0 100px;

## 16.全屏窗口,一边固定,一边自适应

```
*{
    margin:0;
    padding:0;
    box-sizing:border-box;
}
html,body{
    width:100%;
    height:100%;
}
.leftP{
    float:left;
    width:100%;
    height:100%
}
.right{
    height:100%;
    margin-left:100px;
    
}
```



## 17.过滤要0-100价格的商品

​	先用jquery中的filter把商品所有的0-100商品过滤出来,再将之从小到大排列

```js
//返回带有类名 "intro" 的所有 <p> 元素： 
$("p").filter(".intro");
```

## 18.省市县三级联动

​	先将省市县三个下拉选项框动态创建出来(createElement   appendChild),在每个select上都有一个changed事件,在内容改变时,发送ajax请求,比如选择完省,就发送请求返回市的选项,选择完市就返回县的选项

## 19.如何取出对象中的方法

```
var obj = {};
obj.fn = function(){
    console.log(111)
}
//方法一:
obj.fn();	//111
//方法二:
obj['fn']();	//111
```

## 20.检测数据类型

```js
//第一种方法:
typeof  []  // Object

//第二种方法是全能的
Object.prototype.toString.call({})   // "[object,object]"
Object.prototype.toString.call([])   // "[object,array]"
```

## 21.浅拷贝和深拷贝

```
var a = {n:18,m:20}
var b = JSON.stringify(a)
var c= JSON.parse(c)
console.log(c)  // {n:18,m:20}
c.p = 30
console.log(c)  // {n:18,m:20,p:30}
console.log(a)	// {n:18,m:20}
```



## 22.主流浏览器的内核

```
1、IE浏览器内核：Trident内核，也是俗称的IE内核；

2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；

3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；

4、Safari浏览器内核：Webkit内核；

5、Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核；

6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；

7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；

8、百度浏览器、世界之窗内核：IE内核；

9、2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了；

10、UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。。
```



------

# 【vuejs面试题】务必熟知的vuejs面试题「务必收藏」



## vuejs 基础必备

**1、active-class 是哪个组件的属性？嵌套路由怎么定义**

　　(1)、active-class 是 vue-router 模块的 router-link 组件的属性
　　(2)、使用 children 定义嵌套路由

**2、怎么定义 vue-router 的动态路由? 怎么获取传过来的值**

　　在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。

　　使用 router 对象的 params.id 获取

**3、vue-router 有哪几种导航钩子?**

　　三种，

　　(1)、全局导航钩子

　　　　router.beforeEach(to, from, next),

　　　　router.beforeResolve(to, from, next),

　　　　router.afterEach(to, from ,next)

　　(2)、组件内钩子
　　　　beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave

　　(3)、单独路由独享组件

　　　　beforeEnter

**4、v-model 是什么？怎么使用？ vue中标签怎么绑定事件**

　　v-model 可以实现双向绑定，

　　绑定事件：<input @click="rdhub.cn" />

**5、axios 是什么？怎么使用？描述使用它实现登录功能的流程**

　　axios 是请求后台资源的模块。 npm i axios -S

　　如果发送的是跨域请求，需在配置文件中 config/index.js 进行配置

**6、vuex 是什么？怎么使用？哪种功能场景使用它**

　　vuex 是专门为 vue 开发的数据状态管理模式。组件之间数据状态共享

　　使用场景：音乐播放、登录状态、购物车

```
// 新建 store.js
import vue from 'vue'
import vuex form 'vuex'
vue.use(vuex)
export default new vuex.store({
    //...rdhub.cn
})
 
//main.js
import store from './store'
...
```

**7、mvvm 框架是什么？它和其他框架(jquery) 的区别是什么？哪些场景适合**

　　mvvm 是 model + view + viewmodel 框架，通过 viewmodel 连接数据模型model 和 view

　　区别：vue 是数据驱动，通过数据来显示视图层而不是节点操用

　　场景：数据操作比较多的场景，更加快捷

**8、自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数**

　　全局定义指令：在 vue 对象的 directive 方法里面有两个参数, 一个是指令名称, 另一个是函数。

　　组件内定义指令：directives

　　钩子函数: bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)

　　钩子函数参数： el、binding

**9、说出至少 4 种 vue 当中的指令和它的用法**

　　v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)

**10、vue-router 是什么?它有哪些组件**

　　vue-router 是 vue 的路由插件,

　　组件：router-link router-view

**11、vue 的双向绑定的原理是什么**

　　vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

Object.defineProperty() 的原理:

```
var Book = {}
var name = '';
Object.defineProperty(Book, 'name', {
  set: function (value) {
    name = value;
    console.log('你取了一个书名叫做' + value);
  },
  get: function () {
    return '《' + name + '》'
  }
})
 
Book.name = 'vue权威指南';  // 你取了一个书名叫做vue权威指南
console.log(Book.name);  // 《vue权威指南》
```



　　具体步骤：

　　第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

　　第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

　　第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:

　　1、在自身实例化时往属性订阅器(dep)里面添加自己

　　2、自身必须有一个update()方法

　　3、待属性变动dep.notice()通知时，能调用自身的 update() 方法，并触发Compile中绑定的回调，则功成身退。

　　第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

**12、请详细说下你对vue生命周期的理解**

　　总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

　　**创建前/后**

　　在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。

　　在created阶段，vue实例的数据对象data有了，$el还没有。

　　**载入前/后**

　　在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。

　　在mounted阶段，vue实例挂载完成，data.message成功渲染。

　　**更新前/后**

　　当data变化时，会触发beforeUpdate和updated方法。

　　**销毁前/后**

　　在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

## vuex 面试题

**1、有哪几种属性**

　　有 5 种，分别是 state、getter、mutation、action、module

**2、vuex 的 store 特性是什么**

　　(1) vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data

　　(2) state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新

　　(3) 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性

**3、 vuex 的 getter 特性是什么**

　　(1) getter 可以对 state 进行计算操作，它就是 store 的计算属性

　　(2) 虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用

　　(3) 如果一个状态只在一个组件内使用，是可以不用 getters

**4、vuex 的 mutation 特性是什么**

　　action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态

　　action 可以包含任意异步操作

**5、vue 中 ajax 请求代码应该写在组件的methods中还是vuex 的action中**

　　如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里

　　如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回

**5、不用 vuex 会带来什么问题**

　　可维护性会下降，你要修改数据，你得维护3个地方

　　可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的

　　增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背

## 生命周期面试题

**1、什么是 vue 生命周期**

　　vue 实例从创建到销毁的过程就是生命周期。

　　也就是从开始创建、初始化数据、编译模板、挂在 dom -> 渲染、更新 -> 渲染、写在等一系列过程

**2、vue生命周期的作用是什么**

　　生命周期中有多个事件钩子，让我们在控制整个 vue 实例的过程时更容易形成好的逻辑

**3、vue生命周期总共有几个阶段**

　　8个阶段：创建前/后、载入前/后、更新前/后、销毁前/后

**4、第一次页面加载会触发哪几个钩子**

　　第一次加载会触发 beforeCreate、created、beforeMount、mounted

**5、DOM 渲染在哪个周期中就已经完成**

　　mounted

**6、简述每个周期具体适合哪些场景**

　　生命周期钩子的一些使用方法：

　　beforecreate : 可以在这加个loading事件，在加载实例时触发

　　created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

　　mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数

　　beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom

### 路由优化(路由懒加载)

像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时

简单的说就是：进入首页不用一次加载过多资源造成用时过长！！！

```
const Home = resolve => require(['@/components/Home'], resolve);
const Login = resolve => require(['@/components/Login/Login'], resolve);
export default [
  {
    path: '/',
    name: 'Home',
    component: Home
  },]
```

## js设计模式

### 1、js工厂模式

```
 1 var lev=function(){
 2        return  "嘿哈"; 
 3 };
 4 function Parent(){
 5     var Child = new object();
 6     Child.name = "李小龙";
 7     Child.age = "30";
 8     Child.lev = lev;
 9     return Child;
10         
11 };
12 var x=Parent();
13  alert(x.name);
14  alert(x.lev());
```

说明：

1. 在函数中定义对象，并定义对象的各种属性，虽然属性可以为方法，但是建议将属性为方法的属性定义到函数之外，这样可以避免重复创建该方法。
2. 引用该对象的时候，这里使用的是 var x = Parent()而不是 var x = new object(); 因为后者可能会出现很多问题（前者也成为工厂经典方式，后者称之为混合工厂方式），不推荐使用new的方式使用该对象。
3. 在函数的最后返回该对象。
4. 不推荐使用这种方式创建对象，但应该了解。  

### 2、js构造函数模式

```
 1 var lev=function(){
 2        return  "嘿哈"; 
 3 };
 4 function Parent(){
 5     this.name = "李小龙";
 6     this.age = "30";
 7     this.lev = lev;     
 8 };
 9 var x=Parent();
10  alert(x.name);
11  alert(x.lev());
```

说明：

1. 与工厂方式相比，使用构造函数方式创建对象无需在函数内部创建对象，而使用this指代，并而函数无需明确return。
2. 同工厂模式一样，虽然属性的值可以为方法，仍建议将该方法定义在函数之外。
3. 同样的，不推荐使用这种方式创建对象，但仍需了解。

### 3、js原型模式

```
 1 var lev=function(){
 2        return  "嘿哈"; 
 3 };
 4 function Parent(){
 5     Parent.prototype.name = "李小龙";
 6     Parent.prototype.age = "30";
 7     Parent.prototype.lev = lev;     
 8 };
 9 var x=Parent();
10  alert(x.name);
11  alert(x.lev());
```

说明：

1. 函数中不对属性进行定义。
2. 利用prototype属性对属性进行定义。
3. 同样的额，不推荐使用这样的方式创建对象。

### 4、构造函数+原型的js混合模式（推荐）

```
 1 function Parent(){
 2     this.name = "李小龙";
 3     this.age = "30";     
 4 };
 5 Parent.prototype.lev=function(){
 6 return this.name;
 7 }
 8 var x=Parent();
 9  alert(x.name);
10  alert(x.lev());

```

说明：

1. 该模式是指混合搭配使用构造函数和原型方式。
2. 将所有的属性，不是方法的定义在函数中（构造函数的方式），将所有属性值为方法的利用prototype在函数之外定义（原型方式）。
3. 推荐使用这样的方式创建对象，这样有好处。

### 5、构造函数+原型的动态原型模式（推荐）

```
 1 function Parent(){
 2     this.name = "李小龙";
 3     this.age = "30"; 
 4     if(typeof Parent.lev == "undefined"){
 5         Parent.prototype.lev = function(){
 6             return this.name;
 7         }
 8         Parent.lev = true;
 9     }    
10 };
11 
12 var x=Parent();
13  alert(x.lev());

```

说明：

1. 动态原型方式可以理解为混合构造函数，原型方式的一个特例。

2. 该模式中，属性为方法的属性直接在函数中进行了定义，但是因为 

     

   ```
   if(typeof Parent.lev == "undefined"){
             Parent.prototype.lev = function(){
                 return this.name;
             }
             Parent.lev = true;
        }   从而保证创建该对象的实例时，属性的方法不会被重复的创建。
   
   ```

## 前端渲染和后端渲染

```
前端渲染:前端用接口拿到数据用模板引擎去渲染数据
后端渲染:直接后端人员拿到数据后就把数据渲染到页面上,不用前端人员来渲染页面
两者的区别可以直接查看网页源代码就可以看出来,前端渲染出来的页面的动态数据都是模板引擎 , 后端渲染出来的页面的动态数据都是固定数据
前端渲染是前后端彻底分离的思想,后端渲染还是前后端混合开发的思想
//如果要采用前端渲染,一般都会设计成前后端分离的模式,而且为了让前后端彻底分离,并且实现前端模块化
//一般情况下,前后端通信都是通过接口进行
//此时一般会有跨域的问题,跨域一般直接通过CORS解决了
//但是,session 和 cookie不能跨域
//此时出现了一个更好的一个解决方案: JWT : JSON Web Token
```



## SPA单页面应用

```
所有SPA singer page application 单页面程序都有一个致命的问题,无法 SEO 优化
SEO 如果是多页面,每个页面都有meta标签,属性为description , 单页面只有一个html页面,只有一个meta标签,不管搜索什么,点击进来的看到的都是同一个页面 , 无法进行SEO优化
单页面程序还有一个缺点,首屏加载速度奇慢 , 因为页面一加载,就要加载所有的js文件,都打包成了一个bunder.js, 

为了解决这两个问题,提出了 SSR serve side render 服务端渲染  --- vue里面的 nuxt.js  是服务端渲染的框架


获取验证码 , 如果是跨域其请求注册,参数中有验证码 , 需要在请求拦截中设置 每次请求携带 cookie过去 , 设置一行 withCredentials = true  使用凭证 , 还有一种方式,可以全局配置: axios.defaults.withCredentials = true

注册成功后,会返回token ,这个时候,直接将token存储到本地缓存中,还有用户信息,再携带跳转到home中,让用户注册成功直接自动登录,体验更好 , 而且,存储了token之后,就算跳转到登录页,由于导航守卫,也会让你跳转到首页

移动端建议用vant-ui
pc端建议用 element-ui

静止的数据配置都可以配置在全局,但是如果随时能修改的东西最好在拦截器中配置,比如token

模块化Vuex  : 用脚手架3版本以上的时候,总动已经帮你把Vuex里的store抽取出来了,以后项目越来越大的时候,还可以把 state  mutations  getters 都抽取出来
```



## 面试总结:

人事问题 : 位置,老板名字,住宿,距离,开发周期,团队

```
准备一套说辞 ; 不要慌,让她看出来了; 面试的时候不要一起进门 ; 
```

技术: 原生js都忘了  /  实际功能的实现  / 项目中问到的问题  /  项目的优化  / 兼容性问题 / 双向数据绑定的原理 / es6 (项目中哪里用到了) /  熟悉自己的项目:哪些功能怎样实现的,遇到哪些问题

```
对待自己不会的问题 , 要坦然面对 , 老板是不会得罪技术的 , 不要怂 , 面对会的和不会的问题,态度不要两级分化
适当的展示自己的学习能力
身份的转换 , 不要叫老师 , 不要再以为自己是学生 , 少说之前我学的时候... , 多说我之前开发的时候...
遇到的问题 : 有深度有难度
```

简历方面: 要有自己的特点,比如说封装过哪些东西 , 对优化有自己的见解 , 对js非常熟练

自我介绍 : 200字左右 , 先介绍个人信息 , 公司信息 , 离职原因 , 项目 , 举例(大家目前的距离都停留在demo级 , 要提升到项目中 , 往较大的功能说 , 比如说点击事件 , 有弹出层 , 或者有请求发出, 发送请求,得到数据,渲染页面) , 看到网站上有哪些亮点功能看看自己是否能够实现,能的话,也可在面试中举例出来 , , 举例一定要贴合功能 , 不要仅仅停留在演示效果上 , 

技能点: 龙头公司不问员工的成长 ,只问基层和底层 ; 大型公司比较关注 基础比较多 , 当前学习能力 , 框架底层的理解上框架 , ; 中小型公司:只能框架和项目

外面必问 : 生命周期 , MVVM原理 , 组件的理解 , 封装 , 数据驱动 , 常用的指令 , router  , resource , filter

原生js , es6 (), h5c3

前后端联调 : 线上联调/线下联调

```js
线下联调: 后端人员在电脑上搭建虚拟主机 , 编写接口服务器,路由 ; 办公电脑局域网的ip或者是 后端人员的虚拟主机的地址

Host映射 : 让别人可以访问你的虚拟主机

后端出一个接口文档 , 约定数据格式 , 协定数据的键名 , 说明每个键名的含义改 , 要么就是前端自己将就

出现问题 ; 404 403 ,网络状态码异常 , 后端的锅
数据不对 , 数据格式不对 , 找后

工期不同步 , 丢锅
```



```js
线上联调 : 后端把测试代码放在测试服务器上 , 真实域名 , 线上测试真实数据库
路由 ; 真实线上的地址
```

我叫袁俊双 , 25岁 , 2016年毕业于武汉工程大学 化学工程与工艺专业 , 之前在广州喧风信息科技有限公司 , 由于老板回笼不了资金,发不出工资 , 所以就回武汉了, 在公司做了移动端 , 后台管理系统这两类项目(不要在这里说自己具体负责的页面功能),



面试之后归纳总结,遇到的哪些新问题

1.软件安装:

```js
1. 编辑器 (atom  vscode  sublime)
2. 手机端模拟 -- 夜神
3. 虚拟机 centos
4. node
```

2.技能点:

```js
1. h5c3   H5+  websocket(市面上手机端所有高级功能只能用原生js)
2. ajax --- 官方的请求数据	 ajax2(promise+ajax+from)
3. jsonp --- 野路子出生
4. cors node--- 官方实现跨域
5. vue+axios+node+webpack+vuex+vue-router+es2(前后端联调)+mock.js(没有借口)+git+pm2()
6. 前端安全 xss 攻击(怎么防止别人攻击)
7. 打包App
8. 单线程+多线程+多进程  (js + node) node fs  http url md5 os
	一个进程可以开多个线程
```

3.业务逻辑需求demo

```js
1. tabbar 栏切换 ( js  / vue)
2. 登录拦截 (vue  axios  +router)
3. 不买会员试看5分钟,或者试听1分钟 ( video  audio  node)
4. 权限控制(switch  case + routes)
5. 办理银行卡( from + 正则 + ajax + node+mysql)

```

vue的缺点:

```js
1. 单页面 index.html	seo优化实现不了所以退出来服务端渲染 , 只适合中小型项目开发,周期短
2. 可以实现多页面

```

vue优势:

```js
1. 适合中小型项目开发,周期短
2. 渐进式  ++生态圈
3. ssr服务端渲染
4. 前端路由+后端路由
```

# 兼容性问题

```js
1. css3兼容性解决:

如果使用的媒体查询(css3中的属性),就引入 respond.js
respond.js : 解决IE 6,7,8 不兼容 css三的问题,其他都不用弄

2. h5的兼容性问题

引入 html5shiv.js 文件,解决IE9一下的浏览器对h5新标签的不兼容的问题

所以: 只要要使用 h5c3 就直接引入上面两个文件,就可以解决了


3.IE浏览器解决方法:(ie6-8)
 borwserhacks : 可以搜索哪些浏览器上有什么兼容性问题

4. js的兼容性问题:

MDN 中搜索 javascript , 每个属性和方法的说明文档最后,都会有支持哪些浏览器

5. what-is-modernizr (上面的几种方法基本上已经能够解决兼容性问题了)

```



# 前端测试

```js
1.真机模拟测试(ios , Android) Testin 云测 --这是测试人员做的事情,前端也可以看一看,学一学,模拟真机测试

2. 在 MAC(苹果电脑) 上才能装的 xcode 也可以测试



3. Browsersync--前端用得最多的本地测试--超级好用,自己改代码的时候,就可以看到每个设备上的不同效果,用 npm装包,然后在项目中运行命令

4. http-server (线上测试) 
安装包,在当前目录下执行 http-serve 命令 , 本地测试给你两个端口号,一个本地的,一个映射的网址,别人可以访问

一般3和4 是一起配合使用
```



# 性能提升

```js
1.图片压缩:--tinypng网站,将图片传上去,压缩后下载下来,图片看起来没有变,如果项目经理要你提升性能,没办法就把所有图片压缩一遍

2.css代码压缩:

3. js代码压缩:--jsmin网站

4. 精灵图

5. 使用svg:将图片转化为一段svg代码,转化为svg后直接复制使用 不会失真,占用的内存非常小

```



# App打包

注意:打包的项目根目录中就要有index文件

```js
1.phoneGap--跨平台生成打包的框架,被收购了, Cordova,打包之后,就可以调用手机摄像头等,但是很麻烦,所以中国人用 APICcloud

2.APICloud -- 注册,有id -- 创建应用 -- 选择
端开发是前端,云开发是后端

端设置
证书--一键生成证书(安卓的一键生成就行,  ios证书要上传,自己去申请,)
代码--在git上找项目的时候,复制代码地址的时候只能用https不能用SSH
模块--模块库--添加QQ aliPay  wxPay  添加的模块表示可以调用这些接口
云编译

Database  --带_ 的东西最好不要去改它,是私有的数据,不希望被改变的

API调试
```

# webpack配置文件

```js
const path = require("path")

//第二步,在配置文件最上面导入webpack模块
const webpack = require('webpack')

//导入html-webpack-plugin插件,再去plugins创建插件对象
const htmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    //手动指定入口和出口,路径要用path模块
    //entry 入口可以用相对路径或者绝对路径
    entry: path.join(__dirname,'./src/main.js'),
    //output 输出只能用绝对路径
    output:{
        path:path.join(__dirname,"./dist"), //指定打包好的文件
        filename:'bundle.js'  //指定输出的文件的路径
    },
    mode:"development",
    //在配置文件中配置devServer的指令
    devServer:{
        open:true,
        port:3002,
        contentBase:'./src',
        //配置热更新开启这里有三步
        //第一步:hot:true
        hot:true
        //第二步,在配置文件最上面导入webpack模块
        //第三步,在plugins节点中,创建热更新对象
    },
    //在plugins节点下创建插件对象
    plugins:[
        //开启器热更新第三步,在plugins节点中,创建热更新对象
        new webpack.HotModuleReplacementPlugin(),
        //创建html-webpack-plugin插件对象
        new htmlWebpackPlugin({
            //如果不传入配置项,还是会在服务器根目录下创建一个index.html,并且引用了bundle.js,但是index.html没有其他内容,空页面
            //创建一个内存中的html页面,其中会自动引入之前打包好放在内存中的bundle.js,可以查看网页源代码查看到
            template: path.join(__dirname,'./src/index.html'), //指定模板页面,可以使用相对路径或者绝对路径
            // filename:'index.html' //指定在内存中生成的页面的名称,默认就是index.html
        })
    ],
    module:{
        rules:[
            //css-loader是允许你将css文件进行编译,
            //style-loader 用于将css代码用js动态创建style标签插入到index.html页面中,让其起作用,减少请求外部资源的次数
            /* use 使用 loader时,顺序是固定的从右到左的加载 */
            /* 所以这里的style-loader 和css-loader的顺序不能颠倒 */
            {test: /\.css$/,use:['style-loader','css-loader']},
            /* 配置less文件 */
            {test: /\.less$/,use:['style-loader','css-loader','less-loader']},
            /* 配置scss文件 */
            {test: /\.scss$/,use:['style-loader','css-loader','sass-loader']},
            /* 配置图片 */
            {
                test: /\.(png|jpg|jpeg|bmp|gif)$/,
                use:[{
                    loader:'url-loader',
                    options:{
                        limit:81920 
                    }
                }]
            },
            /* 配置字体图标 */
            {test: /\.(eot|svg|ttf|woff|woff2)$/, use:['url-loader']},
            // 配置 Babel 来转换高级的ES语法
            { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }, 
        ]
    }
}
```

# less预处理器

```js
less的使用:

@charset "utf-8"
 
less中的注释:
/**/中可以写注释,可以被编译
// 也可以写注释,但是该注释在编译时会自动过滤掉

LESS中的变量：
less中想声明变量的话，一定要用@开头，基本形式为:@变量名：值；
比如: 
@white:#ffffff;
@width:100%;
.box{
	width:@width;
	color:@white;

}
编译之后就会变成:
.box{
	width:100%;
	color:#ffffff;
}

混合变量:

-定义好的一个类的样式可以在另一个类中引用
上面已经定义好了 .box的样式
.box1{
	.box;
	background-color:@white;
}
编译之后就会变成:
.box1{
	width:100%;
	color:#ffffff;
	background-color:@white;
}

混合变量-可带参数的:
.border_03(@border_width){
	border:solid yellow @border_width;
}

混合变量-带默认值的 , 这里的@border_width与上面的变量同名无影响,只在这个里面有效
.border_04(@border_width:10px){
	border:solid yellow @border_width;
}

运算：
-less中任何数字、颜色或者变量都可以参与运算（如+ - * /），运算应该被包裹在括号中。例如：
@test:300px;
.box_01{
	width:(@test - 20)*5);
	color:#ccc - 10;
}

嵌套规则：
-less中最有意思的小东西，有两种用法

-对伪类使用 .& ：hover或focus

-对链接的使用-&-item
a{
	float:left;
	//&代表他的上一级选择器
	&:hover{
		color:red;
	}
}

·arguments变量：

-@arguments包含了所有传递进来的参数

-如果你不想单独处理每一个参数的话就可以这样写：
.bor(@w:30px,@c:red,@xx:solid){
	border:@arguments;
}
.test_arguments{
	.bor();
}

编译后的:
.test_arguments{
	border:30px #ff0000 solid;
}

避免编译:
有时候我们需要输出一些不正确的CSS语法或者使用一些LESS不认识的专有语法，要在输出这样的值的字符前加上一个~

例如：
//避免编译
.test_03{
	width:~'calc(300px-30px)';
}
编译后的css:
.test_03{
	width:calc(300px-30px);
}
```

